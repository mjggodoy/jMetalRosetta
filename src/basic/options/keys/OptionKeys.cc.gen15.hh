namespace templates { BooleanOptionKey const force_native_topology( "templates:force_native_topology" );  }
namespace templates { RealOptionKey const topology_rank_cutoff( "templates:topology_rank_cutoff" );  }
namespace templates { IntegerOptionKey const min_frag_size( "templates:min_frag_size" );  }
namespace templates { IntegerOptionKey const max_shrink( "templates:max_shrink" );  }
namespace templates { IntegerOptionKey const shrink_step( "templates:shrink_step" );  }
namespace templates { IntegerOptionKey const shrink_pos_step( "templates:shrink_pos_step" );  }
namespace templates { IntegerOptionKey const min_padding( "templates:min_padding" );  }
namespace templates { IntegerOptionKey const min_align_pos( "templates:min_align_pos" );  }
namespace templates { IntegerOptionKey const max_align_pos( "templates:max_align_pos" );  }
namespace templates { namespace cst { BooleanOptionKey const cst( "templates:cst" );  } }
namespace templates { namespace cst { IntegerOptionKey const topN( "templates:cst:topN" );  } }
namespace templates { namespace cst { RealOptionKey const wTopol( "templates:cst:wTopol" );  } }
namespace templates { namespace cst { RealOptionKey const wExtern( "templates:cst:wExtern" );  } }
namespace templates { namespace fragsteal { BooleanOptionKey const fragsteal( "templates:fragsteal" );  } }
namespace templates { namespace fragsteal { IntegerOptionKey const topN( "templates:fragsteal:topN" );  } }
namespace templates { namespace fragsteal { RealOptionKey const wTopol( "templates:fragsteal:wTopol" );  } }
namespace templates { namespace fragsteal { RealOptionKey const wExtern( "templates:fragsteal:wExtern" );  } }
namespace unfolded_state { BooleanOptionKey const unfolded_state( "unfolded_state" );  }
namespace unfolded_state { FileOptionKey const unfolded_energies_file( "unfolded_state:unfolded_energies_file" );  }
namespace unfolded_state { FileOptionKey const split_unfolded_energies_file( "unfolded_state:split_unfolded_energies_file" );  }
namespace unfolded_state { StringOptionKey const split_unfolded_energies_atom_type( "unfolded_state:split_unfolded_energies_atom_type" );  }
namespace wum { BooleanOptionKey const wum( "wum" );  }
namespace wum { IntegerOptionKey const n_slaves_per_master( "wum:n_slaves_per_master" );  }
namespace wum { IntegerOptionKey const n_masters( "wum:n_masters" );  }
namespace wum { IntegerOptionKey const memory_limit( "wum:memory_limit" );  }
namespace wum { StringOptionKey const extra_scorefxn( "wum:extra_scorefxn" );  }
namespace wum { FileOptionKey const extra_scorefxn_ref_structure( "wum:extra_scorefxn_ref_structure" );  }
namespace wum { IntegerOptionKey const extra_scorefxn_relax( "wum:extra_scorefxn_relax" );  }
namespace wum { RealOptionKey const trim_proportion( "wum:trim_proportion" );  }
namespace blivens { BooleanOptionKey const blivens( "blivens" );  }
namespace blivens { namespace disulfide_scorer { BooleanOptionKey const disulfide_scorer( "blivens:disulfide_scorer" );  } }
namespace blivens { namespace disulfide_scorer { RealOptionKey const nds_prob( "blivens:disulfide_scorer:nds_prob" );  } }
namespace blivens { namespace disulfide_scorer { RealOptionKey const cys_prob( "blivens:disulfide_scorer:cys_prob" );  } }
namespace blivens { StringOptionKey const score_type( "blivens:score_type" );  }
namespace cmiles { BooleanOptionKey const cmiles( "cmiles" );  }
namespace cmiles { namespace kcluster { BooleanOptionKey const kcluster( "cmiles:kcluster" );  } }
namespace cmiles { namespace kcluster { IntegerOptionKey const num_clusters( "cmiles:kcluster:num_clusters" );  } }
namespace cmiles { namespace jumping { BooleanOptionKey const jumping( "cmiles:jumping" );  } }
namespace cmiles { namespace jumping { IntegerOptionKey const resi( "cmiles:jumping:resi" );  } }
namespace cmiles { namespace jumping { IntegerOptionKey const resj( "cmiles:jumping:resj" );  } }
namespace crossmatch { BooleanOptionKey const crossmatch( "crossmatch" );  }
namespace crossmatch { RealOptionKey const clash_dis( "crossmatch:clash_dis" );  }
namespace dwkulp { BooleanOptionKey const dwkulp( "dwkulp" );  }
namespace dwkulp { StringOptionKey const forcePolyAAfragments( "dwkulp:forcePolyAAfragments" );  }
namespace evolution { BooleanOptionKey const evolution( "evolution" );  }
namespace evolution { FileVectorOptionKey const parentlist( "evolution:parentlist" );  }
namespace evolution { FileVectorOptionKey const childlist( "evolution:childlist" );  }
namespace evolution { StringOptionKey const action( "evolution:action" );  }
namespace evolution { RealOptionKey const rms_threshold( "evolution:rms_threshold" );  }
namespace evolution { RealOptionKey const rms_topmargin( "evolution:rms_topmargin" );  }
namespace evolution { StringOptionKey const targetdir( "evolution:targetdir" );  }
namespace evolution { RealOptionKey const padding_score_filter( "evolution:padding_score_filter" );  }
namespace evolution { RealOptionKey const padding_stage2_filter( "evolution:padding_stage2_filter" );  }
namespace james { BooleanOptionKey const james( "james" );  }
namespace james { IntegerOptionKey const min_seqsep( "james:min_seqsep" );  }
namespace james { StringVectorOptionKey const atom_names( "james:atom_names" );  }
namespace james { RealVectorOptionKey const dist_thresholds( "james:dist_thresholds" );  }
namespace james { RealVectorOptionKey const torsion_thresholds( "james:torsion_thresholds" );  }
namespace james { BooleanOptionKey const debug( "james:debug" );  }
namespace james { RealOptionKey const real( "james:real" );  }
namespace james { IntegerOptionKey const n_designs( "james:n_designs" );  }
namespace james { BooleanOptionKey const thread_unaligned( "james:thread_unaligned" );  }
namespace krassk { BooleanOptionKey const krassk( "krassk" );  }
namespace krassk { BooleanOptionKey const tail_mode( "krassk:tail_mode" );  }
namespace krassk { IntegerOptionKey const tail_mode_name( "krassk:tail_mode_name" );  }
namespace krassk { StringOptionKey const tail_output_file_name( "krassk:tail_output_file_name" );  }
namespace loodo { BooleanOptionKey const loodo( "loodo" );  }
namespace loodo { IntegerOptionKey const ins_begin( "loodo:ins_begin" );  }
namespace loodo { StringOptionKey const cap( "loodo:cap" );  }
namespace loodo { StringOptionKey const bot( "loodo:bot" );  }
namespace loodo { IntegerVectorOptionKey const fragAlength( "loodo:fragAlength" );  }
namespace loodo { IntegerVectorOptionKey const fragBlength( "loodo:fragBlength" );  }
namespace loodo { IntegerOptionKey const known( "loodo:known" );  }
namespace loodo { StringOptionKey const fragAnative( "loodo:fragAnative" );  }
namespace loodo { StringOptionKey const fragBnative( "loodo:fragBnative" );  }
namespace loodo { StringOptionKey const gridligpath( "loodo:gridligpath" );  }
namespace loodo { BooleanOptionKey const debug( "loodo:debug" );  }
namespace loodo { RealOptionKey const ca_ratio( "loodo:ca_ratio" );  }
namespace loodo { RealOptionKey const distance_tolerance( "loodo:distance_tolerance" );  }
namespace loodo { RealOptionKey const euler_tolerance( "loodo:euler_tolerance" );  }
namespace loodo { IntegerOptionKey const num_frags( "loodo:num_frags" );  }
namespace loodo { StringOptionKey const use_fraglib( "loodo:use_fraglib" );  }
namespace loodo { StringOptionKey const use_fraglibsc( "loodo:use_fraglibsc" );  }
namespace loodo { BooleanOptionKey const com_in_grid( "loodo:com_in_grid" );  }
namespace loodo { BooleanOptionKey const loud( "loodo:loud" );  }
namespace loodo { BooleanOptionKey const dump_all_As( "loodo:dump_all_As" );  }
namespace loodo { BooleanOptionKey const dump_all_Bs( "loodo:dump_all_Bs" );  }
namespace loodo { StringOptionKey const caphit_rt_file( "loodo:caphit_rt_file" );  }
namespace murphp { BooleanOptionKey const murphp( "murphp" );  }
namespace murphp { StringOptionKey const inv_kin_lig_loop_design_filename( "murphp:inv_kin_lig_loop_design_filename" );  }
namespace peptide_deriver { BooleanOptionKey const peptide_deriver( "peptide_deriver" );  }
namespace peptide_deriver { IntegerVectorOptionKey const pep_lengths( "peptide_deriver:pep_lengths" );  }
namespace peptide_deriver { BooleanOptionKey const skip_zero_isc( "peptide_deriver:skip_zero_isc" );  }
namespace peptide_deriver { BooleanOptionKey const dump_peptide_pose( "peptide_deriver:dump_peptide_pose" );  }
namespace peptide_deriver { BooleanOptionKey const dump_cyclic_poses( "peptide_deriver:dump_cyclic_poses" );  }
namespace peptide_deriver { BooleanOptionKey const dump_prepared_pose( "peptide_deriver:dump_prepared_pose" );  }
namespace peptide_deriver { BooleanOptionKey const dump_report_file( "peptide_deriver:dump_report_file" );  }
namespace peptide_deriver { StringVectorOptionKey const restrict_receptors_to_chains( "peptide_deriver:restrict_receptors_to_chains" );  }
namespace peptide_deriver { StringVectorOptionKey const restrict_partners_to_chains( "peptide_deriver:restrict_partners_to_chains" );  }
namespace peptide_deriver { BooleanOptionKey const do_minimize( "peptide_deriver:do_minimize" );  }
namespace peptide_deriver { RealOptionKey const optimize_cyclic_threshold( "peptide_deriver:optimize_cyclic_threshold" );  }
namespace peptide_deriver { StringOptionKey const report_format( "peptide_deriver:report_format" );  }
namespace peptide_deriver { BooleanOptionKey const report_gzip( "peptide_deriver:report_gzip" );  }
namespace phil { BooleanOptionKey const phil( "phil" );  }
namespace phil { IntegerOptionKey const nloop( "phil:nloop" );  }
namespace phil { StringOptionKey const vall_file( "phil:vall_file" );  }
namespace robert { BooleanOptionKey const robert( "robert" );  }
namespace robert { StringOptionKey const pairdata_input_pdb_list( "robert:pairdata_input_pdb_list" );  }
namespace robert { RealOptionKey const pcs_maxsub_filter( "robert:pcs_maxsub_filter" );  }
namespace robert { RealOptionKey const pcs_maxsub_rmsd( "robert:pcs_maxsub_rmsd" );  }
namespace robert { BooleanOptionKey const pcs_dump_cluster( "robert:pcs_dump_cluster" );  }
namespace robert { RealOptionKey const pcs_cluster_coverage( "robert:pcs_cluster_coverage" );  }
namespace robert { BooleanOptionKey const pcs_cluster_lowscoring( "robert:pcs_cluster_lowscoring" );  }
namespace rot_anl { BooleanOptionKey const rot_anl( "rot_anl" );  }
namespace rot_anl { StringOptionKey const tag( "rot_anl:tag" );  }
namespace rot_anl { BooleanOptionKey const min( "rot_anl:min" );  }
namespace rot_anl { BooleanOptionKey const repack( "rot_anl:repack" );  }
namespace rot_anl { BooleanOptionKey const rtmin( "rot_anl:rtmin" );  }
namespace rot_anl { BooleanOptionKey const scmove( "rot_anl:scmove" );  }
namespace rot_anl { BooleanOptionKey const design( "rot_anl:design" );  }
namespace rot_anl { BooleanOptionKey const dump_pdb( "rot_anl:dump_pdb" );  }
namespace rot_anl { IntegerOptionKey const nloop_scmove( "rot_anl:nloop_scmove" );  }
namespace smhybrid { BooleanOptionKey const smhybrid( "smhybrid" );  }
namespace smhybrid { BooleanOptionKey const add_cavities( "smhybrid:add_cavities" );  }
namespace smhybrid { BooleanOptionKey const abinitio_design( "smhybrid:abinitio_design" );  }
namespace smhybrid { BooleanOptionKey const fa_refine( "smhybrid:fa_refine" );  }
namespace smhybrid { BooleanOptionKey const virtual_nterm( "smhybrid:virtual_nterm" );  }
namespace smhybrid { BooleanOptionKey const debug( "smhybrid:debug" );  }
namespace smhybrid { BooleanOptionKey const refine( "smhybrid:refine" );  }
namespace smhybrid { BooleanOptionKey const centroid_all_val( "smhybrid:centroid_all_val" );  }
namespace smhybrid { BooleanOptionKey const subsubs_attract( "smhybrid:subsubs_attract" );  }
namespace smhybrid { BooleanOptionKey const linker_cst( "smhybrid:linker_cst" );  }
namespace smhybrid { BooleanOptionKey const pseudosym( "smhybrid:pseudosym" );  }
namespace smhybrid { BooleanOptionKey const design_linker( "smhybrid:design_linker" );  }
namespace smhybrid { BooleanOptionKey const design( "smhybrid:design" );  }
namespace smhybrid { BooleanOptionKey const restrict_design_to_interface( "smhybrid:restrict_design_to_interface" );  }
namespace smhybrid { BooleanOptionKey const restrict_design_to_subsub_interface( "smhybrid:restrict_design_to_subsub_interface" );  }
namespace smhybrid { BooleanOptionKey const design_hydrophobic( "smhybrid:design_hydrophobic" );  }
namespace smhybrid { BooleanOptionKey const add_metal_at_0( "smhybrid:add_metal_at_0" );  }
namespace smhybrid { IntegerOptionKey const nres_mono( "smhybrid:nres_mono" );  }
namespace smhybrid { IntegerOptionKey const abinitio_cycles( "smhybrid:abinitio_cycles" );  }
namespace smhybrid { IntegerOptionKey const primary_subsubunit( "smhybrid:primary_subsubunit" );  }
namespace smhybrid { IntegerOptionKey const minbb( "smhybrid:minbb" );  }
namespace smhybrid { IntegerOptionKey const switch_concert_sub( "smhybrid:switch_concert_sub" );  }
namespace smhybrid { RealOptionKey const temperature( "smhybrid:temperature" );  }
namespace smhybrid { BooleanOptionKey const inter_subsub_cst( "smhybrid:inter_subsub_cst" );  }
namespace smhybrid { RealOptionKey const rb_mag( "smhybrid:rb_mag" );  }
namespace smhybrid { FileOptionKey const symm_def_template( "smhybrid:symm_def_template" );  }
namespace smhybrid { FileOptionKey const symm_def_template_reduced( "smhybrid:symm_def_template_reduced" );  }
namespace smhybrid { IntegerVectorOptionKey const attach_as_sc( "smhybrid:attach_as_sc" );  }
namespace smhybrid { IntegerVectorOptionKey const attach_as_sc_sub( "smhybrid:attach_as_sc_sub" );  }
namespace smhybrid { BooleanVectorOptionKey const chainbreaks( "smhybrid:chainbreaks" );  }
namespace smhybrid { StringVectorOptionKey const design_res_files( "smhybrid:design_res_files" );  }
namespace smhybrid { StringVectorOptionKey const fixed_res_files( "smhybrid:fixed_res_files" );  }
namespace smhybrid { StringVectorOptionKey const frag_res_files( "smhybrid:frag_res_files" );  }
namespace smhybrid { StringVectorOptionKey const scattach_res_files( "smhybrid:scattach_res_files" );  }
namespace smhybrid { StringVectorOptionKey const rep_edge_files( "smhybrid:rep_edge_files" );  }
namespace smhybrid { StringVectorOptionKey const virtual_res_files( "smhybrid:virtual_res_files" );  }
namespace smhybrid { StringVectorOptionKey const jumpcut_files( "smhybrid:jumpcut_files" );  }
namespace smhybrid { StringVectorOptionKey const cst_sub_files( "smhybrid:cst_sub_files" );  }
namespace smhybrid { StringVectorOptionKey const symm_file_tag( "smhybrid:symm_file_tag" );  }
namespace smhybrid { StringVectorOptionKey const attach_atom( "smhybrid:attach_atom" );  }
namespace smhybrid { StringVectorOptionKey const add_res_before( "smhybrid:add_res_before" );  }
namespace smhybrid { StringVectorOptionKey const add_res_after( "smhybrid:add_res_after" );  }
namespace smhybrid { StringVectorOptionKey const add_ss_before( "smhybrid:add_ss_before" );  }
namespace smhybrid { StringVectorOptionKey const add_ss_after( "smhybrid:add_ss_after" );  }
namespace smhybrid { StringVectorOptionKey const add_atom_at_cen( "smhybrid:add_atom_at_cen" );  }
namespace smhybrid { StringVectorOptionKey const attach_rsd( "smhybrid:attach_rsd" );  }
namespace threadsc { BooleanOptionKey const threadsc( "threadsc" );  }
namespace threadsc { StringOptionKey const src_chain( "threadsc:src_chain" );  }
namespace threadsc { StringOptionKey const trg_chain( "threadsc:trg_chain" );  }
namespace threadsc { IntegerOptionKey const src_first_resid( "threadsc:src_first_resid" );  }
namespace threadsc { IntegerOptionKey const trg_first_resid( "threadsc:trg_first_resid" );  }
namespace threadsc { IntegerOptionKey const nres( "threadsc:nres" );  }
namespace threadsc { IntegerOptionKey const trg_anchor( "threadsc:trg_anchor" );  }
namespace ufv { BooleanOptionKey const ufv( "ufv" );  }
namespace ufv { IntegerOptionKey const left( "ufv:left" );  }
namespace ufv { IntegerOptionKey const right( "ufv:right" );  }
namespace ufv { StringOptionKey const ss( "ufv:ss" );  }
namespace ufv { StringOptionKey const aa_during_build( "ufv:aa_during_build" );  }
namespace ufv { StringOptionKey const aa_during_design_refine( "ufv:aa_during_design_refine" );  }
namespace ufv { BooleanOptionKey const keep_junction_torsions( "ufv:keep_junction_torsions" );  }
namespace ufv { FileOptionKey const ufv_loops( "ufv:ufv_loops" );  }
namespace ufv { BooleanOptionKey const use_fullmer( "ufv:use_fullmer" );  }
namespace ufv { StringOptionKey const centroid_loop_mover( "ufv:centroid_loop_mover" );  }
namespace ufv { BooleanOptionKey const no_neighborhood_design( "ufv:no_neighborhood_design" );  }
namespace ufv { IntegerOptionKey const dr_cycles( "ufv:dr_cycles" );  }
namespace ufv { StringOptionKey const centroid_sfx( "ufv:centroid_sfx" );  }
namespace ufv { StringOptionKey const centroid_sfx_patch( "ufv:centroid_sfx_patch" );  }
namespace ufv { StringOptionKey const fullatom_sfx( "ufv:fullatom_sfx" );  }
namespace ufv { StringOptionKey const fullatom_sfx_patch( "ufv:fullatom_sfx_patch" );  }
namespace ufv { namespace insert { BooleanOptionKey const insert( "ufv:insert" );  } }
namespace ufv { namespace insert { FileOptionKey const insert_pdb( "ufv:insert:insert_pdb" );  } }
namespace ufv { namespace insert { FileOptionKey const attached_pdb( "ufv:insert:attached_pdb" );  } }
namespace ufv { namespace insert { StringOptionKey const connection_scheme( "ufv:insert:connection_scheme" );  } }
namespace willmatch { BooleanOptionKey const willmatch( "willmatch" );  }
namespace willmatch { StringVectorOptionKey const write_reduced_matchset( "willmatch:write_reduced_matchset" );  }
namespace willmatch { RealOptionKey const interface_size( "willmatch:interface_size" );  }
namespace willmatch { RealOptionKey const max_dis_any( "willmatch:max_dis_any" );  }
namespace willmatch { RealOptionKey const max_dis_all( "willmatch:max_dis_all" );  }
namespace willmatch { RealOptionKey const max_dis_hb( "willmatch:max_dis_hb" );  }
namespace willmatch { RealOptionKey const min_dis_hb( "willmatch:min_dis_hb" );  }
namespace willmatch { RealOptionKey const max_dis_hb_colinear( "willmatch:max_dis_hb_colinear" );  }
namespace willmatch { RealOptionKey const max_dis_metal( "willmatch:max_dis_metal" );  }
namespace willmatch { RealOptionKey const max_ang_metal( "willmatch:max_ang_metal" );  }
namespace willmatch { RealOptionKey const clash_dis( "willmatch:clash_dis" );  }
namespace willmatch { RealOptionKey const c2_linker_dist( "willmatch:c2_linker_dist" );  }
namespace willmatch { RealOptionKey const identical_match_dis( "willmatch:identical_match_dis" );  }
namespace willmatch { RealOptionKey const chi1_increment( "willmatch:chi1_increment" );  }
namespace willmatch { RealOptionKey const chi2_increment( "willmatch:chi2_increment" );  }
namespace willmatch { RealOptionKey const c2_symm_increment( "willmatch:c2_symm_increment" );  }
namespace willmatch { RealOptionKey const cb_sasa_thresh( "willmatch:cb_sasa_thresh" );  }
namespace willmatch { BooleanOptionKey const design_interface( "willmatch:design_interface" );  }
namespace willmatch { FileOptionKey const chilist( "willmatch:chilist" );  }
namespace willmatch { FileOptionKey const fixed_res( "willmatch:fixed_res" );  }
namespace willmatch { FileOptionKey const native1( "willmatch:native1" );  }
namespace willmatch { FileOptionKey const native2( "willmatch:native2" );  }
namespace willmatch { FileOptionKey const exclude_res1( "willmatch:exclude_res1" );  }
namespace willmatch { FileOptionKey const exclude_res2( "willmatch:exclude_res2" );  }
namespace willmatch { FileOptionKey const taglist( "willmatch:taglist" );  }
namespace willmatch { IntegerVectorOptionKey const residues( "willmatch:residues" );  }
namespace willmatch { BooleanOptionKey const symmetry_d2( "willmatch:symmetry_d2" );  }
namespace willmatch { BooleanOptionKey const symmetry_c2_dock( "willmatch:symmetry_c2_dock" );  }
namespace willmatch { IntegerVectorOptionKey const splitwork( "willmatch:splitwork" );  }
namespace willmatch { BooleanOptionKey const exclude_ala( "willmatch:exclude_ala" );  }
namespace willmatch { RealOptionKey const match_overlap_dis( "willmatch:match_overlap_dis" );  }
namespace willmatch { RealOptionKey const match_overlap_ang( "willmatch:match_overlap_ang" );  }
namespace willmatch { IntegerVectorOptionKey const forbid_residues( "willmatch:forbid_residues" );  }
namespace willmatch { RealVectorOptionKey const poi( "willmatch:poi" );  }
namespace willmatch { RealOptionKey const poidis( "willmatch:poidis" );  }
namespace willmatch { BooleanOptionKey const homodimer( "willmatch:homodimer" );  }
namespace willmatch { RealOptionKey const fa_dun_thresh( "willmatch:fa_dun_thresh" );  }
namespace testing { BooleanOptionKey const testing( "testing" );  }
namespace testing { BooleanOptionKey const HCF( "testing:HCF" );  }

#ifndef OPTION_CC_GEN_HH
#define OPTION_CC_GEN_HH
#include <basic/options/option.hh>
#include <basic/options/option.cc.include.gen.hh>
#include <utility/options/OptionCollection.hh>
inline void add_rosetta_options_0( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::in::in, "in option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::in::Ntermini, "Put full N termini on pose" ).def("ALL");
option.add( basic::options::OptionKeys::in::Ctermini, "Put full C termini on pose" ).def("ALL");
option.add( basic::options::OptionKeys::in::use_truncated_termini, "Will not add extra OXT/Hs at termini if not in input structure" ).def(false);
option.add( basic::options::OptionKeys::in::ignore_unrecognized_res, "Do not abort if unknown residues are found in PDB file;  instead, ignore them. Note this implies -in:ignore_waters" ).def(false);
option.add( basic::options::OptionKeys::in::ignore_waters, "Ignore HOH residues found in PDB file. Note: HOH residues, and waters in general, are incompatible with the default solvation model (LK)." ).def(true);
option.add( basic::options::OptionKeys::in::guarantee_no_DNA, "Do not rename A/C/G to DA/DC/DG even if missing their 2' hydroxyl; expert knowledge says this structure has no DNA." ).def(false);
option.add( basic::options::OptionKeys::in::add_orbitals, "Will add orbitals to residues only. Does not include orbitals to ligands. Done through params file reading." ).def(false);
option.add( basic::options::OptionKeys::in::show_all_fixes, "Show all residue & atom name fixes" ).def(false);
option.add( basic::options::OptionKeys::in::include_sugars, "Sets whether or not carbohydrate residues will beloaded into Rosetta.  The default value is false." ).shortd( "Load carbohydrate residues into memory?" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::in::include_lipids, "Sets whether or not lipid residues will beloaded into Rosetta.  The default value is false." ).shortd( "Load lipid residues into memory?" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::in::include_surfaces, "Sets whether or not mineral surface residues will beloaded into Rosetta.  The default value is false." ).shortd( "Load mineral surface residues into memory?" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::in::membrane, "Initialize pose as a membrane protein using specified membrane parameters. Default is false" ).shortd( "initialize membrane" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::in::remember_unrecognized_res, "Ignore unrecognized residues, but remember them in PDBInfo." ).def(false);
option.add( basic::options::OptionKeys::in::remember_unrecognized_water, "Remember waters along with other unrecognized residues." ).def(false);
option.add( basic::options::OptionKeys::in::preserve_crystinfo, "Preserve information important for crystal refinement (B factors +CRYST1 line)" ).def(false);
option.add( basic::options::OptionKeys::in::detect_oops, "Detect oligooxopiperazines (oops) and add required constraints" ).def(false);
option.add( basic::options::OptionKeys::in::detect_disulf, "Forcably enable or disable disulfide detection. When unspecified, rosetta conservatively detects disulfides in full atom input based on SG distance, but will not form centroid disulfides.  Setting '-detect_disulf true' will force aggressive disulfide detection in centroid poses based on CB distance.  Setting '-detect_disulf false' disables all detection, even in full atom poses.  Note that disabling disulfides causes severe clashes for native disulfides." ).legal(true).legal(false);
option.add( basic::options::OptionKeys::in::detect_disulf_tolerance, "disulf tolerance" ).def(0.5);
option.add( basic::options::OptionKeys::in::constraints_from_link_records, "Turn link records into atom pair and angle constraints" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::in::auto_setup_metals, "Automatically adds covalent linkages to bound metal ions, as well as atom pair constraints and angle constraints to hold ions in place, on PDB import.  Also, sets the atom_pair_constraint and angle_constraint weights in the default score function to 1.0.  False by default." ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::in::prevent_auto_setup_metal_bb_variants, "When automatically setting up metals, in cases where there is a bond detected between a metal and a backbone heavyatom (e.g. a backbone carbonyl oxygen), by default Rosetta will set up bonded variant types for the current residue and for all orther residue types with an equivalent backbone heavyatom, to permit mutations.  Setting this flag to true prevents this.  False by default." ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::in::metals_detection_LJ_multiplier, "When -auto_setup_metals is used, overlap between metal atoms and metal-binding atoms is used as the criterion by which covalent bonds are detected.  The Lennard-Jones radii of the atoms can be multiplied by a constant factor in order to detect longer bonds to metal ions.  Default 1.0." ).def(1.0);
option.add( basic::options::OptionKeys::in::metals_distance_constraint_multiplier, "Distances between metals and metal-binding atoms are constrained using harmonic potentials, scaled by this multiplier.  Default 1.0.  Set to 0.0 to skip adding distance constraints." ).def(1.0);
option.add( basic::options::OptionKeys::in::metals_angle_constraint_multiplier, "Angles between metals, metal-binding atoms, and metal-binding atom parents are constrained using circular harmonic potentials, scaled by this multiplier.  Default 1.0. Set to 0.0 to skip adding angle constraints." ).def(1.0);
option.add( basic::options::OptionKeys::in::name3_property_codes, "File that describes name3-property correspondence to fix up atom assignments" ).def(utility::vector1<std::string>(1,"code_properties.codes"));
option.add( basic::options::OptionKeys::in::alternate_3_letter_codes, "Specify the filename(s) of (a) *.codes files that includes a list of alternative 3-letter codes.  The default directory is database/input_output/3-letter_codes/ but any path can be provided.  Duplicate codes in successive files will overwrite previous ones." ).shortd( "Specify (a) *.codes file(s) of alternate 3-letter codes." );
option.add( basic::options::OptionKeys::in::only_chairs, "Triggers loading of only the chair conformations of sugars with 6 member rings." ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::in::fix_disulf, "Specify disulfide connectivity via a file.  Disulfides are specified as two whitespace-separated residue indices per line.  This option replaces the old '-run:fix_disulf' option." );
option.add( basic::options::OptionKeys::in::missing_density_to_jump, "If missing density is found in input pdbs, replace with a jump" ).def(false);
option.add( basic::options::OptionKeys::in::target_residues, "which residue numbers to pass for getDistConstraints" );
option.add( basic::options::OptionKeys::in::replonly_residues, "residue numbers regarded as repulsive-only residues" );
option.add( basic::options::OptionKeys::in::replonly_loops, "all loops will be regarded as repulsive-only" ).def(false);
option.add( basic::options::OptionKeys::in::use_database, "Read in structures from database.  Specify database via -inout:dbms:database_name and wanted structures with -in:file:tags or select_structures_from_database" );
option.add( basic::options::OptionKeys::in::select_structures_from_database, "specify an SQL query to determine which structures get read in from a database specified with -inout:dbms:database_name.  SELECT query must return structures.tag" );
option.add( basic::options::OptionKeys::in::dbms::dbms, "dbms option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::in::dbms::struct_ids, "List of struct_ids (hex representation) to be used by the database job inputter" );
option.add( basic::options::OptionKeys::in::path::path, "Paths to search for input files (checked after type-specific paths)" ).def(".").is_group(true);
option.add( basic::options::OptionKeys::in::path::fragments, "Fragment file input search paths" );
option.add( basic::options::OptionKeys::in::path::pdb, "PDB file input search paths" );
option.add( basic::options::OptionKeys::in::path::database, "Database file input search paths.  If the database is not found the ROSETTA3_DB environment variable is tried." );
option.add( basic::options::OptionKeys::in::path::database_cache_dir, "Which directory to use when caching processed database files." );
option.add( basic::options::OptionKeys::in::file::file, "Input file option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::in::file::s, "Name(s) of single PDB file(s) to process" ).def();
option.add( basic::options::OptionKeys::in::file::t, "Name(s) of second PDB file(s) to process (pairs with -s)" );
option.add( basic::options::OptionKeys::in::file::l, "File(s) containing list(s) of PDB files to process" );
option.add( basic::options::OptionKeys::in::file::job_definition_file, "File used by JD3 in which multiple jobs with different inputs can be specified" );
option.add( basic::options::OptionKeys::in::file::list, "File(s) containing list(s) of PDB files.  PDBs on the same line become one pose" );
option.add( basic::options::OptionKeys::in::file::screening_list, "Files containing lists of PDB files. all permutations of the files in the list become poses" );
option.add( basic::options::OptionKeys::in::file::screening_job_file, "A JSON file containing groups of ligands and proteins to screen" );
option.add( basic::options::OptionKeys::in::file::shuffle_screening_jobs, "Randomize the order of jbos input through -in:file:screening_job_file" ).def(false);
option.add( basic::options::OptionKeys::in::file::native, "Native PDB filename" );
option.add( basic::options::OptionKeys::in::file::torsion_bin_probs, "File describing probabilities over torsion bins A,B,E,G,O" ).def("empty");
option.add( basic::options::OptionKeys::in::file::PCS_frag_cst, "File that containts PCS constraints for use in fragment picking" );
option.add( basic::options::OptionKeys::in::file::talos_phi_psi, "File that provides Phi-Psi angles in Talos+ format" );
option.add( basic::options::OptionKeys::in::file::talos_cs, "File that provides chemical shifts in Talos format" );
option.add( basic::options::OptionKeys::in::file::ambig_talos_cs_A, "File that provides 1st set of ambigious chemical shift options in Talos format" );
option.add( basic::options::OptionKeys::in::file::ambig_talos_cs_B, "File that provides 2nd set of ambigious chemical shift options in Talos format" );
option.add( basic::options::OptionKeys::in::file::native_exclude_res, "Residue numbers to be excluded from RMS calculation" );
option.add( basic::options::OptionKeys::in::file::tags, "Tag(s) of structures to be used from silent-file" );
option.add( basic::options::OptionKeys::in::file::user_tags, "user_tag(s) of structures to be used from silent-file" );
option.add( basic::options::OptionKeys::in::file::tagfile, "File with list of tags tou be used from silent-file. (an -in:file:l for silent file tags.)" ).def("TAGS");
option.add( basic::options::OptionKeys::in::file::frag_files, "Fragment input file names" ).def();
option.add( basic::options::OptionKeys::in::file::remap_pdb_atom_names_for, "When reading PDBs, use geometry to rename atoms for the residues with the given three letter codes." );
option.add( basic::options::OptionKeys::in::file::extra_res, ".params file(s) for new residue types (e.g. ligands)" );
option.add( basic::options::OptionKeys::in::file::extra_res_fa, ".params file(s) for new fullatom residue types (e.g. ligands)" ).def();
option.add( basic::options::OptionKeys::in::file::extra_res_mol, ".mol file(s) for new fullatom residue types (e.g. ligands)" );
option.add( basic::options::OptionKeys::in::file::extra_res_mmCIF, ".mmCIF file(s) for component dictionary for residue types (e.g. ligands)" );
option.add( basic::options::OptionKeys::in::file::load_PDB_components, "Use the PDB ligand definitions to load all standard residue descriptions." );
option.add( basic::options::OptionKeys::in::file::PDB_components_file, "The CIF file from which to load the PDB component definitions. (An example can be found at http://www.wwpdb.org/data/ccd" ).def("chemical/components.cif");
option.add( basic::options::OptionKeys::in::file::extra_res_database, "the name of a database containing fullatom residue types (e.g. ligands)" );
option.add( basic::options::OptionKeys::in::file::extra_res_pq_schema, "the name of a postgreSQL schema in the database containing fullatom residue types (e.g. ligands)" ).def("");
option.add( basic::options::OptionKeys::in::file::extra_res_database_mode, "The type of database driver to use for -in:file:extra_res_database." ).legal("sqlite3").legal("mysql").legal("postgres").def("sqlite3");
option.add( basic::options::OptionKeys::in::file::extra_res_database_resname_list, "Path to a list of residue names to be read in from the residue database.  The list should have one residue name per line" );
option.add( basic::options::OptionKeys::in::file::extra_res_cen, ".params file(s) for new centroid residue types (e.g. ligands)" );
option.add( basic::options::OptionKeys::in::file::extra_res_path, "directories with .params files.  Only files containing 'param' will be chosen" );
option.add( basic::options::OptionKeys::in::file::extra_rot_lib_path, "directories with NCAA rotamer files." );
option.add( basic::options::OptionKeys::in::file::override_rot_lib_path, "if rotamer libraries are found in this directory, prioritize them and not others" );
option.add( basic::options::OptionKeys::in::file::extra_res_batch_path, "directories generated by src/python/apps/public/batch_molfile_to_params.py.  Only files containing 'param' will be chosen" );
option.add( basic::options::OptionKeys::in::file::extra_patch_fa, "patch files for full atom variants not specified in the database" );
option.add( basic::options::OptionKeys::in::file::extra_patch_cen, "patch files for centroid atom variants not specified in the database" );
option.add( basic::options::OptionKeys::in::file::frag3, "No description" );
option.add( basic::options::OptionKeys::in::file::frag9, "No description" );
option.add( basic::options::OptionKeys::in::file::fragA, "No description" );
option.add( basic::options::OptionKeys::in::file::fragB, "No description" );
option.add( basic::options::OptionKeys::in::file::surface_vectors, "Input file containing three sets of xyz coordinates which define the plane and periodicity of the solid surface" );
option.add( basic::options::OptionKeys::in::file::xyz, "Input coordinates in a raw XYZ format (three columns)" );
option.add( basic::options::OptionKeys::in::file::keep_input_scores, "Keep/Don't keep scores from input file in Pose." ).def(true);
option.add( basic::options::OptionKeys::in::file::lazy_silent, "Activate LazySilentFileJobInputter" ).def(false);
option.add( basic::options::OptionKeys::in::file::silent, "silent input filename(s)" ).def();
option.add( basic::options::OptionKeys::in::file::force_silent_bitflip_on_read, "Force bit-flipping when reading binary silent files.  This is useful if the files are produced on a little-endian system and read on a big-endian system." ).def(false);
option.add( basic::options::OptionKeys::in::file::atom_tree_diff, "atom_tree_diff input filename(s)" );
option.add( basic::options::OptionKeys::in::file::zip, "zipped input file, used for BOINC database" );
option.add( basic::options::OptionKeys::in::file::boinc_wu_zip, "zipped input file with files for a specific BOINC workunit" );
option.add( basic::options::OptionKeys::in::file::fullatom, "Enable full-atom input of PDB or centroid structures" ).def(false);
option.add( basic::options::OptionKeys::in::file::centroid_input, "why input in the name twice ? in:file:centroid_input Enable centroid inputs of PDBs" ).def(false);
option.add( basic::options::OptionKeys::in::file::centroid, "Enable centroid inputs of PDBs" ).def(false);
option.add( basic::options::OptionKeys::in::file::assign_gasteiger_atom_types, "Automatically assign GasteigerAtomTypes to all residues in the ResidueTypeSet" ).def(false);
option.add( basic::options::OptionKeys::in::file::treat_residues_in_these_chains_as_separate_chemical_entities, "Create a chemical jump for each residue in these chains (String of 1-letter chain IDs)" ).def(" ");
option.add( basic::options::OptionKeys::in::file::residue_type_set, "ResidueTypeSet for input files" ).def("fa_standard");
option.add( basic::options::OptionKeys::in::file::pca, "compute PCA projections" ).def("");
option.add( basic::options::OptionKeys::in::file::silent_energy_cut, "energy cut for silent-files" ).def(1.0);
option.add( basic::options::OptionKeys::in::file::silent_list, "Silent input filename list(s) - like -l is to -s " );
option.add( basic::options::OptionKeys::in::file::silent_renumber, "renumber decoys in not_universal_main or not" ).def(false);
option.add( basic::options::OptionKeys::in::file::silent_struct_type, "Type of SilentStruct object to use in silent-file input" ).def("protein");
option.add( basic::options::OptionKeys::in::file::silent_read_through_errors, "will ignore decoys with errors and continue reading" ).def(false);
option.add( basic::options::OptionKeys::in::file::silent_score_prefix, "Prefix that is appended to all scores read in from a silent-file" ).def("");
option.add( basic::options::OptionKeys::in::file::silent_select_random, "Select a random subset of this number of decoys from every silent-file read" ).def(0);
option.add( basic::options::OptionKeys::in::file::silent_select_range_start, "Select a ranged subset of decoys from every silent-file read.  Start at this decoy." ).def(-1);
option.add( basic::options::OptionKeys::in::file::silent_select_range_mul, "Select a blocksize multiplier.  This param pasically multiplies -silent_select_range_start.  E.g. when set to, say, 5, -silent_select_range_start 0,1,2,3,4 will result in decoys being read starting from 0,5,10,15,20" ).def(1);
option.add( basic::options::OptionKeys::in::file::silent_select_range_len, "Select a ranged subset of decoys from every silent-file read.  Start at this decoy." ).def(1);
option.add( basic::options::OptionKeys::in::file::skip_failed_simulations, "Ignore failed simulations (prefixed by W_) during silent file input.  Existing behavior is preserved by default." ).def(false);
option.add( basic::options::OptionKeys::in::file::silent_scores_wanted, "Only put these silent-scores into the Pose." );
option.add( basic::options::OptionKeys::in::file::fasta, "Fasta-formatted sequence file" ).def();
option.add( basic::options::OptionKeys::in::file::pssm, "NCBI BLAST formatted position-specific scoring matrix" );
option.add( basic::options::OptionKeys::in::file::seq, "List of input files for constructing sequences" );
option.add( basic::options::OptionKeys::in::file::checkpoint, "Sequence profile (flat text file format) prepared by NCBI BLAST" );
option.add( basic::options::OptionKeys::in::file::binary_chk, "Sequence profile (binary file format) prepared by NCBI BLAST" );
option.add( basic::options::OptionKeys::in::file::alignment, "Input file for sequence alignment" );
option.add( basic::options::OptionKeys::in::file::alignment2, "Input file for second sequence alignment " );
option.add( basic::options::OptionKeys::in::file::rama2b_map, "Ramachandran file used by rama2b" ).def("scoring/score_functions/rama/Rama08.dat");
option.add( basic::options::OptionKeys::in::file::psipred_ss2, "psipred_ss2 secondary structure definition file" ).def("tt");
option.add( basic::options::OptionKeys::in::file::dssp, "dssp secondary structure definition file" ).def("tt");
option.add( basic::options::OptionKeys::in::file::fail_on_bad_hbond, "exit if a hydrogen bonding error is detected" ).def(true);
option.add( basic::options::OptionKeys::in::file::movemap, "No description" ).def("default.movemap");
option.add( basic::options::OptionKeys::in::file::repair_sidechains, "Attempt a repack/minmize to repair sidechain problems, such as proline geometry and His tautomerization" ).def(false);
option.add( basic::options::OptionKeys::in::file::no_binary_dunlib, "Do not attempt to read from or write to a binary file for the Dunbrack library" );
option.add( basic::options::OptionKeys::in::file::extended_pose, "number of extended poses to process in not_universal_main" ).def(1);
option.add( basic::options::OptionKeys::in::file::template_pdb, "Name of input template PDB files for comparative modeling" );
option.add( basic::options::OptionKeys::in::file::template_silent, "input templates for comparative modeling -- tag needs to fit alignment id" );
option.add( basic::options::OptionKeys::in::file::rdc, "Experimental NMR Residual Dipolar Coupling File --- one file per alignment medium" );
option.add( basic::options::OptionKeys::in::file::csa, "Experimental NMR Chemical Shift Anisotropy File" );
option.add( basic::options::OptionKeys::in::file::dc, "Experimental NMR Dipolar Coupling File" );
option.add( basic::options::OptionKeys::in::file::burial, "WESA-formatted burial prediction" );
option.add( basic::options::OptionKeys::in::file::vall, "Fragment database file, e.g vall.dat.2006-05-05" ).def("/sampling/filtered.vall.dat.2006-05-05");
option.add( basic::options::OptionKeys::in::file::rescore, "Governs whether input poses are rescored or not in not_universal_main, defaults to false." ).def(false);
option.add( basic::options::OptionKeys::in::file::spanfile, "Membrane spanning file" );
option.add( basic::options::OptionKeys::in::file::lipofile, "Membrane exposure file" );
option.add( basic::options::OptionKeys::in::file::HDX, "HDX (Hydrogen exchange data file" );
option.add( basic::options::OptionKeys::in::file::d2h_sa_reweight, "d2h_sa reweight" ).def(1.00);
option.add( basic::options::OptionKeys::in::file::sucker_params, "Parameter file containing SplineEnergy parameters" ).def("scoring/spline_energy_functions/sucker.params");
option.add( basic::options::OptionKeys::in::file::fold_tree, "User defined fold tree to be imposed on the pose after reading from disk" );
option.add( basic::options::OptionKeys::in::file::obey_ENDMDL, "Stop reading a PDB after ENDMDL card; effectively read only first model in multimodel NMR PDBs" ).def(false);
option.add( basic::options::OptionKeys::in::file::new_chain_order, "ensures chain from different MODEL records have differnet mini chains" ).def(false);
option.add( basic::options::OptionKeys::in::file::ddg_predictions_file, "File that contains mutational ddG information. Used by ddG task operation/filter." ).def("");
option.add( basic::options::OptionKeys::in::file::input_res, "Residues already present in starting file" ).def();
option.add( basic::options::OptionKeys::in::file::minimize_res, "Residues to minimize" ).def();
option.add( basic::options::OptionKeys::in::file::md_schfile, "File name containing MD schedule" );
option.add( basic::options::OptionKeys::in::file::native_contacts, "native contacts pair list for fnat/fnon-nat calculation in Docking" );
option.add( basic::options::OptionKeys::in::rdf::rdf, "rdf option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::in::rdf::sep_bb_ss, "separate RDFs by SS for backbone atypes " ).def(true);
option.add( basic::options::OptionKeys::inout::inout, "Ouput option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::inout::fold_tree_io, "Ignore 'CHECKPOINT' file and the overwrite the PDB file(s)" );
option.add( basic::options::OptionKeys::inout::skip_connect_info, "If true, skips writing CONECT information in PDB files.  False by default (writes CONECT records)." ).def(false);
option.add( basic::options::OptionKeys::inout::write_all_connect_info, "By default, CONECT information is written for all noncanonicals and HETATMs, except waters.  If this flag is set to true, it will be written for ALL residues, subject to the distance cutoff (-inout:connect_info_cufoff) and overridden by -inout:skip_connect_info." ).def(false);
option.add( basic::options::OptionKeys::inout::connect_info_cutoff, "The atom separation cutoff above which bonded atoms have explicit CONECT records written so that programs like PyMOL know the atomic connectivity.  Default 0.0 Angstroms (write all records)." ).def(0.0);
option.add( basic::options::OptionKeys::inout::dbms::dbms, "database option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::inout::dbms::mode, "Which backend to use by default for database access.  Note, usage of 'mysql' requires building with 'extras=mysql' and usage of 'postgres' requires building with 'extras=postgres'" ).legal("sqlite3").legal("mysql").legal("postgres").def("sqlite3");
option.add( basic::options::OptionKeys::inout::dbms::database_name, "name of the database.  For sqlite3 databases this is a path in the file system usually with the '.db3' extension." );
option.add( basic::options::OptionKeys::inout::dbms::pq_schema, "For posgres databases, specify the default schema with the database.  For PostgreSQL database, schemas are like namespaces." ).def("");
option.add( basic::options::OptionKeys::inout::dbms::host, "default hostname of database server" );
option.add( basic::options::OptionKeys::inout::dbms::user, "default username for database server access" );
option.add( basic::options::OptionKeys::inout::dbms::password, "default password for database server access" );
option.add( basic::options::OptionKeys::inout::dbms::port, "default port for database server access" );
option.add( basic::options::OptionKeys::inout::dbms::readonly, "open sqlite3 database in read-only mode by default" ).def(false);
option.add( basic::options::OptionKeys::inout::dbms::separate_db_per_mpi_process, "In MPI mode, open a separate sqlite3 database for each process with extension _<mpi_rank> and write partitioned schema to that database." ).def(false);
option.add( basic::options::OptionKeys::inout::dbms::database_partition, "Open a sepearte sqlite3 database with the extension _<partition> and write a partitioned schema to that database." ).def(-1);
option.add( basic::options::OptionKeys::inout::dbms::use_compact_residue_schema, "Store all the atoms for a residue in a binary silent file style blob.  Sacrifices analyzability for scalability.  If you don't know if you want this you probably don't." ).def(false);
option.add( basic::options::OptionKeys::inout::dbms::retry_failed_reads, "If a database read fails for an unknown reason, try again several times before giving up" ).def(false);
option.add( basic::options::OptionKeys::inout::dbms::path, "Directory the database should be read from or exported to." ).def(".");
option.add( basic::options::OptionKeys::out::out, "Ouput option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::out::overwrite, "Ignore 'CHECKPOINT' file and the overwrite PDB and silent file(s)" );
option.add( basic::options::OptionKeys::out::nstruct, "Number of times to process each input PDB" ).def(1);
option.add( basic::options::OptionKeys::out::shuffle_nstruct, "total number of decoys to produce" ).def(1);
option.add( basic::options::OptionKeys::out::prefix, "Prefix for output structure names, like old -series code" ).def("");
option.add( basic::options::OptionKeys::out::suffix, "Suffix for output structure names" ).def("");
option.add( basic::options::OptionKeys::out::no_nstruct_label, "Do not tag the first output structure with _0001" ).def(false);
option.add( basic::options::OptionKeys::out::pdb_gz, "Compress (gzip) output pdbs" ).def(false);
option.add( basic::options::OptionKeys::out::pdb, "Output PDBs" ).def(false);
option.add( basic::options::OptionKeys::out::silent_gz, "Use gzipped compressed output (silent run level)" ).def(false);
option.add( basic::options::OptionKeys::out::membrane_pdb, "Write out the membrane in the PDB - on/off." );
option.add( basic::options::OptionKeys::out::membrane_pdb_thickness, "Thickness of the written membrane in the PDB file. Using this flag, turns on -out:membrane_pdb automatically. If flag is not given, it uses the default (30) or the one from the -mp:thickness flag." );
option.add( basic::options::OptionKeys::out::mmCIF, "output mmCIF files (broadly, as opposed to PDB files)" ).def(false);
option.add( basic::options::OptionKeys::out::mmCIF_gz, "if outputting mmCIF files, gzip them" ).def(false);
option.add( basic::options::OptionKeys::out::use_database, "Write out structures to database.  Specify database via -inout:dbms:database_name and wanted structures with -in:file:tags" );
option.add( basic::options::OptionKeys::out::database_protocol_id, "Manually specify a protocol ID for database output.  MPI-distributed jobs are the only time when you will want to use this.  It is a temporary workaround to a limitation of the MPI distributor" );
option.add( basic::options::OptionKeys::out::database_filter, "Filter to use with database output.  Arguments for filter follow filter name" );
option.add( basic::options::OptionKeys::out::resume_batch, "Specify 1 or more batch ids to finish an incomplete protocol.  Only works with the DatabaseJobOutputter.  The new jobs will be generated under a new protocol and batch ID" );
option.add( basic::options::OptionKeys::out::nooutput, "Surpress outputfiles" ).def(false);
option.add( basic::options::OptionKeys::out::output, "Force outputfiles" ).def(false);
option.add( basic::options::OptionKeys::out::scorecut, "Only output lowest energy fraction of structures - default 1.0, i.e. output all " ).def(1.0);
option.add( basic::options::OptionKeys::out::show_accessed_options, "In the end of the run show options that has been accessed." ).def(false);
option.add( basic::options::OptionKeys::out::show_unused_options, "In the end of the run show options that were set by the user but never accessed. (Will automatically happen for JD2 protocols.)" ).def(false);
option.add( basic::options::OptionKeys::out::sf, "filename for score output" ).def("score.fsc");
option.add( basic::options::OptionKeys::out::mute, "Mute specified Tracer channels; specify 'all' to mute all channels." );
option.add( basic::options::OptionKeys::out::unmute, "UnMute specified Tracer channels; specify 'all' to unmute all channels." );
option.add( basic::options::OptionKeys::out::level, "Level of Tracer output, any level above will be muted.  Availible levels: 0 - fatal, 100 - error, 200 - warning, 300 - info, 400 - debug, 500 - trace. For additional info please see: src/basic/Tracer.hh and doc page 'Tracer, tool for debug IO'. Default output level is 'info': 300" ).def(300);
option.add( basic::options::OptionKeys::out::levels, "Specified hierarchical mute levels for individual channels in following format: -levels all:300 core.pose:500.  Numeric values could be substituted with mute level names like: debug, info, error etc.  Please note that all:<num> is synonymous to -level:<num>" );
option.add( basic::options::OptionKeys::out::std_IO_exit_error_code, "Specify error code that will be used to exit if std::IO error detected.  This is useful if you want to detect situations like: Rosetta output was redirected to a file but the disk got full, etc.  Default value is 0 which means that error detection code is turned off." ).def(0);
option.add( basic::options::OptionKeys::out::chname, "Add Tracer chanel names to output" ).def(true);
option.add( basic::options::OptionKeys::out::chtimestamp, "Add timestamp to tracer channel name" ).def(false);
option.add( basic::options::OptionKeys::out::dry_run, "If set ComparingTracer will not generate any asserts, and save all Tracer output to a file" ).def(false);
option.add( basic::options::OptionKeys::out::mpi_tracer_to_file, "MPI ONLY: Redirect all tracer output to this file with '_<mpi_rank>' appened as a suffix" ).def("tracer.out");
option.add( basic::options::OptionKeys::out::user_tag, "add this tag to structure tags: e.g., a process id" ).def("");
option.add( basic::options::OptionKeys::out::output_tag, "Prefix output files with this tag, if code checks for it" ).def("");
option.add( basic::options::OptionKeys::out::save_times, "Save modeling time for each model in seconds" ).def(false);
option.add( basic::options::OptionKeys::out::file::file, "Output file option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::out::file::o, "Name of output file" );
option.add( basic::options::OptionKeys::out::file::design_contrast, "output list comparing design sequence to native sequence" ).def("redesign");
option.add( basic::options::OptionKeys::out::file::residue_type_set, "ResidueTypeSet for output files" ).def("fa_standard");
option.add( basic::options::OptionKeys::out::file::atom_tree_diff, "Use atom_tree_diff file output, use filename after this flag" ).def("default.out");
option.add( basic::options::OptionKeys::out::file::atom_tree_diff_bb, "For atom_tree_diff output, how many digits of precision to use for backbone dihedrals" ).def(6);
option.add( basic::options::OptionKeys::out::file::atom_tree_diff_sc, "For atom_tree_diff output, how many digits of precision to use for sidechain dihedrals" ).def(4);
option.add( basic::options::OptionKeys::out::file::atom_tree_diff_bl, "For atom_tree_diff output, how many digits of precision to use for bond lengths" ).def(2);
option.add( basic::options::OptionKeys::out::file::alignment, "Output file for sequence alignment" ).def("out.align");
option.add( basic::options::OptionKeys::out::file::score_only, "Only output scores, no silent files or pdb files" ).def("default.sc");
option.add( basic::options::OptionKeys::out::file::scorefile, "Write a scorefile to the provided filename" ).def("default.sc");
option.add( basic::options::OptionKeys::out::file::scorefile_format, "Scorefile format: text, json" ).def("text");
option.add( basic::options::OptionKeys::out::file::silent, "Use silent file output, use filename after this flag" ).def("default.out");
option.add( basic::options::OptionKeys::out::file::silent_struct_type, "Type of SilentStruct object to use in silent-file output" ).def("protein");
option.add( basic::options::OptionKeys::out::file::silent_print_all_score_headers, "Print a SCORE header for every SilentStruct in a silent-file" ).def(false);
option.add( basic::options::OptionKeys::out::file::raw, "Use silent-type file output" ).def(false);
option.add( basic::options::OptionKeys::out::file::weight_silent_scores, "Weight scores in silent-file output." ).def(true);
option.add( basic::options::OptionKeys::out::file::silent_preserve_H, "Preserve hydrogrens in PDB silent-file format." ).def(false);
option.add( basic::options::OptionKeys::out::file::fullatom, "Enable full-atom output of PDB or centroid structures" ).def(false);
option.add( basic::options::OptionKeys::out::file::suppress_zero_occ_pdb_output, "Suppress output of atoms with zero (or negative) occupancy" ).def(false);
option.add( basic::options::OptionKeys::out::file::output_virtual, "Output virtual atoms in output of PDB" ).def(false);
option.add( basic::options::OptionKeys::out::file::output_virtual_zero_occ, "Set occupancy to 0.0 for virtual atoms in output of PDB" ).def(false);
option.add( basic::options::OptionKeys::out::file::no_chainend_ter, "If true, TER records are not written at the ends of chains in PDB files -- only at the end of all of the ATOM records (the legacy Rosetta behaviour).  False by default (which results in TER records at the ends of every chain)." ).def(false);
option.add( basic::options::OptionKeys::out::file::no_output_cen, "Omit outputting centroids" ).def(false);
option.add( basic::options::OptionKeys::out::file::output_orbitals, "Output all orbitals into PDB." ).def(false);
option.add( basic::options::OptionKeys::out::file::renumber_pdb, "Use Rosetta residue numbering and arbitrary chain labels in pdb output." ).def(false);
option.add( basic::options::OptionKeys::out::file::pdb_parents, "If the pose contains a comment named template, print this as a REMARK in the pdb file" ).def(false);
option.add( basic::options::OptionKeys::out::file::per_chain_renumbering, "When used in conjunction with renumber_pdb, restarts residue numbering at each chain." ).def(false);
option.add( basic::options::OptionKeys::out::file::output_secondary_structure, "output HELIX and SHEET records to StructFileRep / PDB" ).def(false);
option.add( basic::options::OptionKeys::out::file::do_not_autoassign_SS, "Depends on -out:file:output_secondary_structure.  If outputting SS, if this flag is true, it will NOT generate the secondary structure automatically; it will instead assume the secstruct string in the pose is correct" ).def(false);
option.add( basic::options::OptionKeys::out::file::output_torsions, "Output phi, psi, and omega torsions in the PDB output if the pose is ideal." ).def(false);
option.add( basic::options::OptionKeys::out::file::use_occurrence_data, "if option is true reads probabilty matrix from pssm file." ).def(false);
option.add( basic::options::OptionKeys::out::file::pdb_comments, "If the pose contains any comment print it as a COMMENT in the pdb file." ).def(false);
option.add( basic::options::OptionKeys::out::file::force_nonideal_structure, "Force ResidueConformationFeatures to treat the structure as nonideal.  If you know all your structures are non-ideal this decreases pose output time" ).def(true);
option.add( basic::options::OptionKeys::out::file::write_pdb_link_records, "Sets whether or not the LINK records in PDB files are written.  The default value is false." ).shortd( "Write LINK records?" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::out::file::use_pdb_format_HETNAM_records, "Sets whether or not the HETNAM records in PDB files are written in the standard PDB format with a single record per 3-letter code.  The default value is false, which means that the file will use the Rosetta format, which provides a unique HETNAM record for each residue." ).shortd( "Use PDB-format HETNAM records instead of Rosetta-format ones?" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::out::file::write_pdb_parametric_info, "If true, parametric poses have their parameter info included in the REMARK lines of the output PDB file.  True by default." ).shortd( "Write parametric info?" ).legal(true).legal(false).def(true);
option.add( basic::options::OptionKeys::out::file::output_pose_energies_table, "Output the pose energies table.  This can be overridden" ).def(true);
option.add( basic::options::OptionKeys::out::file::output_pose_cache_data, "Output the pose cache." ).def(true);
option.add( basic::options::OptionKeys::out::file::output_pose_fold_tree, "Output the foldtree of the pose. Will go in rosetta_additional column for cif files." ).def(false);

}
inline void add_rosetta_options_1( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::out::file::cif_extra_data_separate_file, "When outputting mmCIF, write extra data and energies to separate files (JOBNAME.extradata and JOBNAME.eneriges)" ).def(false);
option.add( basic::options::OptionKeys::out::file::dont_rewrite_dunbrack_database, "Disables the default behavior of rewriting the Dunrack library in binary format if a binary version is not found" );
option.add( basic::options::OptionKeys::out::file::frag_prefix, "Prefix for fragment output" ).def("default.frags");
option.add( basic::options::OptionKeys::out::file::no_extra_sdf_data, "Do not add extra round-tripping data to SDF file output" ).def(false);
option.add( basic::options::OptionKeys::out::file::no_scores_in_pdb, "Deprated option.  See -output_pose_energies_table and -output_pose_cache_data" );
option.add( basic::options::OptionKeys::out::path::all, "Default file output path" ).def(".");
option.add( basic::options::OptionKeys::out::path::path, "Default file output path" ).def(".").is_group(true);
option.add( basic::options::OptionKeys::out::path::pdb, "PDB file output path" );
option.add( basic::options::OptionKeys::out::path::db, "Database file output path if using FeatureReporters or database output" ).def(".");
option.add( basic::options::OptionKeys::out::path::score, "Score file output path" );
option.add( basic::options::OptionKeys::out::path::scratch, "use this path as scratch drive" ).def("/scratch/USERS/");
option.add( basic::options::OptionKeys::out::path::mpi_rank_dir, "Put silent-output files in individual directory as determined by mpi-rank" ).def(false);
option.add( basic::options::OptionKeys::out::path::mmCIF, "if outputting mmCIF, mmCIF file output path" );
option.add( basic::options::OptionKeys::run::run, "Run option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::run::batches, "batch_flag_files" ).def("");
option.add( basic::options::OptionKeys::run::no_prof_info_in_silentout, "no time-columns appears in score/silent - files" ).def(false);
option.add( basic::options::OptionKeys::run::archive, "run MPIArchiveJobDistributor" ).def(false);
option.add( basic::options::OptionKeys::run::n_replica, "run MPIMultiCommJobDistributor with n_replica processes per job" ).def(1);
option.add( basic::options::OptionKeys::run::shuffle, "Shuffle job order" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::run::msd_job_dist, "Use MSD Job Distributor" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::run::msd_randomize, "Randomize order of input poses for MSD" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::run::n_cycles, "Option to control miscellaneous cycles within protocols.  This has no core meaning - it is meant to reduce option-bloat by having every protocol define separate cycles options.  Check your protocol's documentation to see if it is used." ).lower(1).def(1);
option.add( basic::options::OptionKeys::run::repeat, "Repeat mover N times" ).lower(0).def(1);
option.add( basic::options::OptionKeys::run::max_min_iter, "Maximum number of iterations of dfpmin" ).def(200);
option.add( basic::options::OptionKeys::run::maxruntime, "Maximum runtime in seconds. JobDistributor will signal end if time is exceeded no matter how many jobs were finished." ).def(-1);
option.add( basic::options::OptionKeys::run::maxruntime_bufferfactor, "If set, the JobDistributor will attempt to stop if there doesn't appear to be enough time for `maxruntime_bufferfactor` jobs before maxruntime occurs." ).def(0);
option.add( basic::options::OptionKeys::run::write_failures, "write failed structures to output" ).def(false);
option.add( basic::options::OptionKeys::run::benchmark, "Run in benchmark mode" );
option.add( basic::options::OptionKeys::run::test_cycles, "When running tests, use reduced cycles.  Cycles must be defined in the code itself" ).def(false);
option.add( basic::options::OptionKeys::run::memory_test_cycles, "use together with test_cycles to keep number of copies of anything as high as in production mode" ).def(false);
option.add( basic::options::OptionKeys::run::dry_run, "Run through structures/tasks/etc skipping the actual calculation step for testing of I/O and/or setup" ).def(false);
option.add( basic::options::OptionKeys::run::debug, "Run in debug mode" );
option.add( basic::options::OptionKeys::run::profile, "Run in profile mode" ).def(false);
option.add( basic::options::OptionKeys::run::max_retry_job, "If a job fails with FAIL_RETRY retry this many times at most" ).def(10);
option.add( basic::options::OptionKeys::run::version, "write out SVN version info, if it was available at compile time" ).def(true);
option.add( basic::options::OptionKeys::run::nodelay, "Do not delay launch of minirosetta" );
option.add( basic::options::OptionKeys::run::delay, "Wait N seconds before doing anything at all. Useful for cluster job staggering." ).def(0);
option.add( basic::options::OptionKeys::run::random_delay, "Wait a random amount of 0..N seconds before doing anything at all. Useful for cluster job staggering." ).def(0);
option.add( basic::options::OptionKeys::run::timer, "write out time per decoy in minutes in scorefile" );
option.add( basic::options::OptionKeys::run::chain, "-chain <chain_id>" ).def("-");
option.add( basic::options::OptionKeys::run::score_only, "calculate the score only and exit" ).def(false);
option.add( basic::options::OptionKeys::run::decoystats, "calculate values of a series of additional structural properties, including counting unsatisfied buried Hbond donors and acceptors, SASApack, etc. Additional output associated with this flag is written both to stdout and to output PDB files" );
option.add( basic::options::OptionKeys::run::output_hbond_info, "print hydrogen bond info in the stats section of written out PDB files" );
option.add( basic::options::OptionKeys::run::wide_nblist_extension, "Amount to extend the wide neighbor list" ).def(2.0);
option.add( basic::options::OptionKeys::run::constant_seed, "Use a constant seed (1111111 unless specified)" );
option.add( basic::options::OptionKeys::run::jran, "Specify seed (requires -constant_seed)" ).def(1111111);
option.add( basic::options::OptionKeys::run::use_time_as_seed, "Use time as random number seed instead of default rng seed device." );
option.add( basic::options::OptionKeys::run::rng_seed_device, "Obtain random number seed from specified device." ).def("/dev/urandom");
option.add( basic::options::OptionKeys::run::seed_offset, "This value will be added to the random number seed. Useful when using time as seed 			and submitting many jobs to clusters.  Using the condor job id will force jobs that 			are started in the same second to still have different initial seeds" ).def(0);
option.add( basic::options::OptionKeys::run::rng, "Random number generation algorithm: Currently only mt19937 is a accepted here" ).legal("mt19937").def("mt19937");
option.add( basic::options::OptionKeys::run::rebuild_disulf, "Attempt to build correct disulfide geometry when converting from a centroid pose to a full atom pose. Disulfides must be previously annotated, either by enabling -detect_disulf or by specifying a file to -fix_disulf." ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::run::preserve_header, "Maintain header info from input PDB when writing output PDBs" );
option.add( basic::options::OptionKeys::run::suppress_checkpoints, "Override & switch off checkpoints." );
option.add( basic::options::OptionKeys::run::checkpoint, "Turn checkpointing on" );
option.add( basic::options::OptionKeys::run::delete_checkpoints, "delete the checkpoints after use" ).def(true);
option.add( basic::options::OptionKeys::run::checkpoint_interval, "Checkpoint time interval in seconds" ).lower(10).def(600);
option.add( basic::options::OptionKeys::run::protocol, "Which protocol to run, for Rosetta@home wrapper" ).legal("abrelax").legal("simple_cycpep_predict").legal("broker").legal("vf_abrelax").legal("ligand_dock").legal("relax").legal("symdock").legal("star").legal("loophash").legal("looprelax").legal("threading").legal("rbsegmentrelax").legal("boinc_debug").legal("parser").legal("jd2_scripting").legal("cm").legal("flxbb").legal("rna").legal("ddg").legal("canonical_sampling").legal("nonlocal_frags").legal("medal").def("abrelax");
option.add( basic::options::OptionKeys::run::remove_ss_length_screen, "Sets the use_ss_length_screen flag in the Fragment Mover to false" );
option.add( basic::options::OptionKeys::run::min_type, "type of minimizer to use" ).legal("linmin").legal("linmin_iterated").legal("linmin_iterated_atol").legal("dfpmin").legal("dfpmin_armijo").legal("dfpmin_armijo_nonmonotone").legal("dfpmin_atol").legal("dfpmin_armijo_atol").legal("dfpmin_armijo_nonmonoton_atol").legal("dfpmin_strong_wolfe").legal("dfpmin_strong_wolfe_atol").legal("lbfgs_armijo").legal("lbfgs_armijo_rescored").legal("lbfgs_armijo_atol").legal("lbfgs_armijo_nonmonotone").legal("lbfgs_armijo_nonmonotone_atol").legal("lbfgs_strong_wolfe").def("lbfgs_armijo_nonmonotone");
option.add( basic::options::OptionKeys::run::min_tolerance, "minimizer tolerance" ).def(0.000001);
option.add( basic::options::OptionKeys::run::nblist_autoupdate, "Turn on neighborlist auto-updates for all minimizations" ).def(false);
option.add( basic::options::OptionKeys::run::nblist_autoupdate_narrow, "With nblist autoupdate: the reach in Angstroms for the narrow neighbor list" ).def(0.5);
option.add( basic::options::OptionKeys::run::nblist_autoupdate_wide, "With nblist autoupdate: the reach in Angstroms for the wide neighbor list" ).def(2.0);
option.add( basic::options::OptionKeys::run::skip_set_reasonable_fold_tree, "Do not run set_reasonable_fold_tree when creating a pose from a pdb.  Useful for unreasonable PDBs where the user sets a fold tree explicitly." ).def(false);
option.add( basic::options::OptionKeys::run::randomize_missing_coords, "Insert random coordinates for missing density atoms ( occupancy is zero ) and for any atoms with negative occupancy, randomizing coords is done by default" ).def(false);
option.add( basic::options::OptionKeys::run::ignore_zero_occupancy, "discard coords information for missing density atoms ( occupancy is zero ) defined in input structures.  Default is to keep those coordinates because this is a consistent problem for end users" ).def(true);
option.add( basic::options::OptionKeys::run::cycles_outer, "number of outer cycles" ).lower(1).def(1);
option.add( basic::options::OptionKeys::run::cycles_inner, "number of inner cycles" ).lower(1).def(1);
option.add( basic::options::OptionKeys::run::repack_rate, "repack after every [value] cycles during certain protocols" ).lower(1).def(10);
option.add( basic::options::OptionKeys::run::reinitialize_mover_for_each_job, "job distributor will generate fresh copy of its mover before each apply (once per job)" ).def(false);
option.add( basic::options::OptionKeys::run::reinitialize_mover_for_new_input, "job distributor will generate fresh copy of its mover whenever the pose being passed to the mover is going to change (e.g., next PDB in -l)" ).def(false);
option.add( basic::options::OptionKeys::run::multiple_processes_writing_to_one_directory, "activates .in_progress files used to communicate between independent processes that a job is underway.  UNSAFE but may be convenient." ).def(false);
option.add( basic::options::OptionKeys::run::jobdist_miscfile_ext, "extension for JobOutputter file() function (miscellaneous file output)." ).def(".data");
option.add( basic::options::OptionKeys::run::no_scorefile, "do not output scorefiles" ).def(false);
option.add( basic::options::OptionKeys::run::other_pose_to_scorefile, "write other_pose (JobOutputter) to a scorefile; path by other_pose_scorefile; be warned you can get garbage if scorefunctions for poses do not match.  Overridden by no_scorefile" ).def(false);
option.add( basic::options::OptionKeys::run::other_pose_scorefile, "Path to other_pose (JobOutputter) scorefiles.  Default is same scorefile as regular result poses.  The default will cause problems if your output poses were scored on different scorefunctions." ).def("");
option.add( basic::options::OptionKeys::run::intermediate_scorefiles, "write intermediate evaluations to disk (depends on your protocol if and how often this happens" ).def(false);
option.add( basic::options::OptionKeys::run::intermediate_structures, "write structures together with intermediate evaluations" ).def(false);
option.add( basic::options::OptionKeys::run::idealize_before_protocol, "run idealize first, before running whatever." );
option.add( basic::options::OptionKeys::run::interactive, "Signal Rosetta is to be run as a library in an interactive application. In particular, favor throwing exceptions on bad inputs rather than exiting." ).def(false);
option.add( basic::options::OptionKeys::run::condor, "if condor say yes -- proc_id counting starts at 0" ).def(false);
option.add( basic::options::OptionKeys::run::nproc, "number of process... needed if proc_id is specified" ).def(0);
option.add( basic::options::OptionKeys::run::proc_id, "give process number... Jobdistributor will only work on proc_id mod nproc part of work " ).def(0);
option.add( basic::options::OptionKeys::run::exit_if_missing_heavy_atoms, "quit if heavy atoms missing in pdb" ).def(false);
option.add( basic::options::OptionKeys::run::show_simulation_in_pymol, "Attach PyMOL observer to pose at the beginning of the simulation. Waits until at least every [argument] seconds before sending pose if something has changed, default 5. A value of 0 indicates to not skip any packets from sending! Don't forget to run the PyMOLPyRosettaServer.py script within PyMOL!" ).def(5.0);
option.add( basic::options::OptionKeys::run::update_pymol_on_energy_changes_only, "Only Update the simulation in on energy change.  Useful if pymol observer is segfaulting on length changes." ).def(false);
option.add( basic::options::OptionKeys::run::update_pymol_on_conformation_changes_only, "Only update the simulation in pymol on conformation change." ).def(false);
option.add( basic::options::OptionKeys::run::keep_pymol_simulation_history, "Keep history when using show_simulation_in_pymol flag?" ).def(false);
option.add( basic::options::OptionKeys::run::insert_disulfide_constraint_weight, "Weight of the constraints on disulfide bonds formed by the DisulfideInsertionMover; EXPERIMENTAL" ).def(0.0);
option.add( basic::options::OptionKeys::jd3::jd3, "jd3 option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::jd3::mpi_work_partition_job_distributor, "determine if we should use the WorkPartition job distributor" ).def(false);
option.add( basic::options::OptionKeys::jd3::job_definition_schema, "If provided on the command line, the job distributor will write the XML Schema for the applciation's job definition file out to disk and then exit" );
option.add( basic::options::OptionKeys::jd3::mpi_fast_nonblocking_output, "By default the master node blocks while a slave node outputs to avoid two slaves writing to a score file or silent file at the same time setting this to true disables that feature" ).def(false);
option.add( basic::options::OptionKeys::jd3::n_archive_nodes, "The number of nodes that should perform archival roles only. This flag is only used by the MPIWorkPoolJobDistributor" ).def(0);
option.add( basic::options::OptionKeys::jd3::do_not_archive_on_node0, "Should the master node in the MPIWorkPoolJobDistributor archive any JobResults on it?" ).def(false);
option.add( basic::options::OptionKeys::jd2::jd2, "jd2 option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::jd2::pose_input_stream, "Use PoseInputStream classes for Pose input" ).def(false);
option.add( basic::options::OptionKeys::jd2::lazy_silent_file_reader, "use lazy silent file reader in job distributor, read in a structure only when you need to" ).def(false);
option.add( basic::options::OptionKeys::jd2::mpi_nowait_for_remaining_jobs, "exit immediately (not graceful -- not complete) if the last job has been sent out" ).def(false);
option.add( basic::options::OptionKeys::jd2::mpi_timeout_factor, "timeout is X times average job-completion time - set to 0 to switch off" ).def(0);
option.add( basic::options::OptionKeys::jd2::mpi_work_partition_job_distributor, "determine if we should use the WorkPartition job distributor" ).def(false);
option.add( basic::options::OptionKeys::jd2::mpi_file_buf_job_distributor, "determine if we should use the MPIFileBufJobDistributor (warning: silent output only)" ).def(true);
option.add( basic::options::OptionKeys::jd2::mpi_filebuf_jobdistributor, "same as mpi_file_buf_job_distributor but with more intuitive spacing... determine if we should use the MPIFileBufJobDistributor (warning: silent output only)" ).def(true);
option.add( basic::options::OptionKeys::jd2::mpi_fast_nonblocking_output, "By default the master node blocks while a slave node outputs to avoid two slaves writing to a score file or silent file at the same time setting this to true disables that feature" ).def(false);
option.add( basic::options::OptionKeys::jd2::dd_parser, "determine whether to use the dock_design_parser" ).def(false);
option.add( basic::options::OptionKeys::jd2::ntrials, "number of attempts at creating an output file for each nstruct. e.g., ntrials 3 and nstruct 10 would mean that each of 10 trajectories would attempt to write an output file 3 times and if unsuccessful would fail." );
option.add( basic::options::OptionKeys::jd2::generic_job_name, "job name when using GenericJobInputter (i.e. abinitio)" ).def("S");
option.add( basic::options::OptionKeys::jd2::no_output, "use NoOutputJobOutputter; do not store the pose after a run (no silent or scorefile)" ).def(false);
option.add( basic::options::OptionKeys::jd2::enzdes_out, "causes an enzdes-style scorefile (with information about catalytic res and some pose metric stuff ) to be written instead of the regular scorefile" ).def(false);
option.add( basic::options::OptionKeys::jd2::buffer_silent_output, "write structures to silent-files in blocks of N structures to" ).def(1);
option.add( basic::options::OptionKeys::jd2::buffer_flush_frequency, "when N structures (buffer_silent_output) are collected dump to file with probability X" ).def(1.0);
option.add( basic::options::OptionKeys::jd2::delete_old_poses, "Delete poses after they have been processed.  For jobs that process a large number of structures, the memory consumed by old poses is wasteful." ).def(false);
option.add( basic::options::OptionKeys::jd2::resource_definition_files, "Specify all the jobs and all of their resources to the new JD2ResourceManager system" );
option.add( basic::options::OptionKeys::jd2::checkpoint_file, "write/read nstruct-based checkpoint files to the desired filename." );
option.add( basic::options::OptionKeys::jd2::failed_job_exception, "If JD2 encounters an error during job execution, raise an exception at the end of the run" ).def(true);
option.add( basic::options::OptionKeys::jd2::max_nstruct_in_memory, "If nstruct is set higher than this number, JD2 will keep only this many jobs in memory in the jobs list at any given time (to keep the jobs list from filling up memory).  As jobs complete, they will be deleted and the jobs list will be filled out with new jobs.  This option is intended for exteremly large runs on systems like the Blue Gene/Q supercomputer.  To disable this sort of memory management, set this option to 0." ).def(1000000);
option.add( basic::options::OptionKeys::jd2::sequential_mpi_job_distribution, "If specified, MPI versions of the JobDistributor send jobs to each slave in sequence (slave1, slave2, slave3 etc.).  False by default.  Note that this should NOT be used for production runs; it is intended only for regression tests in which non-sequential job distribution would result in stochastic variations." ).def(false);
option.add( basic::options::OptionKeys::jd2::grid_ensemble, "Do an ensemble search where each input pdb is used for an ensemble based search.  Instead of each in file outputting nstruct, we use the input files to generate a total nstruct across the inputs" ).def(false);
option.add( basic::options::OptionKeys::jd2::seed_ensemble, "Do an ensemble search as in grid_search, but randomly choose the seeds over the inputs.  See seed_ensemble_weights to weight the inputs" ).def(false);
option.add( basic::options::OptionKeys::jd2::seed_ensemble_weights, "Specifiy weights for seeded ensemble.  Must match number of inputs.  See also: -seed_ensemble_weights_file" );
option.add( basic::options::OptionKeys::jd2::seed_ensemble_weights_file, "A file specifying weights to use for each input structure.  Two columns.  basename with extension (or relative path or full path), weight" );
option.add( basic::options::OptionKeys::score::score_pose_cutpoint_variants, "Include cutpoint variants in the pose during linear chainbreak" ).def(false);
option.add( basic::options::OptionKeys::score::score, "scorefunction option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::score::weights, "Name of weights file (without extension .wts)" ).def("talaris2014");
option.add( basic::options::OptionKeys::score::set_weights, "Modification to weights via the command line. Applied in ScoreFunctionFactory::create_score_function inside the function apply_user_defined_reweighting_. Format is a list of paired strings: -score::set_weights <score_type1> <setting1> <score_type2> <setting2> ..." );
option.add( basic::options::OptionKeys::score::pack_weights, "Name of packing weights file (without extension .wts)" ).def("talaris2014");
option.add( basic::options::OptionKeys::score::soft_wts, "Name of the 'soft' weights file, for protocols which use it." ).def("soft_rep");
option.add( basic::options::OptionKeys::score::docking_interface_score, "the score is computed as difference between bound and unbound pose" ).def(false);
option.add( basic::options::OptionKeys::score::min_score_score, "do not consider scores lower than min-score in monte-carlo criterion" ).def(0.0);
option.add( basic::options::OptionKeys::score::custom_atom_pair, "filename for custom atom pair constraints" ).def("empty");
option.add( basic::options::OptionKeys::score::patch, "Name of patch file (without extension)" ).def("");
option.add( basic::options::OptionKeys::score::empty, "Make an empty score - i.e. NO scoring" );
option.add( basic::options::OptionKeys::score::fa_max_dis, "How far does the FA pair potential go out to ?" ).def(6.0);
option.add( basic::options::OptionKeys::score::fa_Hatr, "Turn on Lennard Jones attractive term for hydrogen atoms" );
option.add( basic::options::OptionKeys::score::no_smooth_etables, "Revert to old style etables" );
option.add( basic::options::OptionKeys::score::no_lk_polar_desolvation, "Disable the polar-desolvation component of the LK solvation model; effectively set dGfree for polar atoms to 0" );
option.add( basic::options::OptionKeys::score::lk_polar_without_proline_N, "Force class LK_PolarNonPolarEnergy to treat the N atom of proline as non-polar" ).def(false);
option.add( basic::options::OptionKeys::score::input_etables, "Read etables from files with given prefix" );
option.add( basic::options::OptionKeys::score::output_etables, "Write out etables to files with given prefix" );
option.add( basic::options::OptionKeys::score::analytic_etable_evaluation, "Instead of interpolating between bins, use an analytic evaluation of the lennard-jones and solvation energies" ).def(true);
option.add( basic::options::OptionKeys::score::put_intra_into_total, "Put intra-residue terms inside hbond, geom_sol_fast, fa_atr. (Contributions will not show up in hbond_intra, fa_atr_intra_xover4.) Off for proteins by default." ).def(false);
option.add( basic::options::OptionKeys::score::include_intra_res_protein, "Include computation of intra-residue terms for proteins." ).def(false);
option.add( basic::options::OptionKeys::score::fa_stack_base_base_only, "Only calculate fa_stack for RNA base/base." ).def(true);
option.add( basic::options::OptionKeys::score::fa_stack_sol_prefactor, "Strength of sol penalty in fa_stack_sol." ).def(0.1);
option.add( basic::options::OptionKeys::score::fa_stack_sol_stack_cutoff, "distances below this get full sol stack." ).def(5.5);
option.add( basic::options::OptionKeys::score::fa_stack_sol_dist_cutoff, "distances below this get some sol stack." ).def(6.5);
option.add( basic::options::OptionKeys::score::fa_stack_lr_prefactor, "Strength of lr penalty in fa_stack_lr." ).def(-0.05);
option.add( basic::options::OptionKeys::score::fa_stack_lr_stack_cutoff, "distances below this get full lr stack." ).def(6.5);
option.add( basic::options::OptionKeys::score::fa_stack_lr_dist_cutoff, "distances below this get some lr stack." ).def(7.5);
option.add( basic::options::OptionKeys::score::geom_sol_interres_path_distance_cutoff, "Minimum no. bonds between atoms in different residues to calculate geom_sol" ).def(0);
option.add( basic::options::OptionKeys::score::geom_sol_intrares_path_distance_cutoff, "Minimum no. bonds between atoms in same residues to calculate geom_sol" ).def(6);
option.add( basic::options::OptionKeys::score::rms_target, "Target of RMS optimization for RMS_Energy EnergyMethod" ).def(0.0);
option.add( basic::options::OptionKeys::score::ramaneighbors, "Uses neighbor-dependent ramachandran maps" ).def(false);
option.add( basic::options::OptionKeys::score::optH_weights, "Name of weights file (without extension .wts) to use during optH" );
option.add( basic::options::OptionKeys::score::optH_patch, "Name of weights file (without extension .wts) to use during optH" );
option.add( basic::options::OptionKeys::score::hb_don_strength, "Modification of hbond donor-atom strengths, over-rides any database file settings. Format is -hb_don_strength <atm1>:<wt1> <atm2>:<wt2> ...   For example -hb_don_strength hbdon_IND:1.5 hbdon_AHX:0.5" );
option.add( basic::options::OptionKeys::score::hb_acc_strength, "Modification of hbond acceptor-atom strengths, over-rides any database file settings. Format is -hb_acc_strength <atm1>:<wt1> <atm2>:<wt2> ...   For example -hb_acc_strength hbacc_CXA:1.5 hbdon_HXL:0.5" );
option.add( basic::options::OptionKeys::score::hbe_for_dH2O_aGEN_SP3SC_ssother, "HBEvalType for HBEvalTuple(hbdon_H2O, hbacc_GENERIC_SP3SC, seq_sep_other)" ).def("hbe_dH2OaHXL");
option.add( basic::options::OptionKeys::score::hbond_params, "Directory name in the database for which hydrogen bond parameters to use." ).def("sp2_elec_params");
option.add( basic::options::OptionKeys::score::hbond_bb_per_residue_energy, "In score tables, separate out backbone hydrogens bond energies per residue. By default, bb hbonds are included in the total energy, but not per residue energies" ).def(false);
option.add( basic::options::OptionKeys::score::hbond_disable_bbsc_exclusion_rule, "Disable the rule that protein bb/sc hbonds are excluded if the backbone group is already forming a hydrogen bond to a backbone group; with this flag, no hbonds are excluded" ).def(false);
option.add( basic::options::OptionKeys::score::symE_units, "Number of symmetric Units in design for use with symE scoring" ).def(-1);
option.add( basic::options::OptionKeys::score::symE_bonus, "Energy bonus per match for use with symE scoring" ).def(0.0);
option.add( basic::options::OptionKeys::score::symmetric_gly_tables, "If true, the Ramachandran and P_AA_PP tables for glycine will be symmetrized on load.  If false (the default), then the statistical tables will be used, which are asymmetric due to the contribution of chiral amino acids." ).def(false);
option.add( basic::options::OptionKeys::score::NV_lbound, "Lower Bound for neighbor Vector scoring" ).def(3.3);
option.add( basic::options::OptionKeys::score::NV_ubound, "Upper Bound for neighbor Vector scoring" ).def(11.1);
option.add( basic::options::OptionKeys::score::NV_table, "Location of path to potential lookup table" ).def("scoring/score_functions/NV/neighbor_vector_score.histogram");
option.add( basic::options::OptionKeys::score::disable_orientation_dependent_rna_ch_o_bonds, "Do not use orientation-dependent potential for RNA carbon hydrogen bonds" ).def(false);
option.add( basic::options::OptionKeys::score::rna_torsion_potential, "In RNA torsion calculation, directory containing 1D torsional potentials" ).def("ps_04282011");
option.add( basic::options::OptionKeys::score::rna_suite_potential, "In RNA calculation, directory containing suite potentials" ).def("Richardson");
option.add( basic::options::OptionKeys::score::suiteness_bonus, "In RNA calculation, directory containing suiteness bonus definition" ).def("Richardson");
option.add( basic::options::OptionKeys::score::rna_torsion_skip_chainbreak, "Don't score RNA torsions located at the chain_breaks (aside from the ones that will be closed)" ).def(true);
option.add( basic::options::OptionKeys::score::rna_chemical_shift_verbose, "print out chemical shifts; useful for debug" ).def(false);
option.add( basic::options::OptionKeys::score::rna_chemical_shift_larmord, "Use LARMORD to calculate 1H chemical shifts" ).def(false);
option.add( basic::options::OptionKeys::score::rna_chemical_shift_exp_data, "rna_chemical_shift_exp_data" ).def("");
option.add( basic::options::OptionKeys::score::rna_chemical_shift_larmord_par, "larmord parameters file" ).def("larmord_1.0_nocut_parameters.dat");
option.add( basic::options::OptionKeys::score::rna_chemical_shift_larmord_wt, "larmord expected accuracy file" ).def("larmord_noweights.txt");
option.add( basic::options::OptionKeys::score::rna_chemical_shift_larmord_ref, "larmord reference  chemical shift file" ).def("larmord_1.0_reference_shifts.dat");
option.add( basic::options::OptionKeys::score::rna_chemical_shift_larmord_nei, "larmord neighbor atom shift file" ).def("larmord_1.0_neighbor_atoms.dat");
option.add( basic::options::OptionKeys::score::rna_chemical_shift_larmord_cut, "larmord distance cutoff" ).def(9999.9);
option.add( basic::options::OptionKeys::score::rna_chemical_shift_larmord_beta, "larmord beta value (the exponent)" ).def(-3.0);
option.add( basic::options::OptionKeys::score::rna_chemical_shift_H5_prime_mode, "rna_chemical_shift_H5_prime_mode" ).def("");
option.add( basic::options::OptionKeys::score::rna_chemical_shift_include_res, "rna_chemical_shift_include_res" );
option.add( basic::options::OptionKeys::score::DMS_separate_features, "in RNA DMS scoring, calculate N1-bonded, occupancy, and binding-energy-based scores as if they were uncorrelated features and sum scores. " ).def(false);
option.add( basic::options::OptionKeys::score::DMS_careful_base_pair_classifier, "in RNA lo-res DMS scoring, use detailed base pair classification to assess lores score " ).def(false);
option.add( basic::options::OptionKeys::score::rna_chem_map_lores_weight, "In RNA lo-res chemical mapping scoring, final strength of rna_chem_map_lores term when -data_file is specified." ).def(0.0);
option.add( basic::options::OptionKeys::score::use_2prime_OH_potential, "Use torsional potential for RNA 2prime OH." ).def(true);
option.add( basic::options::OptionKeys::score::include_neighbor_base_stacks, "In RNA score calculation, include stacks between i,i+1" ).def(false);
option.add( basic::options::OptionKeys::score::FA_low_res_rnp_scoring, "RNA/protein low-res scoring using full atom protein residues" ).def(false);
option.add( basic::options::OptionKeys::score::find_neighbors_3dgrid, "Use a 3D lookup table for doing neighbor calculations.  For spherical, well-distributed conformations, O(N) neighbor detection instead of general O(NlgN)" ).def(false);
option.add( basic::options::OptionKeys::score::find_neighbors_stripehash, "should be faster than 3dgrid and use 1/8th the memory" ).def(false);
option.add( basic::options::OptionKeys::score::seqdep_refene_fname, "Filename for table containing sequence-dependent reference energies" );
option.add( basic::options::OptionKeys::score::secondary_seqdep_refene_fname, "Additional filename for table containing sequence-dependent reference energies" );
option.add( basic::options::OptionKeys::score::exact_occ_pairwise, "When using occ_sol_exact, compute energies subject to pairwise additivity (not recommended - intended for parameterization / evaluation purposes)" ).def(false);
option.add( basic::options::OptionKeys::score::exact_occ_skip_Hbonders, "When using occ_sol_exact, do not count contributions from occluding groups which form Hbonds to the polar group of interest" ).def(true);
option.add( basic::options::OptionKeys::score::exact_occ_pairwise_by_res, "When using occ_sol_exact, compute energies subject to by-residue pairwise additivity (not recommended - intended for parameterization / evaluation purposes)" ).def(false);
option.add( basic::options::OptionKeys::score::exact_occ_split_between_res, "When using occ_sol_exact with the exact_occ_pairwise flag, split the energies between both contributing residues instead of assigning it just to the polar residue (not recommended - intended for parameterization / evaluation purposes)" ).def(false);
option.add( basic::options::OptionKeys::score::exact_occ_self_res_no_occ, "Setting this to false means that the self-residue CAN occlude when using the exact ODO model, leading to potential double-counting with the Dunbrack energy but better results in loop discrimination." ).def(false);
option.add( basic::options::OptionKeys::score::exact_occ_radius_scaling, "When using occ_sol_exact, scale the radii of occluding atoms by this factor (intended for parameterization / evaluation purposes)" ).def(1.0);
option.add( basic::options::OptionKeys::score::ref_offsets, "offset reference energies using 3 character residue types (example: TRP 0.9 HIS 0.3)" );
option.add( basic::options::OptionKeys::score::ref_offset, "offset all reference energies by this amount" ).def(0.0);
option.add( basic::options::OptionKeys::score::output_residue_energies, "Output the energy for each residue" ).def(false);
option.add( basic::options::OptionKeys::score::fa_custom_pair_distance_file, "Name of custom pair distance energy file" ).def("");
option.add( basic::options::OptionKeys::score::disulf_matching_probe, "Size of probe to use in disulfide matching score" ).def(2.5);
option.add( basic::options::OptionKeys::score::bonded_params, "Default spring constants for bonded parameters [length,angle,torsion,proton-torsion,improper-torsion]" );
option.add( basic::options::OptionKeys::score::bonded_params_dir, "Spring constants for bonded parameters [length,angle,torsion,proton-torsion,improper-torsion]" ).def("scoring/score_functions/bondlength_bondangle");
option.add( basic::options::OptionKeys::score::extra_improper_file, "Add extra parameters for improper torsions" );
option.add( basic::options::OptionKeys::score::pro_close_planar_constraint, "stdev of CD,N,CA,prevC trigonal planar constraint in pro_close energy method" ).def(0.1);
option.add( basic::options::OptionKeys::score::no_pro_close_ring_closure, "The pro_close term holds the proline ring closed, but also has some inter-residue energy associated with the psi value of the preceding residue.  If this flag is set to 'true', the term ONLY does the torsional stuff -- it doesn't hold the ring closed.  For use with cart_bonded or ring_close.  False by default." ).def(false);
option.add( basic::options::OptionKeys::score::ring_close_shadow_constraint, "Standard deviation of the harmonic potential used to hold shadow atoms atop real atoms in order to hold rings closed with the ring_close scoring term.  Analogous to pro_close_planar_constraint option for the pro_close energy term." ).def(0.1);
option.add( basic::options::OptionKeys::score::linear_bonded_potential, "use linear (instead of quadratic) bonded potential" ).def(false);
option.add( basic::options::OptionKeys::score::free_suite_bonus, "Amount to reward virtualization of a nucleotide suite" ).def(-1.0);
option.add( basic::options::OptionKeys::score::free_sugar_bonus, "Amount to reward virtualization of a sugar/ribose" ).def(-1.0);
option.add( basic::options::OptionKeys::score::free_2HOprime_bonus, "Amount to reward virtualization of a 2'-OH" ).def(-0.5);
option.add( basic::options::OptionKeys::score::syn_G_potential_bonus, "Amount to reward syn chi conformation of guanosine" ).def(0.0);
option.add( basic::options::OptionKeys::score::pack_phosphate_penalty, "Amount to penalize instantiation of a 5' or 3' phosphate" ).def(0.25);
option.add( basic::options::OptionKeys::score::free_side_chain_bonus, "Amount to reward virtualization of a protein side chain, per free chi" ).def(-0.5);
option.add( basic::options::OptionKeys::score::bond_angle_sd_polar_hydrogen, "Standard deviation for bond_geometry angle term with -vary_polar_hydrogen_geometry flag, in degrees" ).def(60.0);
option.add( basic::options::OptionKeys::score::bond_torsion_sd_polar_hydrogen, "Standard deviation for bond_geometry torsion term with -vary_polar_hydrogen_geometry flag, in degrees" ).def(30.0);
option.add( basic::options::OptionKeys::score::rna_bulge_bonus_once_per_loop, "For legacy stepwise term rna_bulge in SWM runs, compute bulge bonus on a per-loop basis, rather than a bonus for each virtual residue." ).def(true);
option.add( basic::options::OptionKeys::score::compute_mg_sol_for_hydrogens, "mg_sol includes penalties for hydrogens near Mg(2+)" ).def(false);
option.add( basic::options::OptionKeys::score::rg_local_span, "First,last res in rg_local. For example to calc rg_local from 1-20 would be 1,20" ).def(0);
option.add( basic::options::OptionKeys::score::unmodifypot, "Do not call modify pot to add extra repulsive interactions between Obb/Obb atom types at distances beneath 3.6 Angstroms" );
option.add( basic::options::OptionKeys::score::conc, "intermolecular concentration to use in intermol term (give in M)" ).def(1.0);
option.add( basic::options::OptionKeys::score::sidechain_buried, "count buried residues (rvernon pilot app)" ).def(-1);
option.add( basic::options::OptionKeys::score::sidechain_exposed, "count exposed residues (rvernon pilot app)" ).def(-1);
option.add( basic::options::OptionKeys::score::aa_composition_setup_file, "The filename of one or more setup files for the aa_composition scoring term.  (Multiple such files can be listed, separated by a space.)  The default location for these files (which have a .comp extension) is /database/scoring/score_functions/aa_composition/." );
option.add( basic::options::OptionKeys::score::aa_repeat_energy_penalty_file, "The filename of a penalty file for the aa_repeat_energy term.  The penalty file should be a series of numbers on a single line, representing the penalty for having a repeat of 1, 2, 3, etc. of the same residue.  Penalty files are stored in database/scoring/score_functions/aa_repeat_energy/ and should have the suffix .rpt_pen.  The default is default_repeat_penalty_table.rpt_pen." ).def("default_repeat_penalty_table.rpt_pen");
option.add( basic::options::OptionKeys::score::aspartimide_penalty_value, "The penalty for each aspartimide-forming two-residue sequence found, when the aspartimide_penalty score term weight is set to 1.0.  Default is 25.0." ).def(25.0);
option.add( basic::options::OptionKeys::score::elec_min_dis, "changes the minimum distance cut-off for hack-elec energy" ).def(1.6);
option.add( basic::options::OptionKeys::score::elec_max_dis, "changes the maximum distance cut-off for hack-elec energy" ).def(5.5);
option.add( basic::options::OptionKeys::score::elec_die, "changes the dielectric constant for hack-elec energy" ).def(10.0);
option.add( basic::options::OptionKeys::score::elec_r_option, "changes the dielectric from distance dependent to distance independent" ).def(false);
option.add( basic::options::OptionKeys::score::elec_sigmoidal_die, "changes the dielectric from distance dependent to sigmoidal" ).def(false);
option.add( basic::options::OptionKeys::score::elec_sigmoidal_die_D, "D parameter for sigmoidal dielectric" ).def(78.0);
option.add( basic::options::OptionKeys::score::elec_sigmoidal_die_D0, "D0 parameter for sigmoidal dielectric" ).def(2.0);
option.add( basic::options::OptionKeys::score::elec_sigmoidal_die_S, "S parameter for sigmoidal dielectric" ).def(0.36);
option.add( basic::options::OptionKeys::score::elec_representative_cp, "Use representative atoms for countpair to avoid dipole splits" ).def(false);
option.add( basic::options::OptionKeys::score::elec_representative_cp_flip, "Enable elec_representative_cp, but FLIP the order in the table" ).def(false);
option.add( basic::options::OptionKeys::score::eval_intrares_elec_ST_only, "Intrares elec only for free DOF atoms in Ser/Thr" ).def(false);
option.add( basic::options::OptionKeys::score::smooth_fa_elec, "Smooth the discontinuities in the elec energy function using a sigmoidal term" ).def(true);
option.add( basic::options::OptionKeys::score::grpelec_fade_type, "use standard way (shift/switch function) of Coulomb function for fa_grpelec" ).def("false");
option.add( basic::options::OptionKeys::score::grpelec_fade_param1, "fading distance for shift/switch" ).def(1.0);
option.add( basic::options::OptionKeys::score::grpelec_fade_param2, "exponent for shift" ).def(1.0);
option.add( basic::options::OptionKeys::score::elec_group_file, "file where group information is stored" ).def("/scoring/score_functions/elec_group_def.dat");
option.add( basic::options::OptionKeys::score::elec_group_extrafile, "file where group information for extra_res is stored" ).def("");

}
inline void add_rosetta_options_2( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::score::grpelec_fade_hbond, "fade grpelec for hbonding group" ).def(false);
option.add( basic::options::OptionKeys::score::grpelec_max_qeps, "Max abs charge for the group types, used when fading hbond [nonpolar/polar/charged]" ).def(0).def(0.10).def(0.25).def(0.5);
option.add( basic::options::OptionKeys::score::grpelec_context_dependent, "whether grpelec depends on context" ).def(false);
option.add( basic::options::OptionKeys::score::grp_cpfxn, "rule for trying cpfxn on group" ).def(true);
option.add( basic::options::OptionKeys::score::grpelec_cpfxn_weight, "cpfxn weight on group(1-4/1-5/>1-5)" ).def(0.0).def(0.2).def(1.0);
option.add( basic::options::OptionKeys::score::elec_context_minstrength, "strength at min burial " ).def(0.2);
option.add( basic::options::OptionKeys::score::elec_context_minburial, "num. cb assigned as min burial " ).def(7.0);
option.add( basic::options::OptionKeys::score::elec_context_maxburial, "num. cb assigned as max burial" ).def(24.0);
option.add( basic::options::OptionKeys::score::use_polarization, "whether multipole electrostatics includes polarization (induced dipoles)" ).def(true);
option.add( basic::options::OptionKeys::score::use_gen_kirkwood, "whether multipole electrostatics includes treatment of reaction field" ).def(true);
option.add( basic::options::OptionKeys::score::protein_dielectric, "dielectric constant for protein in generalized Kirkwood treatment of reaction field" ).def(1.0);
option.add( basic::options::OptionKeys::score::water_dielectric, "dielectric constant for water in generalized Kirkwood treatment of reaction field" ).def(78.3);
option.add( basic::options::OptionKeys::score::facts_GBpair_cut, "GBpair interaction distance cutoff (same as elec_max_dis)" ).def(10.0);
option.add( basic::options::OptionKeys::score::facts_kappa, "GBpair interaction screening factor" ).def(12.0);
option.add( basic::options::OptionKeys::score::facts_asp_patch, "AtomicSolvationParameter set for nonpolar interaction in FACTS" ).def(3);
option.add( basic::options::OptionKeys::score::facts_plane_to_self, "Add atoms in same plane to self energy pairs" ).def(true);
option.add( basic::options::OptionKeys::score::facts_saltbridge_correction, "FACTS Self energy parameter scaling factor for polarH" ).def(1.0);
option.add( basic::options::OptionKeys::score::facts_dshift, "FACTS pair term denominator distance shift[bb/bbsc/scsc/saltbridge]" ).def(0.0).def(1.5).def(1.5).def(1.5);
option.add( basic::options::OptionKeys::score::facts_die, "FACTS dielectric constant" ).def(1.0);
option.add( basic::options::OptionKeys::score::facts_binding_affinity, "Activate FACTS options for binding affinity calculation" ).def(false);
option.add( basic::options::OptionKeys::score::facts_intrascale_by_level, "Apply internal scaling by path_dist to CA? (definition below becomes G/D/E/Z/>Z" ).def(false);
option.add( basic::options::OptionKeys::score::facts_intbb_elec_scale, "FACTS Coulomb scale for intrares bonded pairs: [1-4, 1-5, >1-5]" ).def(0.0).def(0.2).def(0.0);
option.add( basic::options::OptionKeys::score::facts_intbb_solv_scale, "FACTS GB scale for intrares bb-bb bonded pairs: [1-4, 1-5, >1-5]" ).def(0.4).def(0.4).def(0.0);
option.add( basic::options::OptionKeys::score::facts_adjbb_elec_scale, "FACTS Coulomb scale for adjacent bb-bb bonded pairs: [1-4, 1-5, 1-6, 2res-coupled, 1res-decoupled]" ).def(0.0).def(0.2).def(1.0).def(0.5).def(0.5);
option.add( basic::options::OptionKeys::score::facts_adjbb_solv_scale, "FACTS GB scale for adjacent bb-bb bonded pairs: [1-4, 1-5, 1-6, 2res-coupled, 1res-decoupled]" ).def(0.0).def(0.2).def(1.0).def(0.5).def(0.5);
option.add( basic::options::OptionKeys::score::facts_intbs_elec_scale, "FACTS Coulomb scale for intrares bb-sc bonded pairs: [1-4, 1-5, 1-6, >1-6, dumm]" ).def(0.2).def(0.2).def(0.2).def(0.2).def(0.0);
option.add( basic::options::OptionKeys::score::facts_intbs_solv_scale, "FACTS GB scale for intrares bb-sc bonded pairs: [1-4, 1-5, 1-6, >1-6, dumm]" ).def(1.0).def(0.6).def(0.6).def(0.6).def(0.0);
option.add( basic::options::OptionKeys::score::facts_adjbs_elec_scale, "FACTS Coulomb scale for adjacent bb-sc bonded pairs: [1-4, 1-5, 1-6, 1-7, >1-7]" ).def(0.0).def(0.2).def(0.2).def(0.2).def(0.2);
option.add( basic::options::OptionKeys::score::facts_adjbs_solv_scale, "FACTS GB scale for adjacent bb-sc bonded pairs: [1-4, 1-5, 1-6, 1-7, >1-7]" ).def(1.0).def(0.6).def(0.6).def(0.6).def(0.6);
option.add( basic::options::OptionKeys::score::facts_intsc_elec_scale, "FACTS Coulomb scale for intrares sc-sc pairs: [1-4, 1-5, >1-5]" ).def(0.0).def(0.0).def(0.0);
option.add( basic::options::OptionKeys::score::facts_intsc_solv_scale, "FACTS GB scale for intrares sc-sc pairs: [1-4, 1-5, >1-5]" ).def(1.0).def(0.0).def(0.0);
option.add( basic::options::OptionKeys::score::facts_charge_dir, "directory where residue topology files for FACTS charge are stored" ).def("scoring/score_functions/facts");
option.add( basic::options::OptionKeys::score::facts_eff_charge_dir, "directory where residue topology files for FACTS charge are stored" ).def("scoring/score_functions/facts/eff");
option.add( basic::options::OptionKeys::score::facts_plane_aa, "AAs to apply plane rule" );
option.add( basic::options::OptionKeys::score::facts_eq_type, "FACTS equation type" ).def("exact");
option.add( basic::options::OptionKeys::score::ignore_terminal_ss_elements, "number of secondary structure elements to be ignored" ).def(0);
option.add( basic::options::OptionKeys::score::length_dep_srbb, "Enable helix-length-dependent sr backbone hbonds" ).def(false);
option.add( basic::options::OptionKeys::score::ldsrbb_low_scale, "Helix-length-dependent scaling at minlength." ).def(0.5);
option.add( basic::options::OptionKeys::score::ldsrbb_high_scale, "Helix-length-dependent scaling at maxlength." ).def(2.0);
option.add( basic::options::OptionKeys::score::ldsrbb_minlength, "Helix-length-dependent scaling minlength." ).def(4);
option.add( basic::options::OptionKeys::score::ldsrbb_maxlength, "Helix-length-dependent scaling maxlength." ).def(17);
option.add( basic::options::OptionKeys::score::max_motif_per_res, "maximum value for motifs" ).def(3.0);
option.add( basic::options::OptionKeys::score::max_contacting_ss, "maximum number of interconnecting SS" ).def(4);
option.add( basic::options::OptionKeys::score::motif_ignore_symmmetry, "only counts motifs inside monomer" ).def(true);
option.add( basic::options::OptionKeys::score::motif_residues, "which residue numbers to calculate motifs" );
option.add( basic::options::OptionKeys::score::nmer_ref_energies, "nmer ref energies database filename" );
option.add( basic::options::OptionKeys::score::nmer_ref_energies_list, "list of nmer ref energies database filenames" );
option.add( basic::options::OptionKeys::score::nmer_pssm, "nmer pssm database filename" );
option.add( basic::options::OptionKeys::score::nmer_pssm_list, "list of nmer pssm database filenames" );
option.add( basic::options::OptionKeys::score::nmer_pssm_scorecut, "nmer pssm scorecut gate for ignoring lowscore nmers" ).def(0.0);
option.add( basic::options::OptionKeys::score::nmer_svm, "nmer svm filename (libsvm)" );
option.add( basic::options::OptionKeys::score::nmer_svm_list, "list of nmer svm filenames (libsvm)" );
option.add( basic::options::OptionKeys::score::nmer_svm_scorecut, "nmer svm scorecut gate for ignoring lowscore nmers" ).def(0.0);
option.add( basic::options::OptionKeys::score::nmer_svm_aa_matrix, "nmer svm sequence encoding matrix filename" );
option.add( basic::options::OptionKeys::score::nmer_svm_term_length, "how many up/dnstream res to avg and incl in svm sequence encoding" ).def(3);
option.add( basic::options::OptionKeys::score::nmer_svm_pssm_feat, "add pssm features to svm encoding?" ).def(true);
option.add( basic::options::OptionKeys::score::nmer_ref_seq_length, "length of nmers in nmer_ref score" ).def(9);
option.add( basic::options::OptionKeys::score::just_calc_rmsd, "In rna_score, just calculate rmsd -- do not replace score." ).def(false);
option.add( basic::options::OptionKeys::score::envsmooth_zero_negatives, "use alternative envsmooth table with a floor of 0.0 (envsmooth awards no energy bonus)" ).def(false);
option.add( basic::options::OptionKeys::score::rama_power, "If rama > 0.0, raise to the nth power.  This has been useful for Foldit design.  Note that this creates derivative discontinuities, so it should be used with caution!  If not specified, the default rama behaviour (no power function) is preserved." ).def(1.0);
option.add( basic::options::OptionKeys::score::hbond_fade, "fade_factor for hbond geometry softmax" ).def(2.5);
option.add( basic::options::OptionKeys::score::hbond_new_sp3_acc, "fade_factor for hbond geometry softmax" ).def(false);
option.add( basic::options::OptionKeys::score::saxs::saxs, "saxs option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::score::saxs::min_score, "minimum value of saxs score; the parameter is used to flatten the energy funnel around its minimum" ).def(-5);
option.add( basic::options::OptionKeys::score::saxs::custom_ff, "Name of config file providing extra from factors" ).def("");
option.add( basic::options::OptionKeys::score::saxs::print_i_calc, "File to optionally write scaled computed spectra" ).def("");
option.add( basic::options::OptionKeys::score::saxs::ref_fa_spectrum, "reads reference full-atom spectrum from a file" );
option.add( basic::options::OptionKeys::score::saxs::ref_cen_spectrum, "reads reference centroid spectrum from a file" );
option.add( basic::options::OptionKeys::score::saxs::ref_spectrum, "reads reference spectrum from a file" );
option.add( basic::options::OptionKeys::score::saxs::ref_pddf, "reads reference pairwise distance distribution function" );
option.add( basic::options::OptionKeys::score::saxs::d_min, "minimum value of distance used in PDDF score evaluation (in [A])" ).def(5.0);
option.add( basic::options::OptionKeys::score::saxs::d_max, "maximum value of distance used in PDDF score evaluation (in [A])" ).def(100.0);
option.add( basic::options::OptionKeys::score::saxs::d_step, "step of distance used in PDDF score evaluation (in [A])" ).def(0.1);
option.add( basic::options::OptionKeys::score::saxs::q_min, "minimum value of q used in spectra calculations (in [A^-1])" ).def(0.01);
option.add( basic::options::OptionKeys::score::saxs::q_max, "maximum value of q used in spectra calculations (in [A^-1])" ).def(0.25);
option.add( basic::options::OptionKeys::score::saxs::q_step, "step of q used in spectra calculations (in [A^-1])" ).def(0.01);
option.add( basic::options::OptionKeys::score::saxs::fit_pddf_area, "PDDF curve for a scored pose will be normalized to match the area under the reference PDDF curve" ).def(false);
option.add( basic::options::OptionKeys::score::fiber_diffraction::fiber_diffraction, "fiber_diffraction option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::score::fiber_diffraction::layer_lines, "reads layer_lines from a file" );
option.add( basic::options::OptionKeys::score::fiber_diffraction::a, "number of subunits per repeat" ).def(0);
option.add( basic::options::OptionKeys::score::fiber_diffraction::b, "number of turns per repeat" ).def(0);
option.add( basic::options::OptionKeys::score::fiber_diffraction::p, "subunit rise" ).def(0);
option.add( basic::options::OptionKeys::score::fiber_diffraction::radius, "helical radius" ).def(0);
option.add( basic::options::OptionKeys::score::fiber_diffraction::resolution_cutoff_low, "ignore intensity data below this point" ).def(0.05);
option.add( basic::options::OptionKeys::score::fiber_diffraction::resolution_cutoff_high, "ignore intensity data above this point" ).def(0.5);
option.add( basic::options::OptionKeys::score::fiber_diffraction::max_bessel_order, "maximum number of bessel orders used in simulations" ).def(50);
option.add( basic::options::OptionKeys::score::fiber_diffraction::cn_symmetry, "cn symmetry at one z level (along fibrilar axis)" ).def(0);
option.add( basic::options::OptionKeys::score::fiber_diffraction::b_factor, "b_factor value" ).def(20);
option.add( basic::options::OptionKeys::score::fiber_diffraction::b_factor_solv, "b_factor_solv value" ).def(400);
option.add( basic::options::OptionKeys::score::fiber_diffraction::b_factor_solv_K, "b_factor_solv_K value" ).def(0.4);
option.add( basic::options::OptionKeys::score::fiber_diffraction::grid_reso, "resolution for density sampling on the grid" ).def(0.5);
option.add( basic::options::OptionKeys::score::fiber_diffraction::grid_r, "number of grid points along r" ).def(256);
option.add( basic::options::OptionKeys::score::fiber_diffraction::grid_phi, "number of grid points along phi" ).def(128);
option.add( basic::options::OptionKeys::score::fiber_diffraction::grid_z, "number of grid points along z" ).def(256);
option.add( basic::options::OptionKeys::score::fiber_diffraction::qfht_K1, "value of K1 for Hankel sampling" ).def(2.0);
option.add( basic::options::OptionKeys::score::fiber_diffraction::qfht_K2, "value of K2 for Hankel sampling" ).def(2.2);
option.add( basic::options::OptionKeys::score::fiber_diffraction::chi_iterations, "number of iterations to calculate chi e.g. number of layer lines" ).def(0);
option.add( basic::options::OptionKeys::score::fiber_diffraction::rfactor_refinement, "R-factor refinement" ).def(false);
option.add( basic::options::OptionKeys::score::fiber_diffraction::output_fiber_spectra, "Output intensity, reciprocal R, layer line" ).def(false);
option.add( basic::options::OptionKeys::score::fiber_diffraction::gpu_processor, "GPU processor number - for systems with more than 1" ).def(0);
option.add( basic::options::OptionKeys::score::fiber_diffraction::centroid_density_mass, "density mass of centroid" ).def(0.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::occ_sol_fitted, "occ_sol_fitted option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::Ntrp_amp_scaling, "scaling factor for Ntrp atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::NH2O_amp_scaling, "scaling factor for NH2O atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::Nlys_amp_scaling, "scaling factor for Nlys atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::Narg_amp_scaling, "scaling factor for Narg atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::Nbb_amp_scaling, "scaling factor for Nbb atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::Nhis_amp_scaling, "scaling factor for Nhis atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::OH_amp_scaling, "scaling factor for OH atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::ONH2_amp_scaling, "scaling factor for ONH2 atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::OOC_amp_scaling, "scaling factor for OOC atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::Oaro_amp_scaling, "scaling factor for Oaro atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::Oet2_amp_scaling, "scaling factor for Oet2 atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::Oet3_amp_scaling, "scaling factor for Oet3 atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::OCbb_amp_scaling, "scaling factor for OCbb atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::HOH_amp_scaling, "scaling factor for HOH atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::OPha_amp_scaling, "scaling factor for OPha atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::OHha_amp_scaling, "scaling factor for OHha atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::OC3_amp_scaling, "scaling factor for OC3 atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::OSi_amp_scaling, "scaling factor for OSi atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::occ_sol_fitted::Oice_amp_scaling, "scaling factor for Oice atoms's amplitude of the gaussian" ).def(1.0);
option.add( basic::options::OptionKeys::score::loop_close::loop_close, "loop_close option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::score::loop_close::loop_fixed_cost, "For loop_close term, a fixed cost of instantiating an end of a Gaussian chain; calibrated based on RNA bulge/loop data" ).def(-0.29);
option.add( basic::options::OptionKeys::score::loop_close::allow_complex_loop_graph, "LoopGraph hack - allow sharing of loops between cycles" ).def(false);
option.add( basic::options::OptionKeys::score::loop_close::use_6D_potential, "for implicit modeling of RNA loops, use 6D potentials instead of simple 1D Gaussian chain model" ).def(false);
option.add( basic::options::OptionKeys::score::loop_close::force_6D_potential_file, "use this 6D potential for all loop_close instead of database files (for testing only!)" ).def("");
option.add( basic::options::OptionKeys::packing::packing, "Packing option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::packing::repack_only, "Disable design at all positions" ).def(false);
option.add( basic::options::OptionKeys::packing::prevent_repacking, "Disable repacking (or design) at all positions" ).def(false);
option.add( basic::options::OptionKeys::packing::cenrot_cutoff, "Cutoff to generate centroid rotamers" ).def(0.16);
option.add( basic::options::OptionKeys::packing::ignore_ligand_chi, "Disable param file chi-angle based rotamer generation in SingleLigandRotamerLibrary" ).def(false);
option.add( basic::options::OptionKeys::packing::quasisymmetry, "Turn on quasisymmetric packing using when using RotamerLinks" ).def(false);
option.add( basic::options::OptionKeys::packing::ndruns, "Number of fixbb packing iterations.  Each time packing occurs, it will pack this many times and return only the best result.  Implemented at level of PackRotamersMover." ).lower(1).def(1);
option.add( basic::options::OptionKeys::packing::soft_rep_design, "Use larger LJ radii for softer potential" );
option.add( basic::options::OptionKeys::packing::mainchain_h_rebuild_threshold, "Cutoff for rebuilding mainchain hydrogens during rotamer generation during packing.  If the position of the hydrogen is less than the threshold from its ideal position, it is not rebuilt.  Default 0.75 A." ).def(0.75);
option.add( basic::options::OptionKeys::packing::use_electrostatic_repulsion, "Use electrostatic repulsion" );
option.add( basic::options::OptionKeys::packing::dump_rotamer_sets, "Output NMR-style PDB's with the rotamer sets used during packing" );
option.add( basic::options::OptionKeys::packing::dunbrack_prob_buried, "fraction of possible dunbrack rotamers to include in each single residue rotamer set, for 'buried' residues" ).lower(0).upper(1).def(0.98);
option.add( basic::options::OptionKeys::packing::dunbrack_prob_nonburied, "fraction of possible dunbrack rotamers to include in each single residue rotamer set, for 'nonburied' residues" ).lower(0).upper(1).def(0.95);
option.add( basic::options::OptionKeys::packing::no_optH, "Do not optimize hydrogen placement at the time of a PDB load" ).def(true);
option.add( basic::options::OptionKeys::packing::optH_MCA, "If running optH, use the Multi-Cool Annealer (more consistent, but slower)" ).def(false);
option.add( basic::options::OptionKeys::packing::pack_missing_sidechains, "Run packer to fix residues with missing sidechain density at PDB load" ).def(true);
option.add( basic::options::OptionKeys::packing::preserve_c_beta, "Preserve c-beta positions during rotamer construction" );
option.add( basic::options::OptionKeys::packing::flip_HNQ, "Consider flipping HIS, ASN, and GLN during hydrogen placement optimization" );
option.add( basic::options::OptionKeys::packing::fix_his_tautomer, "seqpos numbers of his residus whose tautomer should be fixed during repacking" ).def();
option.add( basic::options::OptionKeys::packing::print_pymol_selection, "include pymol-style selections when printing a PackerTask" ).def(false);
option.add( basic::options::OptionKeys::packing::extrachi_cutoff, "number of neighbors a residue must have before extra rotamers are used. default: 18" ).def(18);
option.add( basic::options::OptionKeys::packing::resfile, "resfile filename(s).  Most protocols use only the first and will ignore the rest; it does not track against -s or -l automatically." ).def("resfile");
option.add( basic::options::OptionKeys::packing::outeriterations_scaling, "Multiplier for number of outer iterations" ).def(1.0);
option.add( basic::options::OptionKeys::packing::inneriterations_scaling, "Multiplier for number of inner iterations" ).def(1.0);
option.add( basic::options::OptionKeys::packing::adducts, "Gives list of adduct names to generate for residue 			definitions.  Each adduct name may be followed by an 			optional integer, which gives a maximum number of adducts 			of that type which will be generated." );
option.add( basic::options::OptionKeys::packing::use_input_sc, "Use rotamers from input structure in packing 			By default, input sidechain coords are NOT 			included in rotamer set but are discarded 			before the initial pack; with this flag, the 			the input rotamers will NOT be discarded. 			Note that once the starting rotamers are 			replaced by any mechanism, they are no longer 			included in the rotamer set 			(rotamers included by coordinates)" );
option.add( basic::options::OptionKeys::packing::unboundrot, "Read 'native' rotamers from supplied PDB(s).  			Unlike -use_input_sc, these rotamers will not be lost during repacks.  			This option requires specific support from the protocol;  			it is NOT built in to PackerTask.initialize_from_command_line()" );
option.add( basic::options::OptionKeys::packing::max_rotbump_energy, "discard rotamers with poor interactions with the background using  				the specified cutoff.  Values must be in the range of 0 to 5.0." ).def(5.0);
option.add( basic::options::OptionKeys::packing::lazy_ig, "Force the packer to always allocate pair energy storage but procrastinate 				energy caclulation until each RPE is needed; each RPE is 				computed at most once. Memory use is quadratic in rotamers per residue. 				The InteractionGraphFactory will prefer the linear-memory interaction graph 				to the Lazy Interaction graph, so specifying both linmem_ig and lazy_ig results 				in the use of the linear-memory interaction graph.  The Surface-series IGs 				(surface weight in scorefunction is nonzero) also overrides this IG." ).def(false);
option.add( basic::options::OptionKeys::packing::double_lazy_ig, "Force the packer to always procrastinate allocation AND energy caclulation 				until each RPE is needed; each RPE is computed at most once. 				The InteractionGraphFactory will prefer the linear-memory interaction graph 				to the DoubleLazy Interaction graph, so specifying both linmem_ig and lazy_ig results 				in the use of the linear-memory interaction graph.  The Surface-series IGs (surface 				weight in scorefunction is nonzero) also overrides this IG." ).def(false);
option.add( basic::options::OptionKeys::packing::linmem_ig, "Force the packer to use the linear memory interaction graph; each 				RPE may be computed more than once, but recently-computed RPEs 				are reused.  The integer parameter specifies the number 				of recent rotamers to store RPEs for.  10 is the recommended size. 				Memory use scales linearly with the number of 				rotamers at about 200 bytes per rotamer per recent rotamers to 				store RPEs for (~4 KB per rotamer by default)" ).def(10);
option.add( basic::options::OptionKeys::packing::multi_cool_annealer, "Alternate annealer for packing.  Runs multiple quence cycles in a first cooling stage, and tracks 			the N best network states it observes.  It then runs low-temperature rotamer substitutions with repeated 			quenching starting from each of these N best network states.  10 is recommended." );
option.add( basic::options::OptionKeys::packing::minpack_temp_schedule, "Alternate annealing schedule for min_pack." );
option.add( basic::options::OptionKeys::packing::minpack_inner_iteration_scale, "The number of inner iterations per rotamer to run at each temperature in min pack." );
option.add( basic::options::OptionKeys::packing::minpack_disable_bumpcheck, "Disable bump check in min pack (i.e. include rotamers that collide with the background." );
option.add( basic::options::OptionKeys::packing::ex1::ex1, "use extra chi1 sub-rotamers for all residues that pass the extrachi_cutoff" ).is_group(true);
option.add( basic::options::OptionKeys::packing::ex1::level, "use extra chi1 sub-rotamers for all residues that pass the extrachi_cutoff The integers that follow the ex flags specify the pattern for chi dihedral angle sampling There are currently 8 options; they all include the original chi dihedral angle. NO_EXTRA_CHI_SAMPLES          0          original dihedral only; same as using no flag at all EX_ONE_STDDEV                 1 Default  +/- one standard deviation (sd); 3 samples EX_ONE_HALF_STEP_STDDEV       2          +/- 0.5 sd; 3 samples EX_TWO_FULL_STEP_STDDEVS      3          +/- 1 & 2 sd; 5 samples EX_TWO_HALF_STEP_STDDEVS      4          +/- 0.5 & 1 sd; 5 samples EX_FOUR_HALF_STEP_STDDEVS     5          +/- 0.5, 1, 1.5 & 2 sd; 9 samples EX_THREE_THIRD_STEP_STDDEVS   6          +/- 0.33, 0.67, 1 sd; 7 samples EX_SIX_QUARTER_STEP_STDDEVS   7          +/- 0.25, 0.5, 0.75, 1, 1.25 & 1.5 sd; 13 samples" ).legal(0).legal(1).legal(2).legal(3).legal(4).legal(5).legal(6).legal(7).def(1);
option.add( basic::options::OptionKeys::packing::ex1::operate, "apply special operations (see RotamerOperation class) on ex1 rotamers" );
option.add( basic::options::OptionKeys::packing::ex2::ex2, "use extra chi2 sub-rotamers for all residues that pass the extrachi_cutoff" ).is_group(true);
option.add( basic::options::OptionKeys::packing::ex2::level, "use extra chi2 sub-rotamers for all residues that pass the extrachi_cutoff The integers that follow the ex flags specify the pattern for chi dihedral angle sampling There are currently 8 options; they all include the original chi dihedral angle. NO_EXTRA_CHI_SAMPLES          0          original dihedral only; same as using no flag at all EX_ONE_STDDEV                 1 Default  +/- one standard deviation (sd); 3 samples EX_ONE_HALF_STEP_STDDEV       2          +/- 0.5 sd; 3 samples EX_TWO_FULL_STEP_STDDEVS      3          +/- 1 & 2 sd; 5 samples EX_TWO_HALF_STEP_STDDEVS      4          +/- 0.5 & 1 sd; 5 samples EX_FOUR_HALF_STEP_STDDEVS     5          +/- 0.5, 1, 1.5 & 2 sd; 9 samples EX_THREE_THIRD_STEP_STDDEVS   6          +/- 0.33, 0.67, 1 sd; 7 samples EX_SIX_QUARTER_STEP_STDDEVS   7          +/- 0.25, 0.5, 0.75, 1, 1.25 & 1.5 sd; 13 samples" ).legal(0).legal(1).legal(2).legal(3).legal(4).legal(5).legal(6).legal(7).def(1);
option.add( basic::options::OptionKeys::packing::ex2::operate, "apply special operations (see RotamerOperation class) on ex2 rotamers" );
option.add( basic::options::OptionKeys::packing::ex3::ex3, "use extra chi1 sub-rotamers for all residues that pass the extrachi_cutoff" ).is_group(true);
option.add( basic::options::OptionKeys::packing::ex3::level, "use extra chi3 sub-rotamers for all residues that pass the extrachi_cutoff The integers that follow the ex flags specify the pattern for chi dihedral angle sampling There are currently 8 options; they all include the original chi dihedral angle. NO_EXTRA_CHI_SAMPLES          0          original dihedral only; same as using no flag at all EX_ONE_STDDEV                 1 Default  +/- one standard deviation (sd); 3 samples EX_ONE_HALF_STEP_STDDEV       2          +/- 0.5 sd; 3 samples EX_TWO_FULL_STEP_STDDEVS      3          +/- 1 & 2 sd; 5 samples EX_TWO_HALF_STEP_STDDEVS      4          +/- 0.5 & 1 sd; 5 samples EX_FOUR_HALF_STEP_STDDEVS     5          +/- 0.5, 1, 1.5 & 2 sd; 9 samples EX_THREE_THIRD_STEP_STDDEVS   6          +/- 0.33, 0.67, 1 sd; 7 samples EX_SIX_QUARTER_STEP_STDDEVS   7          +/- 0.25, 0.5, 0.75, 1, 1.25 & 1.5 sd; 13 samples" ).legal(0).legal(1).legal(2).legal(3).legal(4).legal(5).legal(6).legal(7).def(1);
option.add( basic::options::OptionKeys::packing::ex3::operate, "apply special operations (see RotamerOperation class) on ex3 rotamers" );
option.add( basic::options::OptionKeys::packing::ex4::ex4, "use extra chi1 sub-rotamers for all residues that pass the extrachi_cutoff" ).is_group(true);
option.add( basic::options::OptionKeys::packing::ex4::level, "use extra chi4 sub-rotamers for all residues that pass the extrachi_cutoff The integers that follow the ex flags specify the pattern for chi dihedral angle sampling There are currently 8 options; they all include the original chi dihedral angle. NO_EXTRA_CHI_SAMPLES          0          original dihedral only; same as using no flag at all EX_ONE_STDDEV                 1 Default  +/- one standard deviation (sd); 3 samples EX_ONE_HALF_STEP_STDDEV       2          +/- 0.5 sd; 3 samples EX_TWO_FULL_STEP_STDDEVS      3          +/- 1 & 2 sd; 5 samples EX_TWO_HALF_STEP_STDDEVS      4          +/- 0.5 & 1 sd; 5 samples EX_FOUR_HALF_STEP_STDDEVS     5          +/- 0.5, 1, 1.5 & 2 sd; 9 samples EX_THREE_THIRD_STEP_STDDEVS   6          +/- 0.33, 0.67, 1 sd; 7 samples EX_SIX_QUARTER_STEP_STDDEVS   7          +/- 0.25, 0.5, 0.75, 1, 1.25 & 1.5 sd; 13 samples" ).legal(0).legal(1).legal(2).legal(3).legal(4).legal(5).legal(6).legal(7).def(1);
option.add( basic::options::OptionKeys::packing::ex4::operate, "apply special operations (see RotamerOperation class) on ex4 rotamers" );
option.add( basic::options::OptionKeys::packing::ex1aro::ex1aro, "use extra chi1 sub-rotamers for aromatic residues that pass the extrachi_cutoff" ).is_group(true);
option.add( basic::options::OptionKeys::packing::ex1aro::level, "use extra chi1 sub-rotamers for all residues that pass the extrachi_cutoff The integers that follow the ex flags specify the pattern for chi dihedral angle sampling There are currently 8 options; they all include the original chi dihedral angle. NO_EXTRA_CHI_SAMPLES          0          original dihedral only; same as using no flag at all EX_ONE_STDDEV                 1 Default  +/- one standard deviation (sd); 3 samples EX_ONE_HALF_STEP_STDDEV       2          +/- 0.5 sd; 3 samples EX_TWO_FULL_STEP_STDDEVS      3          +/- 1 & 2 sd; 5 samples EX_TWO_HALF_STEP_STDDEVS      4          +/- 0.5 & 1 sd; 5 samples EX_FOUR_HALF_STEP_STDDEVS     5          +/- 0.5, 1, 1.5 & 2 sd; 9 samples EX_THREE_THIRD_STEP_STDDEVS   6          +/- 0.33, 0.67, 1 sd; 7 samples EX_SIX_QUARTER_STEP_STDDEVS   7          +/- 0.25, 0.5, 0.75, 1, 1.25 & 1.5 sd; 13 samples" ).legal(0).legal(1).legal(2).legal(3).legal(4).legal(5).legal(6).legal(7).def(1);
option.add( basic::options::OptionKeys::packing::ex2aro::ex2aro, "use extra chi1 sub-rotamers for aromatic residues that pass the extrachi_cutoff" ).is_group(true);
option.add( basic::options::OptionKeys::packing::ex2aro::level, "use extra chi2 sub-rotamers for all residues that pass the extrachi_cutoff The integers that follow the ex flags specify the pattern for chi dihedral angle sampling There are currently 8 options; they all include the original chi dihedral angle. NO_EXTRA_CHI_SAMPLES          0          original dihedral only; same as using no flag at all EX_ONE_STDDEV                 1 Default  +/- one standard deviation (sd); 3 samples EX_ONE_HALF_STEP_STDDEV       2          +/- 0.5 sd; 3 samples EX_TWO_FULL_STEP_STDDEVS      3          +/- 1 & 2 sd; 5 samples EX_TWO_HALF_STEP_STDDEVS      4          +/- 0.5 & 1 sd; 5 samples EX_FOUR_HALF_STEP_STDDEVS     5          +/- 0.5, 1, 1.5 & 2 sd; 9 samples EX_THREE_THIRD_STEP_STDDEVS   6          +/- 0.33, 0.67, 1 sd; 7 samples EX_SIX_QUARTER_STEP_STDDEVS   7          +/- 0.25, 0.5, 0.75, 1, 1.25 & 1.5 sd; 13 samples" ).legal(0).legal(1).legal(2).legal(3).legal(4).legal(5).legal(6).legal(7).def(1);
option.add( basic::options::OptionKeys::packing::ex1aro_exposed::ex1aro_exposed, "use extra chi1 sub-rotamers for all aromatic residues" ).is_group(true);
option.add( basic::options::OptionKeys::packing::ex1aro_exposed::level, "use extra chi1 sub-rotamers for all aromatic residues The integers that follow the ex flags specify the pattern for chi dihedral angle sampling There are currently 8 options; they all include the original chi dihedral angle. NO_EXTRA_CHI_SAMPLES          0          original dihedral only; same as using no flag at all EX_ONE_STDDEV                 1 Default  +/- one standard deviation (sd); 3 samples EX_ONE_HALF_STEP_STDDEV       2          +/- 0.5 sd; 3 samples EX_TWO_FULL_STEP_STDDEVS      3          +/- 1 & 2 sd; 5 samples EX_TWO_HALF_STEP_STDDEVS      4          +/- 0.5 & 1 sd; 5 samples EX_FOUR_HALF_STEP_STDDEVS     5          +/- 0.5, 1, 1.5 & 2 sd; 9 samples EX_THREE_THIRD_STEP_STDDEVS   6          +/- 0.33, 0.67, 1 sd; 7 samples EX_SIX_QUARTER_STEP_STDDEVS   7          +/- 0.25, 0.5, 0.75, 1, 1.25 & 1.5 sd; 13 samples" ).legal(0).legal(1).legal(2).legal(3).legal(4).legal(5).legal(6).legal(7).def(1);
option.add( basic::options::OptionKeys::packing::ex2aro_exposed::ex2aro_exposed, "use extra chi2 sub-rotamers for all aromatic residues" ).is_group(true);
option.add( basic::options::OptionKeys::packing::ex2aro_exposed::level, "use extra chi2 sub-rotamers for all aromatic residues The integers that follow the ex flags specify the pattern for chi dihedral angle sampling There are currently 8 options; they all include the original chi dihedral angle. NO_EXTRA_CHI_SAMPLES          0          original dihedral only; same as using no flag at all EX_ONE_STDDEV                 1 Default  +/- one standard deviation (sd); 3 samples EX_ONE_HALF_STEP_STDDEV       2          +/- 0.5 sd; 3 samples EX_TWO_FULL_STEP_STDDEVS      3          +/- 1 & 2 sd; 5 samples EX_TWO_HALF_STEP_STDDEVS      4          +/- 0.5 & 1 sd; 5 samples EX_FOUR_HALF_STEP_STDDEVS     5          +/- 0.5, 1, 1.5 & 2 sd; 9 samples EX_THREE_THIRD_STEP_STDDEVS   6          +/- 0.33, 0.67, 1 sd; 7 samples EX_SIX_QUARTER_STEP_STDDEVS   7          +/- 0.25, 0.5, 0.75, 1, 1.25 & 1.5 sd; 13 samples" ).legal(0).legal(1).legal(2).legal(3).legal(4).legal(5).legal(6).legal(7).def(1);
option.add( basic::options::OptionKeys::packing::exdna::exdna, "use extra dna rotamers" ).is_group(true);
option.add( basic::options::OptionKeys::packing::exdna::level, "extra dna rotamer sample level -- rotbuilder converts from 0-7 to number" ).legal(0).legal(1).legal(2).legal(3).legal(4).legal(5).legal(6).legal(7).def(1);
option.add( basic::options::OptionKeys::archive::archive, "archive option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::archive::reread_all_structures, "ignore pool file... reread from batches" ).def(false);
option.add( basic::options::OptionKeys::archive::completion_notify_frequency, "tell Archive every X completed decoys" ).def(100);
option.add( basic::options::OptionKeys::carbohydrates::carbohydrates, "carbohydrates option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::carbohydrates::glycam_pdb_format, "Indicates that the input PDB files were generated by GLYCAM and thus join any HO- or RO- \"residues\" to the following one since Rosetta is smart enough to patch reducing ends.  The default value is false." ).shortd( "Was this input file generated by GLYCAM?" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::carbohydrates::linkage_conformer_data_file, "Specify the file where glycosidic linkage conformer torsion angle statistical data is stored.  The default directory is database/chemical/carbohydrates/linkage_conformers/but any path can be provided.  The default filename is default.table" ).shortd( "Specify a file containing glycosidic linkage data." ).def("default.table");
option.add( basic::options::OptionKeys::carbohydrates::glycan_relax::glycan_relax, "glycan_relax option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::carbohydrates::glycan_relax::glycan_relax_test, "Indicates to go into testing mode for Glycan Relax.  Will try all torsions in a given PDB in a linear fashion" ).def(false);
option.add( basic::options::OptionKeys::carbohydrates::glycan_relax::glycan_relax_rounds, "Number of rounds to use for Glycan Relax. Total rounds is this # times number of glycan residues in movemap" ).def(25);
option.add( basic::options::OptionKeys::carbohydrates::glycan_relax::pack_glycans, "Pack Glycan OH groups during Glycan Relax. Currently time consuming" ).def(false);
option.add( basic::options::OptionKeys::carbohydrates::glycan_relax::final_min_glycans, "Do a final minimization of glycans after glycan relax protocol?" ).def(true);
option.add( basic::options::OptionKeys::carbohydrates::glycan_relax::glycan_relax_movie, "Make a movie of accepts and trials (send to pymol)" ).def(false);
option.add( basic::options::OptionKeys::carbohydrates::glycan_relax::glycan_relax_kt, "KT for GlycanRelaxMover" ).def(2.0);
option.add( basic::options::OptionKeys::carbohydrates::glycan_relax::glycan_relax_refine, "Set the protocol to not start from a random conformation, and instead refine the structure." ).def(false);
option.add( basic::options::OptionKeys::carbohydrates::glycan_relax::cartmin, "Use Cartesian-space minimization instead of dihedral" ).def(false);
option.add( basic::options::OptionKeys::carbohydrates::glycan_relax::tree_based_min_pack, "Use a random-tree based method to minimize and pack instead of minimizing and packing all of them during the randommover selection. This makes the speed of the algorithm mostly-linear with the addition of more glycans, and wastes less time packing and minimizing" ).def(true);
option.add( basic::options::OptionKeys::carbohydrates::clash_check::clash_check, "clash_check option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::carbohydrates::clash_check::glycan_branches, "Required. Vector of glycan branches.  Rosetta Residue numbering or PDB like RosettaScripts" );
option.add( basic::options::OptionKeys::carbohydrates::clash_check::check_chains, "Required. A list of chains to compute chain-based clashes.  If not given, will only compute glycan-glycan clashes!" );
option.add( basic::options::OptionKeys::carbohydrates::clash_check::soft_clash, "When we calculate atom-atom distances using VDW, clash if distance < (atomI_vdw + atomJ_vdw)*(1 - soft_clash)" ).def(0.33);
option.add( basic::options::OptionKeys::carbohydrates::clash_check::cb_clash_distance, "NOT CURRENTLY USED. Distance for CB distance clash check. Residue is clashing if at least 1 atom is less than this distance" );
option.add( basic::options::OptionKeys::carbohydrates::clash_check::ignore_hydrogens, "Should we calculate only heavy-heavy atom clashes?" ).def(false);
option.add( basic::options::OptionKeys::carbohydrates::clash_check::ignore_full_res_output, "Should we output each glycan residue clash information in scorefile?  Ignoring will make scorefile a bit smaller." ).def(false);
option.add( basic::options::OptionKeys::carbohydrates::clash_check::output_per_glycan_data, "Should we output per glycan branch data?  Easy to compute later on if full res output is on. " ).def(false);
option.add( basic::options::OptionKeys::rings::rings, "rings option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rings::lock_rings, "Sets whether or not alternative ring conformations will be sampled by the protocol, (e.g, ring flips or puckering).  Only low-energy conformers will be sampled, if known.  Otherwise, all ideal ring conformers will be sampled.  The default value is false." ).shortd( "Are rings allowed to flip or pucker?" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::rings::idealize_rings, "Sets whether or not the ring conformations of input poses are idealized (set to the lowest-energy ring conformer, according to the toplogy file for that residue).  The default is false: the input ring conformations will be used." ).shortd( "Are rings pre-set to low-energy conformations?" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::rings::sample_high_energy_conformers, "Sets whether or not even ring conformations that are energy energy maxima will be sampled by the protocol.  The default value is false; however, if the low energy ring conformers are not listed in the topology files, all ideal ring conformers will be sampled anyway." ).shortd( "Are rings allowed to flip or pucker?" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::chemical::chemical, "chemical option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::chemical::exclude_patches, "Names of the residue-type-set patches which should not be applied; if you know which patches you do not need for a particular run, this flag can reduce your memory use" );
option.add( basic::options::OptionKeys::chemical::include_patches, "Names of the residue-type-set patches which should be applied even if excluded/commented out in patches.txt; useful for testing non-default patches" );
option.add( basic::options::OptionKeys::chemical::add_atom_type_set_parameters, "Additional AtomTypeSet extra-parameter files that should be read; format is a sequence of paired strings: <atom-type-set-tag1> <filename1> <atom-type-set-tag2> <filename2> ..." );
option.add( basic::options::OptionKeys::chemical::set_atom_properties, "Modify atom properties (the ones in <atom-set>/atom_properties.txt) from the command line. Happens at time of AtomTypeSet creation inside ChemicalManager.cc. Format is: -chemical:set_atom_properties <atom-set1>:<atom_name1>:<param1>:<setting1> <atom-set2>:<atom2>:<param2>:<setting2> ... For example: '-chemical:set_atom_properties fa_standard:OOC:LK_DGFREE:-5 fa_standard:ONH2:LJ_RADIUS:0.5' " );
option.add( basic::options::OptionKeys::chemical::patch_selectors, "allow patch files that have CMDLINE_SELECTOR tags can be switched on with this option" ).def();
option.add( basic::options::OptionKeys::chemical::override_rsd_type_limit, "over-ride cap on number of residue types." ).def(false);
option.add( basic::options::OptionKeys::chemical::clone_atom_types, "Optionally clone atom types; copies all properties, which can then be diverged via -set_atom_properties. -clone_atom_types format should be:: -clone_atom_types <set1>:<atomname1>:<cloned-atomname1> <set2>:<atomname2>:<cloned-atomname2> ...; for example: '-chemical:clone_atom_types fa_standard:OOC:OOC2' " );
option.add( basic::options::OptionKeys::chemical::reassign_atom_types, "Switch the atomtype assignments for atoms in specified residue types. Useful along with -clone_atom_types. -reassign_atom_types format should be:: -reassign_atom_types <rsd-type-set1-name>:<rsd-type1-name>:<atom-type1-name>:<new-atom-type1-name>   <rsd-type-set2-name>:<rsd-type2-name>:<atom-type2-name>:<new-atom-type2-name> ...; for example: '-chemical:reassign_atom_types fa_standard:ARG:NE:NtpR' " );
option.add( basic::options::OptionKeys::chemical::reassign_icoor, "Update icoor parameters for specified atom types. -reassign_icoor format should be:: -reassign_icoor <rsd-type-set1-name>:<rsd-type1-name>:<atom1-name>:<the-six-icoor-params-as-a-comma-separated-list>   <rsd-type-set2-name>:<rsd-type2-name>:<atom2-name>:<icoorparams2> ...; for example: -chemical:reassign_icoor fa_standard:ADE:UPPER:-180,60,1.6,O3',C3',C4' " );
option.add( basic::options::OptionKeys::chemical::set_atomic_charge, "Modify atomic charge from the command line. Happens at time of params file reading, so changes will propagate to patched versions of the residue type. Format is: -chemical:set_atomic_charge <rsd-type-set1-name>:<rsd-type1-name>:<atom1-name>:<new-charge> <rsd-type-set2-name>:<rsd-type2-name>:<atom2-name>:<new-charge>  ... For example: '-chemical:set_atomic_charge fa_standard:ARG:NE:-1' " );
option.add( basic::options::OptionKeys::chemical::set_patch_atomic_charge, "Modify patch atomic charge from the command line. Happens at time of patch file reading, so changes will propagate to patched versions of the residue type.  Uses a simplified version of the residue selector so will probably not work for patches with complex selector logic.   format should be::  -chemical:set_patch_atomic_charge <rsd-type-set1-name>:<rsd-type1-name>:<patch-name>:<atom1-name>:<new-charge> ... For example: '-chemical:set_atomic_charge fa_standard:PRO:NtermProteinFull:1H:-1' " );
option.add( basic::options::OptionKeys::chemical::enlarge_H_lj, "Use larger LJ_WDEPTH for Hs to avoid RNA clashes" ).def(false);
option.add( basic::options::OptionKeys::chemical::no_hbonds_to_ether_oxygens, "no H-bonds to nucleic acid ether oxygens O3', O4', O5'" ).def(false);
option.add( basic::options::OptionKeys::constraints::constraints, "constraints option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::constraints::exit_on_bad_read, "exit if error is encountered reading constraints" ).def(true);
option.add( basic::options::OptionKeys::constraints::cst_file, "constraints filename(s) (for proteins, applied in centroid mode; when multiple files are given a *random* one will be picked)." );
option.add( basic::options::OptionKeys::constraints::cst_weight, "No description" ).def(1.0);
option.add( basic::options::OptionKeys::constraints::max_cst_dist, "No description" ).def(12.0);
option.add( basic::options::OptionKeys::constraints::cst_fa_file, "constraints filename(s) for fullatom. When multiple files are given a *random* one will be picked." );
option.add( basic::options::OptionKeys::constraints::cst_fa_weight, "No description" ).def(1.0);
option.add( basic::options::OptionKeys::constraints::normalize_mixture_func, "No description" ).def(false);
option.add( basic::options::OptionKeys::constraints::penalize_mixture_func, "No description" ).def(true);
option.add( basic::options::OptionKeys::constraints::forest_file, "file with constraintforest" ).def("");
option.add( basic::options::OptionKeys::constraints::compute_total_dist_cst, "only relevant for debug: atom_pair_constraints during abinito depends on seq_sep, this computes also the score without regarding seq_sep" ).def(false);
option.add( basic::options::OptionKeys::constraints::cull_with_native, "if option is set all constraints that violate the native structure with more than X are thrown out! " ).def(1);
option.add( basic::options::OptionKeys::constraints::dump_cst_set, "dump the cstset_ to file " ).def("");
option.add( basic::options::OptionKeys::constraints::evaluate_max_seq_sep, "evaluate constraints to this seq-sep [vector]" ).def(0);
option.add( basic::options::OptionKeys::constraints::named, "enable named constraints to avoid problems with changing residue-types e.g., cutpoint-variants" ).def(false);
option.add( basic::options::OptionKeys::constraints::no_cst_in_relax, "remove constraints for relax" ).def(false);
option.add( basic::options::OptionKeys::constraints::no_linearize_bounded, "dont switch to linearized in BOUNDED func" ).def(false);
option.add( basic::options::OptionKeys::constraints::pocket_constraint_weight, "Weight of the Pocket Constraint" ).def(0);
option.add( basic::options::OptionKeys::constraints::pocket_zero_derivatives, "Return zero for PocketConstaint derivatives" ).def(false);
option.add( basic::options::OptionKeys::constraints::viol, "show violations" ).def(false);
option.add( basic::options::OptionKeys::constraints::viol_level, "how much detail for violation output" ).def(1);

}
inline void add_rosetta_options_3( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::constraints::viol_type, "work only on these types of constraints" ).def("");
option.add( basic::options::OptionKeys::constraints::sog_cst_param, "weight parameter for SOGFunc constraints" ).def(0.0);
option.add( basic::options::OptionKeys::constraints::sog_upper_bound, "Upper cutoff for SOGFunc constraints" ).def(10.0);
option.add( basic::options::OptionKeys::constraints::epr_distance, "use epr distance potential" ).def(false);
option.add( basic::options::OptionKeys::constraints::combine, "combine constraints randomly into OR connected groups (Ambiguous). N->1" ).def(1);
option.add( basic::options::OptionKeys::constraints::combine_exclude_region, "core-defintion file do not combine constraints that are core-core" );
option.add( basic::options::OptionKeys::constraints::skip_redundant, "skip redundant constraints" ).def(false);
option.add( basic::options::OptionKeys::constraints::skip_redundant_width, "radius of influence for redundant constraints" ).def(2);
option.add( basic::options::OptionKeys::constraints::force_pdb_info_mapping, "force PDB info mapping for residues in cst file, using " " as default chain." ).def();
option.add( basic::options::OptionKeys::corrections::corrections, "corrections option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::corrections::beta, "Use the most-recent (curr Nov 15) beta score function" ).def(false);
option.add( basic::options::OptionKeys::corrections::beta_cart, "Use the most-recent (curr Nov 15) beta score function for nonideal optimization" ).def(false);
option.add( basic::options::OptionKeys::corrections::beta_nov16, "Use the November 2015 beta score function" ).def(false);
option.add( basic::options::OptionKeys::corrections::beta_nov16_cart, "Use the November 2015 beta score function for nonideal optimization" ).def(false);
option.add( basic::options::OptionKeys::corrections::beta_nov15, "Use the November 2015 beta score function" ).def(false);
option.add( basic::options::OptionKeys::corrections::beta_nov15_cart, "Use the November 2015 beta score function for nonideal optimization" ).def(false);
option.add( basic::options::OptionKeys::corrections::beta_july15, "Use the July 2015 beta  score function" ).def(false);
option.add( basic::options::OptionKeys::corrections::beta_july15_cart, "Use the July 2015 beta score function for nonideal optimization" ).def(false);
option.add( basic::options::OptionKeys::corrections::beta_patch, "Apply the extra patch to most-recent (curr Nov 15) beta_score_function." ).def(false);
option.add( basic::options::OptionKeys::corrections::beta_nov15_patch, "Apply the extra patch to (curr Nov 15) beta_score_function. Adding (conservative) patches to correct some pathologies found in beta_nov15. Could be merged to beta_nov15 in the future when it turns out to work generally better -score:weights beta_nov15_patch -rama_prepro_steep -eval_intrares_elec_ST_only" ).def(false);
option.add( basic::options::OptionKeys::corrections::newdna, "Apply some dna-specific mods to chemical/scoring (for testing)" ).def(false);
option.add( basic::options::OptionKeys::corrections::correct, "turn on default corrections:See src/core/init/score_function_corrections.cc" ).def(false);
option.add( basic::options::OptionKeys::corrections::hbond_sp2_correction, "turn on the hbond Sp2 correction with a single flag use with sp2_correction.wts. Note, these weight sets are chosen automatically by default. -score::hb_sp2_chipen -hb_sp2_BAH180_rise 0.75 -hb_sp2_outer_width 0.357 -hb_fade_energy -hbond_measure_sp3acc_BAH_from_hvy -lj_hbond_hdis 1.75 -lj_hbond_OH_donor_dis 2.6 -hbond_params sp2_elec_params -expand_st_chi2sampling -smooth_fa_elec -elec_min_dis 1.6 -elec_r_option false -chemical::set_atom_properties fa_standard:ONH2:LK_DGFREE:-5.85 fa_standard:NH2O:LK_DGFREE:-7.8 fa_standard:Narg:LK_DGFREE:-10.0 fa_standard:OH:LK_DGFREE:-6.70" );
option.add( basic::options::OptionKeys::corrections::facts_default, "turn on default options for FACTS use with scorefacts.wts. Incompatible with hbond_sp2_correction option. -correct -lj_hbond_hdis 2.3 -lj_hbond_OH_donor_dis 3.4 -use_bicubic_interpolation  -hbond_params sp2_elec_params -hb_sp2_chipen  -hbond_measure_sp3acc_BAH_from_hby -facts_GBpair_cut 10.0 -facts_min_dis 1.5 -facts_dshift 1.4 -facts_die 1.0 -facts_kappa 12.0 -facts_asp_patch 3 -facts_intrares_scale 0.4 -facts_elec_sh_exponent 1.8" ).def(false);
option.add( basic::options::OptionKeys::corrections::score::score, "score option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::corrections::score::bbdep_omega, "Enable phi-psi dependent omega" );
option.add( basic::options::OptionKeys::corrections::score::bbdep_bond_params, "Enable phi-psi dependent bondlengths and bondangles" );
option.add( basic::options::OptionKeys::corrections::score::bbdep_bond_devs, "Enable phi-psi dependent deviations for bondlengths and bondangles" );
option.add( basic::options::OptionKeys::corrections::score::no_his_his_pairE, "Set pair term for His-His to zero" );
option.add( basic::options::OptionKeys::corrections::score::no_his_DE_pairE, "Set pair term for His-Glu and His-Asp to zero" );
option.add( basic::options::OptionKeys::corrections::score::p_aa_pp, "Name of scoring/score_functions/P_AA_pp/P_AA_PP potential file (search in the local directory first, then look in the database)" ).def("scoring/score_functions/P_AA_pp/P_AA_pp");
option.add( basic::options::OptionKeys::corrections::score::p_aa_pp_nogridshift, "the format of p_aa_pp changed from using i*10+5 (5, 15, etc) to i*10 (0,10,etc.) as grid points" );
option.add( basic::options::OptionKeys::corrections::score::rama_not_squared, "Rama potential calculated as input for both rama and rama2b. By default, the potential is square for (ram a+entropy) > 1.0" );
option.add( basic::options::OptionKeys::corrections::score::rama_map, "Ramachandran file used by rama" ).def("scoring/score_functions/rama/Rama_smooth_dyn.dat_ss_6.4");
option.add( basic::options::OptionKeys::corrections::score::rama_pp_map, "Ramachandran dir used by rama_prepro" ).def("scoring/score_functions/rama/fd");
option.add( basic::options::OptionKeys::corrections::score::rama_map_average_L_flat, "Ramachandran map that's the average of all canonical L amino acids, flattened to give equal probability to the allowed region.  Lazily loaded; for sampling only." ).def("scoring/score_functions/rama/flat/avg_L_rama.dat");
option.add( basic::options::OptionKeys::corrections::score::rama_map_sym_average_L_flat, "Ramachandran map that's the average of all canonical L amino acids, flattened to give equal probability to the allowed region, and symmetrized.  Lazily loaded; for sampling only." ).def("scoring/score_functions/rama/flat/sym_all_rama.dat");
option.add( basic::options::OptionKeys::corrections::score::rama_map_sym_gly_flat, "Ramachandran map for glycine, flattened to give equal probability to the allowed region and symmetrized.  Lazily loaded; for sampling only." ).def("scoring/score_functions/rama/flat/sym_G_rama.dat");
option.add( basic::options::OptionKeys::corrections::score::rama_map_sym_pro_flat, "Ramachandran map for proline, flattened to give equal probability to the allowed region and symmetrized.  Lazily loaded; for sampling only." ).def("scoring/score_functions/rama/flat/sym_P_rama.dat");
option.add( basic::options::OptionKeys::corrections::score::rama_map_average_L_flat_stringent, "Ramachandran map that's the average of all canonical L amino acids, flattened to give equal probability to the allowed region, with the allowed region selected with high stringency.  Lazily loaded; for sampling only." ).def("scoring/score_functions/rama/flat/avg_L_rama_str.dat");
option.add( basic::options::OptionKeys::corrections::score::rama_map_sym_average_L_flat_stringent, "Ramachandran map that's the average of all canonical L amino acids, flattened to give equal probability to the allowed region, with the allowed region selected with high stringency, and symmetrized.  Lazily loaded; for sampling only." ).def("scoring/score_functions/rama/flat/sym_all_rama_str.dat");
option.add( basic::options::OptionKeys::corrections::score::rama_map_sym_gly_flat_stringent, "Ramachandran map for glycine, flattened to give equal probability to the allowed region, with the allowed region selected with high stringency, and symmetrized.  Lazily loaded; for sampling only." ).def("scoring/score_functions/rama/flat/sym_G_rama_str.dat");
option.add( basic::options::OptionKeys::corrections::score::rama_map_sym_pro_flat_stringent, "Ramachandran map for proline, flattened to give equal probability to the allowed region, with the allowed region selected with high stringency, and symmetrized.  Lazily loaded; for sampling only." ).def("scoring/score_functions/rama/flat/sym_P_rama_str.dat");
option.add( basic::options::OptionKeys::corrections::score::rama_prepro_steep, "Use steep rama_prepro library" ).def(false);
option.add( basic::options::OptionKeys::corrections::score::rama_prepro_nobidentate, "Use rama_prepro library derived by excluding bidentate Hbonding loop residues" ).def(false);
option.add( basic::options::OptionKeys::corrections::score::cenrot, "Use the Centroid Rotamer Model." ).def(false);
option.add( basic::options::OptionKeys::corrections::score::dun10, "Use the 2010 Dunbrack library instead of either the the 2002 library." ).def(true);
option.add( basic::options::OptionKeys::corrections::score::dun10_dir, "Name of dun10 dir" ).def("rotamer/ExtendedOpt1-5");
option.add( basic::options::OptionKeys::corrections::score::dun02_file, "Name of dun02 input file" ).def("rotamer/bbdep02.May.sortlib");
option.add( basic::options::OptionKeys::corrections::score::ch_o_bond_potential, "Name of ch_o_bond potential file (search in the local directory first, then look in the database)" ).def("scoring/score_functions/carbon_hbond/ch_o_bond_potential.dat");
option.add( basic::options::OptionKeys::corrections::score::lj_hbond_hdis, "Lennard Jones sigma value for hatms, classically it's been at 1.95 but the average A-H distance for hydrogen bonding is 1.75 from crystal structures. (momeara)" ).def(1.75);
option.add( basic::options::OptionKeys::corrections::score::lj_hbond_OH_donor_dis, "Lennard Jones sigma value for O in OH donor groups.  Classically it has been 3.0 but the average distances from crystal structurs is 2.6 (momeara)" ).def(2.6);
option.add( basic::options::OptionKeys::corrections::score::score12prime, "Restore to score funciton parameters to score12 parameters and have getScoreFuntion return with score12prime.wts. The score12prime.wts differs from standard.wts + score12.wts_patch, in that the reference energies have been optimized with optE for sequence profile recovery" ).def(false);
option.add( basic::options::OptionKeys::corrections::score::hbond_energy_shift, "The shift upwards (through addition) of the well depth for the hydrogen bond polynomials; this shift is applied before the weights are applied." ).def(0.0);
option.add( basic::options::OptionKeys::corrections::score::hb_sp2_BAH180_rise, "The rise from -0.5 for the BAH=180 value for the additive chi/BAH sp2 potential" ).def(0.75);
option.add( basic::options::OptionKeys::corrections::score::hb_sp2_outer_width, "The width between the peak when CHI=0 and BAH=120 to when the BAH is at a maximum (Units: pi * radians. E.g. 1/3 means the turn off hbonding when BAH < 60, larger values mean a wider potential). Use 0.357 in conjunction with the hb_energy_fade flag." ).def(0.357);
option.add( basic::options::OptionKeys::corrections::score::hb_sp2_chipen, "Experimental term for hydrogen bonds to sp2 acceptors: penalizes out-of-plane geometry by 67%" ).def(true);
option.add( basic::options::OptionKeys::corrections::score::hbond_measure_sp3acc_BAH_from_hvy, "If true, then the BAH angle for sp3 (aka hydroxyl) acceptors is measured donor-hydrogen--acceptor-heavyatom--heavyatom-base instead of donor-hydrogen--accptor-heavyatom--hydroxyl-hydrogen" ).def(true);
option.add( basic::options::OptionKeys::corrections::score::hb_fade_energy, "Rather than having a strict cutoff of hbond definition at 0, fade the energy smoothly in the range [-0.1, 0.1]. This is necessary to prevent a discontinuity in the derivative when E=0 that arise because of the additive form of the hbond function." ).def(true);
option.add( basic::options::OptionKeys::corrections::score::hb_cen_soft, "Use softer version of cen_hb term" ).def(false);
option.add( basic::options::OptionKeys::corrections::score::use_bicubic_interpolation, "Instead of using bilinear interpolation to evaluate the Ramachandran, P_AA_pp and Dunbrack potentials, use bicubic interpolation.  Avoids pile-ups at the grid boundaries where discontinuities in the derivatives frustrate the minimizer" ).def(true);
option.add( basic::options::OptionKeys::corrections::score::dun_normsd, "Use height-normalized guassian distributions to model p(chi|phi,psi) instead of height-unnormalized gaussians" ).def(false);
option.add( basic::options::OptionKeys::corrections::score::dun_entropy_correction, "Add Shannon entropy correction to rotamer energy: E = -logP + S" ).def(false);
option.add( basic::options::OptionKeys::corrections::chemical::chemical, "chemical option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::corrections::chemical::icoor_05_2009, "New set of idealized coordinates for full atom, 05-2009" );
option.add( basic::options::OptionKeys::corrections::chemical::parse_charge, "Use PARSE charge set." );
option.add( basic::options::OptionKeys::corrections::chemical::expand_st_chi2sampling, "Ugly temporary hack.  Expand the chi2 sampling for serine and threonine in the fa_standard residue type set so that samples are taken every 20 degrees (instead of every 60 degrees.  This will soon be changed in the SER and THR params files themselves.  This flag can be used with any residue type set (including the pre-s fa_standard version, and with the fa_standard_05.2009_icoor version) but is unncessary for the talaris2013 version (currently named fa_standard) as the expanded SER and THR sampling is already encoded in .params files for these two residues" ).def(false);
option.add( basic::options::OptionKeys::corrections::shapovalov_lib_fixes_enable, "Apply new code by Maxim Shapovalov from Dunbrack Lab such as for reading/using dun, rama, prop libraries in new format and options for applying different bug fixes. False value will employ old libraries and old code." ).def(false);
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shapovalov_lib, "shapovalov_lib option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_dun10_enable, "Enable new Shapovalov's dun10 fix if the umbrella option is on, shapovalov_lib_fixes" ).def(true);
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_dun10_smooth_level, "Smoothing level either numeric or word keyword, possible values are 1 or lowest_smooth, 2 or lower_smooth, 3 or low_smooth, 4 or average_smooth, 5 or higher_smooth, 6 or highest_smooth." ).def("3");
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_dun10_dir, "Name of the new format dun10 dir" ).def("rotamer/shapovalov/StpDwn_5-5-5");
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_dun10_use_minus_log_P_ignore_P, "Use minus log P from text libraries only and ignore any P." ).def(false);
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_rama_enable, "Enable new Shapovalov's Rama fix if the umbrella option is on, shapovalov_lib_fixes" ).def(true);
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_rama_smooth_level, "Smoothing level either numeric or word keyword, possible values are 1 or lowest_smooth, 2 or lower_smooth, 3 or higher_smooth, 4 or highest_smooth." ).def("4");
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_rama_map, "New Ramachandran file in the new format used by rama" ).def("scoring/score_functions/rama/shapovalov/kappa25/all.ramaProb");
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_rama_nogridshift, "With correct flag there is a bug. Rama09_noEH_kernel25_it08.dat is used where prob values are reported exactly at the 10-deg grid while Rama_smooth_dyn.dat_ss_6.4 has values reported in the middle of bins. There is no need for 5-deg shift for newer Rama maps with values reported at the grid." ).def(true);
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_p_aa_pp_enable, "Enable new Shapovalov's propensity map fix if the umbrella option is on, shapovalov_lib_fixes" ).def(true);
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_p_aa_pp_smooth_level, "Smoothing level either numeric or word keyword, possible values are 1 or low_smooth, 2 or high_smooth." ).def("2");
option.add( basic::options::OptionKeys::corrections::shapovalov_lib::shap_p_aa_pp, "Name of the new Shapovalov's P_AA_PP potential file (search in the local directory first, then look in the database)" ).def("scoring/score_functions/P_AA_pp/shapovalov/10deg/kappa50/a20.prop");
option.add( basic::options::OptionKeys::evaluation::evaluation, "evaluation option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::evaluation::rmsd_target, "[vector] determine rmsd against this/these structure(s)" );
option.add( basic::options::OptionKeys::evaluation::rmsd_column, "[vector] use xxx as column name: rms_xxx" );
option.add( basic::options::OptionKeys::evaluation::rmsd_select, "[vector] a bunch of loop files which makes rmsds with tags: rms_XXX, where XXX is basename of file" );
option.add( basic::options::OptionKeys::evaluation::align_rmsd_target, "[vector] determine rmsd against this/these structure(s) using simple sequence alignment" );
option.add( basic::options::OptionKeys::evaluation::structural_similarity, "[vector] measure average similarity against these structures (option specifies a silent-file)" );
option.add( basic::options::OptionKeys::evaluation::contact_map, "Calculate contact map similarity using the given native" );
option.add( basic::options::OptionKeys::evaluation::jscore_evaluator, "Calculate scores using the given score function weights files and, residue type set names (e.g score12 fa_standard score3 centroid)" );
option.add( basic::options::OptionKeys::evaluation::align_rmsd_column, "[vector] use xxx as column name for align_rmsd_target: rms_xxx" );
option.add( basic::options::OptionKeys::evaluation::align_rmsd_fns, "[vector] of sequence alignments used for align_rmsd files" );
option.add( basic::options::OptionKeys::evaluation::align_rmsd_format, "format for sequence alignment between structures used in evaluation" ).legal("grishin").legal("general").def("grishin");
option.add( basic::options::OptionKeys::evaluation::rms_type, "RNP if you want both protein and RNA RMSD, blank for protein" ).def("");
option.add( basic::options::OptionKeys::evaluation::predicted_burial_fn, "file for burial predictions" ).def("");
option.add( basic::options::OptionKeys::evaluation::pool, "find closest matching structure in this pool and report tag and rmsd" );
option.add( basic::options::OptionKeys::evaluation::rmsd, "[vector/pairs] tripletts: rmsd_target (or NATIVE / IRMS) col_name selection_file (or FULL)" );
option.add( basic::options::OptionKeys::evaluation::chirmsd, "[vector/tripletts]: rmsd_target (or NATIVE / IRMS ) col_name selection_file ( or FULL) " );
option.add( basic::options::OptionKeys::evaluation::gdtmm, "for each rmsd evaluator also a gdtmm evaluator is created" ).def(false);
option.add( basic::options::OptionKeys::evaluation::gdttm, "for each rmsd evaluator also a gdttm evaluator is created" ).def(false);
option.add( basic::options::OptionKeys::evaluation::score_with_rmsd, "score the pose on the same subset of atoms as in the rmsd poses" );
option.add( basic::options::OptionKeys::evaluation::constraints, "[vector] evaluate against these constraint sets" );
option.add( basic::options::OptionKeys::evaluation::constraints_column, "[vector] use xxx as column name: cst_xxx" );
option.add( basic::options::OptionKeys::evaluation::combined_constraints, "[vector] use xxx as cst-file but combine constraints before applying" );
option.add( basic::options::OptionKeys::evaluation::combined_constraints_column, "[vector] use xxx as cst-file but combine constraints before applying" );
option.add( basic::options::OptionKeys::evaluation::combine_statistics, "repeat constraint evaluation X times to get statistics of constraint combination" ).def(10);
option.add( basic::options::OptionKeys::evaluation::chemical_shifts, "compute chemical shift score with SPARTA+ use tuples: talos_file [cs]_column_name  (ATTENTION uses filesystem)" );
option.add( basic::options::OptionKeys::evaluation::sparta_dir, "[optional] point to an external resource for the sparta directory (instead of minirosetta_database)" ).def("SPARTA+");
option.add( basic::options::OptionKeys::evaluation::cam_shifts, "compute chemical shift score with Camshift talos_file [cs]_column_name  (ATTENTION uses filesystem)" );
option.add( basic::options::OptionKeys::evaluation::pales, "compute Residual Dipolar Couplings using the PALES program (ATTENTION uses filesystem)" );
option.add( basic::options::OptionKeys::evaluation::extra_score, "[vector] provide .wts files to generate extra columns" );
option.add( basic::options::OptionKeys::evaluation::extra_score_patch, "[vector] provide .patch files, set NOPATCH for columns that are not patched" );
option.add( basic::options::OptionKeys::evaluation::extra_score_column, "[vector] use xxx as column name: score_xxx" );
option.add( basic::options::OptionKeys::evaluation::extra_score_select, "[vector] /rigid/ files for selection, use SELECT_ALL as placeholder" );
option.add( basic::options::OptionKeys::evaluation::rdc_target, "[vector] as rmsd_target/column provide PDB wih missing density to compute RDC score on selected residues" );
option.add( basic::options::OptionKeys::evaluation::symmetric_rmsd, "calculate the rmsd symmetrically by checking all chain orderings" );
option.add( basic::options::OptionKeys::evaluation::rdc_column, "[vector] column names for rdc_select" );
option.add( basic::options::OptionKeys::evaluation::rdc, "[vector] rdc-files and column names for RDC calculation" );
option.add( basic::options::OptionKeys::evaluation::built_in_rdc, "evaluate rdc from -in:file:rdc with standard score function and store under column xxx" );
option.add( basic::options::OptionKeys::evaluation::jump_nr, "adds the JumpNrEvaluator for the nrjumps column" ).def(false);
option.add( basic::options::OptionKeys::evaluation::score_exclude_res, "Calculates a select_score column based on all residues not excluded by the command line vector" );
option.add( basic::options::OptionKeys::evaluation::score_sscore_short_helix, "defines the maximum length of a helix that is not scored if it terminates a loop" ).def(5);
option.add( basic::options::OptionKeys::evaluation::score_sscore_maxloop, "defines the maximum length of a loop that is still considered for the sscore - score" ).def(3);
option.add( basic::options::OptionKeys::evaluation::window_size, "Window size for local RMSD calculations in windowed_rmsd app" ).def(5);
option.add( basic::options::OptionKeys::evaluation::I_sc, "score function name used to calculate I_sc" ).def("score12");
option.add( basic::options::OptionKeys::evaluation::Irms, "will compute the docking interface rmsd" ).def(false);
option.add( basic::options::OptionKeys::evaluation::Ca_Irms, "will compute the docking Ca-atom interface rmsd" ).def(false);
option.add( basic::options::OptionKeys::evaluation::Fnat, "will compute the docking recovered fraction of native contacts" ).def(false);
option.add( basic::options::OptionKeys::evaluation::Lrmsd, "will compute the docking ligand rmsd" ).def(false);
option.add( basic::options::OptionKeys::evaluation::Fnonnat, "will compute the fraction of non-native contacts for docking" ).def(false);
option.add( basic::options::OptionKeys::evaluation::DockMetrics, "will compute all docking metrics (I_sc/Irms/Fnat/Lrmsd for now) for replica docking" ).def(false);
option.add( basic::options::OptionKeys::filters::filters, "filters option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::filters::disable_all_filters, "turn off all centroid filters: RG, CO, and Sheet" ).def(false);
option.add( basic::options::OptionKeys::filters::disable_rg_filter, "turn off RG filter" ).def(false);
option.add( basic::options::OptionKeys::filters::disable_co_filter, "turn off contact order filter" ).def(false);
option.add( basic::options::OptionKeys::filters::disable_sheet_filter, "turn off sheet filter" ).def(false);
option.add( basic::options::OptionKeys::filters::set_pddf_filter, "Turns on PDDF filter with a given score cutoff" ).def(5.0);
option.add( basic::options::OptionKeys::filters::set_saxs_filter, "Turns on SAXS energy filter with a given score cutoff" ).def(-3);
option.add( basic::options::OptionKeys::gpu::gpu, "Enable/Disable GPU support" ).def(true).is_group(true);
option.add( basic::options::OptionKeys::gpu::device, "GPU device to use" ).def(1);
option.add( basic::options::OptionKeys::gpu::threads, "Max GPU threads to use" ).def(2048);
option.add( basic::options::OptionKeys::jumps::jumps, "jumps option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::jumps::evaluate, "evaluate N-CA-C gemoetry for all jumps in the fold-tree" ).def(false);
option.add( basic::options::OptionKeys::jumps::extra_frags_for_ss, "use ss-def from this fragset" ).def("");
option.add( basic::options::OptionKeys::jumps::fix_chainbreak, "minimize to fix ccd in re-runs" ).def(false);
option.add( basic::options::OptionKeys::jumps::fix_jumps, "read jump_file" ).def("");
option.add( basic::options::OptionKeys::jumps::jump_lib, "read jump_library_file for automatic jumps" ).def("");
option.add( basic::options::OptionKeys::jumps::loop_definition_from_file, "use ss-def from this file" ).def("");
option.add( basic::options::OptionKeys::jumps::no_chainbreak_in_relax, "dont penalize chainbreak in relax" ).def(false);
option.add( basic::options::OptionKeys::jumps::pairing_file, "file with pairings" ).def("");
option.add( basic::options::OptionKeys::jumps::random_sheets, "random sheet topology--> replaces -sheet1 -sheet2 ... select randomly up to N sheets with up to -sheet_i pairgins for sheet i" ).def(1);
option.add( basic::options::OptionKeys::jumps::residue_pair_jump_file, "a file to define residue pair jump" ).def("");
option.add( basic::options::OptionKeys::jumps::sheets, "sheet topology--> replaces -sheet1 -sheet2 ... -sheetN" ).def(1);
option.add( basic::options::OptionKeys::jumps::topology_file, "read a file with topology info ( PairingStats )" ).def("");
option.add( basic::options::OptionKeys::jumps::bb_moves, "Apply bb_moves ( wobble, small, shear) during stage3 and stage 4." ).def(false);
option.add( basic::options::OptionKeys::jumps::no_wobble, "Don t apply the useless wobble during stage3 and stage 4." ).def(false);
option.add( basic::options::OptionKeys::jumps::no_shear, "Don t apply the useless shear during stage3 and stage 4." ).def(false);
option.add( basic::options::OptionKeys::jumps::no_sample_ss_jumps, "sample jump-frags during folding" ).def(false);
option.add( basic::options::OptionKeys::jumps::invrate_jump_move, "give 5 here to have 5 torsion moves for each jump move" ).def(10);
option.add( basic::options::OptionKeys::jumps::chainbreak_weight_stage1, "the weight on chainbreaks" ).def(1.0);
option.add( basic::options::OptionKeys::jumps::chainbreak_weight_stage2, "the weight on chainbreaks" ).def(1.0);
option.add( basic::options::OptionKeys::jumps::chainbreak_weight_stage3, "the weight on chainbreaks" ).def(1.0);
option.add( basic::options::OptionKeys::jumps::chainbreak_weight_stage4, "the weight on chainbreaks" ).def(1.0);
option.add( basic::options::OptionKeys::jumps::ramp_chainbreaks, "ramp up the chainbreak weight stage1-0, stage2 0.25, stage3 alternating 0.5..2.5, stage4 2.5..4" ).def(true);
option.add( basic::options::OptionKeys::jumps::increase_chainbreak, "multiply ramped chainbreak weight by this amount" ).def(1.0);
option.add( basic::options::OptionKeys::jumps::overlap_chainbreak, "use the overlap chainbrak term in stage4" ).def(false);
option.add( basic::options::OptionKeys::jumps::sep_switch_accelerate, "constraints and chainbreak depend on in-chain-separation. Accelerate their enforcement 1+num_cuts()*<this_factor>" ).def(0.4);
option.add( basic::options::OptionKeys::jumps::dump_frags, "dump jump_fragments " ).def(false);
option.add( basic::options::OptionKeys::jumps::njumps, "number_of_jumps to select from library for each trajectory (membrane mode)" ).def(1);
option.add( basic::options::OptionKeys::jumps::max_strand_gap_allowed, "merge strands if they less than X residues but same register" ).def(2);
option.add( basic::options::OptionKeys::jumps::contact_score, "the strand-weight will have a weight * contact_order component" ).def(0.0);
option.add( basic::options::OptionKeys::jumps::filter_templates, "filter hybridization protocol templates" ).def(false);
option.add( basic::options::OptionKeys::loops::loops, "loop modeling option group" ).legal(true).legal(false).def(true).is_group(true);
option.add( basic::options::OptionKeys::loops::cen_weights, "ScoreFunction weights file for centroid phase of loop-modeling" ).def("cen_std");
option.add( basic::options::OptionKeys::loops::cen_patch, "ScoreFunction patch for for centroid phase of loop-modeling" ).def("score4L");
option.add( basic::options::OptionKeys::loops::input_pdb, "template pdb file" ).def("input_pdb");
option.add( basic::options::OptionKeys::loops::loop_file, "Loop definition file(s). When multiple files are given a *random* one will be picked each time when this parameter is requested." );
option.add( basic::options::OptionKeys::loops::extended_loop_file, "loop definition file for loops to be extended (used in abrelax)" ).def("loop_file");
option.add( basic::options::OptionKeys::loops::mm_loop_file, "loop definition file" ).def("loop_file");
option.add( basic::options::OptionKeys::loops::fix_natsc, "fix sidechains in template region in loop modeling" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::refine_only, "perform full atom refinement only on loops" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::fast, "reduce number of simulation cycles in loop modeling" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::vall_file, "vall database file" ).def("vall_file");
option.add( basic::options::OptionKeys::loops::frag_sizes, "lengths of fragments to be used in loop modeling" ).def(9).def(3).def(1);
option.add( basic::options::OptionKeys::loops::frag_files, "fragment libraries files" ).def("frag9").def("frag3").def("frag1");
option.add( basic::options::OptionKeys::loops::output_pdb, "output model pdb file" ).def("output.pdb");
option.add( basic::options::OptionKeys::loops::debug, "No description" ).def(false);
option.add( basic::options::OptionKeys::loops::build_initial, "Precede loop-modeling with an initial round of just removing the missing densities and building simple loops" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::extended, "Force extended on loops, independent of loop input file" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::remove_extended_loops, "Before building any loops, remove all loops marked as extended" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::idealize_after_loop_close, "Run structure through idealizer after loop_closing" ).def(true);
option.add( basic::options::OptionKeys::loops::idealize_before_loop_close, "Run structure through idealizer before loop_closing" ).def(true);
option.add( basic::options::OptionKeys::loops::select_best_loop_from, "Keep building loops until N and choose best (by score)" ).def(1);
option.add( basic::options::OptionKeys::loops::build_attempts, "Build attempts per growth attempt" ).def(3);
option.add( basic::options::OptionKeys::loops::grow_attempts, "Total loop growth attempts" ).def(7);
option.add( basic::options::OptionKeys::loops::random_grow_loops_by, "Randomly grow loops by up to this number of residues on either side." ).def(0.0);
option.add( basic::options::OptionKeys::loops::accept_aborted_loops, "accept aborted loops      " ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::strict_loops, "Do not allow growing of loops" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::superimpose_native, "Superimpose the native over the core before calculating looprms" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::build_specific_loops, "Numbers of the loops to be built" );
option.add( basic::options::OptionKeys::loops::random_order, "build in random order     " ).legal(true).legal(false).def(true);
option.add( basic::options::OptionKeys::loops::build_all_loops, "build all loops(no skip)  " ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::fa_closure_protocol, "Abrelax uses FASlidingWindowLoopClosure... " ).def(false);
option.add( basic::options::OptionKeys::loops::combine_rate, "Combine successive loops at this rate" ).def(0.0);
option.add( basic::options::OptionKeys::loops::skip_initial_loop_build, "Skip the initial loop build step where existing loop torsions are discarded and the loop is built from scratch. " ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::remodel, "" ).legal("no").legal("perturb_ccd").legal("perturb_kic").legal("perturb_kic_refactor").legal("perturb_kic_with_fragments").legal("quick_ccd").legal("quick_ccd_moves").legal("old_loop_relax").legal("sdwindow").def("no");
option.add( basic::options::OptionKeys::loops::intermedrelax, "" ).legal("no").legal("relax").legal("fastrelax").legal("seqrelax").def("no");
option.add( basic::options::OptionKeys::loops::refine, "method for performing full-atom refinement on loops" ).legal("no").legal("refine_ccd").legal("refine_kic").legal("refine_kic_refactor").legal("refine_kic_with_fragments").def("no");
option.add( basic::options::OptionKeys::loops::relax, "" ).legal("no").legal("relax").legal("fastrelax").legal("seqrelax").legal("minirelax").def("no");
option.add( basic::options::OptionKeys::loops::final_clean_fastrelax, "Add a final fastrelax without constraints" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::relax_with_foldtree, "keep foldtree during relax" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::constrain_rigid_segments, "Use Coordinate constraints on the non-loop regions" ).def(0.0);
option.add( basic::options::OptionKeys::loops::loopscores, "Calculate loopscores individually for these loops (path to loopsfile)" );
option.add( basic::options::OptionKeys::loops::timer, "Output time spent in seconds for each loop modeling job" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::vicinity_sampling, "only sample within a certain region of the current torsion values" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::vicinity_degree, "number of degrees to sample within current torsion values for vicinity sampling" ).def(1.0);
option.add( basic::options::OptionKeys::loops::neighbor_dist, "CB distance cutoff for repacking, rotamer trails, and side-chain minimization during loop modeling. NOTE: values over 10.0 are effectively reduced to 10.0" ).def(10.0);
option.add( basic::options::OptionKeys::loops::kic_max_seglen, "maximum size of residue segments used in kinematic closure calculations" ).def(12);
option.add( basic::options::OptionKeys::loops::kic_recover_last, "If true, do not recover lowest scoring pose after each outer cycle and at end of protocol in kic remodel and refine" ).def(false);
option.add( basic::options::OptionKeys::loops::kic_min_after_repack, "Should the kinematic closure refine protocol minimize after repacking steps" ).def(true);
option.add( basic::options::OptionKeys::loops::optimize_only_kic_region_sidechains_after_move, "Should we perform rotamer trials and minimization after every KIC move but only within the loops:neighbor_dist of the residues in the moved KIC segment. Useful to speed up when using very large loop definitions (like when whole chains are used for ensemble generation)." ).def(false);
option.add( basic::options::OptionKeys::loops::max_kic_build_attempts, "Number of attempts at initial kinematic closure loop building" ).def(10000);
option.add( basic::options::OptionKeys::loops::remodel_kic_attempts, "Number of kic attempts per inner cycle during perturb_kic protocol" ).def(300);
option.add( basic::options::OptionKeys::loops::max_kic_perturber_samples, "Maximum number of kinematic perturber samples" ).def(2000);
option.add( basic::options::OptionKeys::loops::nonpivot_torsion_sampling, "enables sampling of non-pivot residue torsions when the kinematic loop closure segment length is > 3" ).legal(true).legal(false).def(true);
option.add( basic::options::OptionKeys::loops::fix_ca_bond_angles, "Freezes N-CA-C bond angles in KIC loop sampling" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::kic_use_linear_chainbreak, "Use linear_chainbreak instead of (harmonic) chainbreak in KIC loop sampling" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::sample_omega_at_pre_prolines, "Sample omega in KIC loop sampling" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::allow_omega_move, "Allow loop omega to minimize during loop modeling" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::kic_with_cartmin, "Use cartesian minimization in KIC loop modeling" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::allow_takeoff_torsion_move, "Allow takeoff phi/psi to move during loop modeling" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::extend_length, "Number of alanine residues to append after cutpoint in loopextend app" ).lower(0).def(0);
option.add( basic::options::OptionKeys::loops::perturb_outer_cycles, "number of outer cycles in the perturbation (centroid) stage" ).lower(1).def(5);
option.add( basic::options::OptionKeys::loops::refine_outer_cycles, "number of outer cycles in the fullatom refinement stage" ).lower(1).def(5);
option.add( basic::options::OptionKeys::loops::max_inner_cycles, "maxium number of inner cycles in fullatom loop refinement" ).lower(1).def(1);
option.add( basic::options::OptionKeys::loops::repack_period, "repack period during fullatom loop refinement" ).lower(1).def(20);
option.add( basic::options::OptionKeys::loops::remodel_init_temp, "Initial temperature for loop rebuiding. Currently only supported in kinematic (KIC) mode" ).def(2.0);
option.add( basic::options::OptionKeys::loops::remodel_final_temp, "Final temperature for loop rebuilding. Currently only supported in kinematic (KIC) mode" ).def(1.0);
option.add( basic::options::OptionKeys::loops::refine_init_temp, "Initial temperature for loop refinement. Currently only supported in kinematic (KIC) mode" ).def(1.5);
option.add( basic::options::OptionKeys::loops::refine_final_temp, "Final temperature for loop refinement. Currently only supported in kinematic (KIC) mode" ).def(0.5);
option.add( basic::options::OptionKeys::loops::gapspan, "when automatically identifying loop regions, this is the maximum gap length for a single loop" ).lower(1).def(6);
option.add( basic::options::OptionKeys::loops::spread, "when automatically identifying loop regions, this is the number of neighboring residues by which to extend out loop regions" ).lower(1).def(2);
option.add( basic::options::OptionKeys::loops::kinematic_wrapper_cycles, "maximum number of KinematicMover apply() tries per KinematicWrapper apply()" ).def(20);
option.add( basic::options::OptionKeys::loops::kic_num_rotamer_trials, "number of RotamerTrial iterations in each KIC cycle -- default is 1" ).def(1);
option.add( basic::options::OptionKeys::loops::kic_omega_sampling, "Perform sampling of omega angles around 179.6 for trans, and including 0 for pre-prolines -- default false, for legacy reasons" ).def(false);
option.add( basic::options::OptionKeys::loops::kic_bump_overlap_factor, "allow some atomic overlap in initial loop closures (should be remediated in subsequent repacking and minimization)" ).def(0.36);
option.add( basic::options::OptionKeys::loops::minimize_max_iter, "Max iteration of minimization during MC" ).def(200);
option.add( basic::options::OptionKeys::loops::restrict_kic_sampling_to_torsion_string, "restrict kinematic loop closure sampling to the phi/psi angles specified in the torsion string" ).def("");

}
inline void add_rosetta_options_4( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::loops::derive_torsion_string_from_native_pose, "apply torsion-restricted sampling, and derive the torsion string from the native [or, if not provided, starting] structure" ).def(false);
option.add( basic::options::OptionKeys::loops::always_remodel_full_loop, "always remodel the full loop segment (i.e. the outer pivots are always loop start & end) -- currently this only applies to the perturb stage -- EXPERIMENTAL" ).def(false);
option.add( basic::options::OptionKeys::loops::taboo_sampling, "enhance diversity in KIC sampling by pre-generating different torsion bins and sampling within those -- this flag activates Taboo sampling in the perturb stage" ).def(false);
option.add( basic::options::OptionKeys::loops::taboo_in_fa, "enhance diversity in KIC sampling by pre-generating different torsion bins and sampling within those -- this flag activates Taboo sampling in the first half of the full-atom stage; use in combination with -loops:taboo_sampling or -kic_leave_centroid_after_initial_closure" ).def(false);
option.add( basic::options::OptionKeys::loops::ramp_fa_rep, "ramp the weight of fa_rep over outer cycles in refinement" ).def(false);
option.add( basic::options::OptionKeys::loops::ramp_rama, "ramp the weight of rama over outer cycles in refinement" ).def(false);
option.add( basic::options::OptionKeys::loops::kic_rama2b, "use neighbor-dependent Ramachandran distributions in random torsion angle sampling" ).def(false);
option.add( basic::options::OptionKeys::loops::kic_leave_centroid_after_initial_closure, "only use centroid mode for initial loop closure -- all further loop closures will be performed in full-atom" ).def(false);
option.add( basic::options::OptionKeys::loops::legacy_kic, "always select the start pivot first and then the end pivot -- biases towards sampling the C-terminal part of the loop more (false by default)" ).def(false);
option.add( basic::options::OptionKeys::loops::alternative_closure_protocol, "use WidthFirstSliding..." ).def(false);
option.add( basic::options::OptionKeys::loops::chainbreak_max_accept, "accept all loops that have a lower cumulative chainbreak score (linear,quadratic(if present), and overlap)" ).def(2.0);
option.add( basic::options::OptionKeys::loops::debug_loop_closure, "dump structures before and after loop closing" ).def(false);
option.add( basic::options::OptionKeys::loops::non_ideal_loop_closing, "allow small non-idealities at the chainbreak residue after loop-closing -- requires binary silent out" ).def(false);
option.add( basic::options::OptionKeys::loops::scored_frag_cycles, "cycle-ratio for scored_frag_cycles ( loop_size<10 ) after jumping-abinitio" ).def(1.0);
option.add( basic::options::OptionKeys::loops::short_frag_cycles, "cycle-ratio for short_frag_cycles ( loop_size<10 ) after jumping-abinitio" ).def(1.0);
option.add( basic::options::OptionKeys::loops::rmsd_tol, "rmsd tolerance to deviate from original pose" ).def(10000.0);
option.add( basic::options::OptionKeys::loops::chain_break_tol, "acceptable tolerance for chain break score" ).def(0.2);
option.add( basic::options::OptionKeys::loops::random_loop, "randomize loop stub positions" ).def(false);
option.add( basic::options::OptionKeys::loops::stealfrags, "StealFragPDBS" );
option.add( basic::options::OptionKeys::loops::stealfrags_times, "StealFragPDBS how many times ?" ).def(1);
option.add( basic::options::OptionKeys::loops::coord_cst, "restraintweight" ).def(0.0);
option.add( basic::options::OptionKeys::loops::skip_1mers, "rate at which you should skip a 1 mer insertion" ).def(0.0);
option.add( basic::options::OptionKeys::loops::skip_3mers, "rate at which you should skip a 3 mer insertion" ).def(0.0);
option.add( basic::options::OptionKeys::loops::skip_9mers, "rate at which you should skip a 9 mer insertion" ).def(0.0);
option.add( basic::options::OptionKeys::loops::loop_model, "loop modeling option" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::score_filter_cutoff, "value for score filter" ).def(1.0);
option.add( basic::options::OptionKeys::loops::ccd_closure, "apply ccd closure" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::skip_ccd_moves, "when running in ccd_moves mode, dont actually do ccd_moves.. just do fragment insertions" ).def(false);
option.add( basic::options::OptionKeys::loops::no_randomize_loop, "Leave loop as it is" ).def(false);
option.add( basic::options::OptionKeys::loops::loops_subset, "pick subset of desired loops" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::num_desired_loops, "number of desired loops" ).def(1);
option.add( basic::options::OptionKeys::loops::loop_combine_rate, "skip rate for not combining a chosen loop" ).def(0.0);
option.add( basic::options::OptionKeys::loops::final_score_filter, "Only output structures that score bette rthan that" ).def(1000000.0);
option.add( basic::options::OptionKeys::loops::no_combine_if_fail, "combine loops if loop modeling fails" ).legal(true).legal(false).def(true);
option.add( basic::options::OptionKeys::loops::shorten_long_terminal_loop, "shorten long loops" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::backrub_trials, "number of backrub steps to do in loop relax" ).def(10);
option.add( basic::options::OptionKeys::loops::looprlx_cycle_ratio, "fraction of the total looprlx cycles" ).def(1.0);
option.add( basic::options::OptionKeys::loops::extended_beta, "Extended tempfactor: stochastic extendedness: p_ext = exp( - beta * length ) " ).def(-1.0);
option.add( basic::options::OptionKeys::loops::no_looprebuild, "do not rebuild loops" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::allow_lig_move, "allow ligands to move during loop modeling" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::keep_natro, "list of residues where the rotamers are kept fixed" ).def("keep_natro");
option.add( basic::options::OptionKeys::loops::refine_design_iterations, "iterations of refine and design" ).def(1);
option.add( basic::options::OptionKeys::loops::ccd::ccd, "ccd option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::loops::ccd::max_rama_score_increase, "Maximum increase in Ramachandran score that will be tolerated." ).def(2.0);
option.add( basic::options::OptionKeys::loops::ccd::max_torsion_delta_per_move, "Maxmimum absolute torsion deviation for a single residue in a given move. Different deviations for residues in helical, extended or coil conformations must be supplied (in that order)." ).n(3).def(1.0).def(5.0).def(10.0);
option.add( basic::options::OptionKeys::loops::ccd::max_torsion_delta, "Maxmimum absolute torsion deviation for a single residue over the entire CCD closure. Different deviations for residues in helical, extended or coil conformations must be supplied (in that order)." ).n(3).def(10.0).def(50.0).def(75.0);
option.add( basic::options::OptionKeys::loops::ccd::tolerance, "Maximum RMSD (in Angstroms) of the duplicated atoms across the cutpoint that will be considered a successful closure." ).def(0.08);
option.add( basic::options::OptionKeys::loops::ccd::max_cycles, "Maximum number of CCD iterations to attempt. CCD will stop if the loop is closed in fewer cycles than the maximum." ).def(100);
option.add( basic::options::OptionKeys::loops::ccd::check_rama_scores, "Bias toward moves that improve the moving resiude's Ramachandran score." ).legal(true).legal(false).def(true);
option.add( basic::options::OptionKeys::loops::ccd::rama_2b, "Use two-body (neighbor-dependent) Ramachandran score." ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::loops::ccd::temperature, "Temperature (roughly in units of kT) to use when accepting a move that does not improve the Ramachandran score." ).def(0.25);
option.add( basic::options::OptionKeys::intf::intf, "intf option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::intf::chains, "Chains over which the statistics are taken, can be multiple. Example: 'AEF'. If not given, takes statistics over unique chains in the PDB." );
option.add( basic::options::OptionKeys::mp::mp, "mp option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::thickness, "Thickness of the membrane used by the high resolution scoring function. Overwrites default thickness of 30A." );
option.add( basic::options::OptionKeys::mp::steepness, "Control transition region between polar and nonpoar phases for the membrane model used by the high resolution energy function. Default = 10 gives a 6A transition region." );
option.add( basic::options::OptionKeys::mp::center_start, "Starting point for center search. Example: 3 2 4." );
option.add( basic::options::OptionKeys::mp::center_delta, "Perturbation of center in Angstrom." );
option.add( basic::options::OptionKeys::mp::center_search_cycles, "Iterations for center search." );
option.add( basic::options::OptionKeys::mp::normal_start, "Base vector for normal search. Angles go off that vector." );
option.add( basic::options::OptionKeys::mp::normal_angle_start, "Starting angle from base vector for normal search. Degrees." );
option.add( basic::options::OptionKeys::mp::normal_angle_delta, "Perturbation of normal angle in degrees." );
option.add( basic::options::OptionKeys::mp::normal_search_cycles, "Number of iterations for normal search." );
option.add( basic::options::OptionKeys::mp::chain_normal_angle_max, "Maximum of normal angle wrt normal_start for chain embedding. Degrees." );
option.add( basic::options::OptionKeys::mp::pose_normal_angle_max, "Maximum of normal angle wrt normal_start for pose embedding. Degrees." );
option.add( basic::options::OptionKeys::mp::no_interpolate_Mpair, "from old code." );
option.add( basic::options::OptionKeys::mp::Hbond_depth_correction, "from old code." );
option.add( basic::options::OptionKeys::mp::TMprojection, "Penalty for hydrophobic mismatch on/off." );
option.add( basic::options::OptionKeys::mp::wt_TMprojection, "Weight for hydrophobic mismatch penalty." );
option.add( basic::options::OptionKeys::mp::non_helix, "Penalty for non-helix residues in the membrane on/off." );
option.add( basic::options::OptionKeys::mp::wt_non_helix, "Weight for non-helix penalty. " );
option.add( basic::options::OptionKeys::mp::termini, "Penalty for termini in the membrane on/off." );
option.add( basic::options::OptionKeys::mp::wt_termini, "Weight for termini penalty." );
option.add( basic::options::OptionKeys::mp::secstruct, "Penalty if structure-based secondary structure doesn't match predicted one - on/off" );
option.add( basic::options::OptionKeys::mp::wt_secstruct, "Weight for secondary structure penalty." );
option.add( basic::options::OptionKeys::mp::spanning, "Penalty if structure-based spanning doesn't match spanfile - on/off." );
option.add( basic::options::OptionKeys::mp::wt_spanning, "Weight for spanning penalty." );
option.add( basic::options::OptionKeys::mp::viewer::viewer, "viewer option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::viewer::thickness, "Thickness of membrane to visualize" ).def(15);
option.add( basic::options::OptionKeys::mp::viewer::num_points, "Number of points to define the membrane planes. x >= 3" );
option.add( basic::options::OptionKeys::mp::visualize::visualize, "visualize option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::visualize::embedding, "Visualize embedding centers and normals for each pose element" ).def(true);
option.add( basic::options::OptionKeys::mp::visualize::spacing, "Spacing of virtual membrane residues representing the membrane planes" ).def(5);
option.add( basic::options::OptionKeys::mp::visualize::width, "Width of membrane planes for n by n plane" ).def(100);
option.add( basic::options::OptionKeys::mp::visualize::thickness, "Thickness of membrane to visualize" ).def(15);
option.add( basic::options::OptionKeys::mp::visualize::plane_radius, "Radius of membrane planes to draw in PyMOL - part of the PyMOL viewer plugin" );
option.add( basic::options::OptionKeys::mp::scoring::scoring, "scoring option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::scoring::hbond, "Hydrogen bonding energy correction for membrane proteins" );
option.add( basic::options::OptionKeys::mp::setup::setup, "setup option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::setup::spanfiles, "Spanning topology file from Octopus" );
option.add( basic::options::OptionKeys::mp::setup::spans_from_structure, "Uses spanning topology computed from the PDB; requires the protein to be transformed into the membrane coordinate frame!" );
option.add( basic::options::OptionKeys::mp::setup::lipsfile, "List of lips files by chain" ).def("mypdb.lips4");
option.add( basic::options::OptionKeys::mp::setup::center, "membrane center x,y,z" );
option.add( basic::options::OptionKeys::mp::setup::normal, "membrane normal x,y,z" );
option.add( basic::options::OptionKeys::mp::setup::membrane_rsd, "membrane residue number" );
option.add( basic::options::OptionKeys::mp::setup::transform_into_membrane, "score_jd2: transform protein into fixed membrane before scoring; spanfile required" );
option.add( basic::options::OptionKeys::mp::setup::position_from_topo, "determine a membrane position from the transmembrane spans of the protein" );
option.add( basic::options::OptionKeys::mp::setup::optimize1, "Optimize position in membrane for partner 1 using membrane scorefunction." ).def(false);
option.add( basic::options::OptionKeys::mp::setup::optimize2, "Optimize position in membrane for partner 2 using membrane scorefunction." ).def(false);
option.add( basic::options::OptionKeys::mp::lipid_acc::lipid_acc, "lipid_acc option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::lipid_acc::angle_cutoff, "Cutoff for CA-CB-COM angle to identify lipid accessible residues, in degrees. <90 faces towards COM, >90 faces away from COM." ).def(65);
option.add( basic::options::OptionKeys::mp::lipid_acc::slice_width, "Width of the slice in Angstrom to compute hull." ).def(10.0);
option.add( basic::options::OptionKeys::mp::lipid_acc::shell_radius, "Radius of shell from outermost atoms that are still counted as boundary, i.e. how thick is lipid-exposed layer from the outside." ).def(5.0);
option.add( basic::options::OptionKeys::mp::lipid_acc::dist_cutoff, "Distances between boundary atoms longer than this cutoff (in 2D) will be cut in. Anything larger will be kept as boundary atoms." ).def(5.0);
option.add( basic::options::OptionKeys::mp::lipid_acc::tm_alpha, "Is the main secondary structure in the membrane helical?" ).def(true);
option.add( basic::options::OptionKeys::mp::transform::transform, "transform option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::transform::optimize_embedding, "Use the scorefunction to optimize the embedding after an initial coarse grained setting" );
option.add( basic::options::OptionKeys::mp::dock::dock, "dock option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::dock::weights_cen, "Scorefunction for low-resolution step." );
option.add( basic::options::OptionKeys::mp::dock::weights_fa, "Scorefunction for high-resolution step." );
option.add( basic::options::OptionKeys::mp::dock::lowres, "Use centroid score function for finding interface." );
option.add( basic::options::OptionKeys::mp::dock::allow_flips, "Allow partner 2 to flip in the membrane during global search. Default: yes." );
option.add( basic::options::OptionKeys::mp::dock::flexible_bb, "Do a flexible backbone docking: runs relax before and after docking." );
option.add( basic::options::OptionKeys::mp::dock::flexible_sc, "Do a flexible sidechain docking: repacks before and after docking." );
option.add( basic::options::OptionKeys::mp::dock::slide_threshold, "Theshold for scoreterm to define partner closeness in SlideIntoContact." );
option.add( basic::options::OptionKeys::mp::quickrelax::quickrelax, "quickrelax option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::quickrelax::angle_max, "Maximum allowed change in dihedral angles. Typical values around 1." );
option.add( basic::options::OptionKeys::mp::quickrelax::nmoves, "Number of moves allowed. Typical value is close to the number of residues in the protein: [nres] is allowed value. " );
option.add( basic::options::OptionKeys::mp::quickrelax::repack_again, "Do an additional round of sidechain repacking, simultaneously including all sidechains." );
option.add( basic::options::OptionKeys::mp::mutate_relax::mutate_relax, "mutate_relax option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::mutate_relax::mutation, "Single mutation: Format: One-letter code / residue number / one-letter code. Example: A163F" );
option.add( basic::options::OptionKeys::mp::mutate_relax::mutant_file, "Input file containing mutations" );
option.add( basic::options::OptionKeys::mp::mutate_relax::nmodels, "Number of models to produce per construct. Typically between 50 and 1,000." );
option.add( basic::options::OptionKeys::mp::mutate_relax::repack_mutation_only, "Boolean - Only repack the mutated residue(s), no relax." );
option.add( basic::options::OptionKeys::mp::mutate_relax::repack_radius, "Float - Repack within a radius of X Angstrom of the mutated residue(s)." );
option.add( basic::options::OptionKeys::mp::mutate_relax::relax, "Boolean - Do a full relax run with both backbone minimization and repacking." );
option.add( basic::options::OptionKeys::mp::benchmark::benchmark, "benchmark option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::benchmark::ideal_helix::ideal_helix, "ideal_helix option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::benchmark::ideal_helix::helix_start, "Start position for ideal helix dihedral angles" );
option.add( basic::options::OptionKeys::mp::benchmark::ideal_helix::helix_end, "End position for ideal helix dihedral angles" );
option.add( basic::options::OptionKeys::mp::benchmark::tilt_angle::tilt_angle, "tilt_angle option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::benchmark::tilt_angle::output, "Path to tilt angle vs. score output file" );
option.add( basic::options::OptionKeys::mp::output::output, "output option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mp::output::normalize_to_thk, "Output an additional MEM resdiue data in the PDB where the membrane normal is scaled to match the current membrane thickness (Makes sense for IMM Models" );
option.add( basic::options::OptionKeys::membrane::membrane, "membrane option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::membrane::normal_cycles, "number of membrane normal cycles" ).def(100);
option.add( basic::options::OptionKeys::membrane::normal_mag, "magnitude of membrane normal angle search (degrees)" ).def(5);
option.add( basic::options::OptionKeys::membrane::center_mag, "magnitude of membrane normal center search (Angstroms)" ).def(1);
option.add( basic::options::OptionKeys::membrane::smooth_move_frac, "No description" ).def(0.5);
option.add( basic::options::OptionKeys::membrane::no_interpolate_Mpair, "No description" ).def(false);
option.add( basic::options::OptionKeys::membrane::Menv_penalties, "No description" ).def(false);
option.add( basic::options::OptionKeys::membrane::Membed_init, "No description" ).def(false);
option.add( basic::options::OptionKeys::membrane::Fa_Membed_update, "No description" ).def(false);
option.add( basic::options::OptionKeys::membrane::center_search, "perform membrane center search" ).def(false);
option.add( basic::options::OptionKeys::membrane::normal_search, "perform membrane normal search" ).def(false);
option.add( basic::options::OptionKeys::membrane::center_max_delta, "magnitude of maximum membrane width deviation during membrane center search (Angstroms)" ).def(5);
option.add( basic::options::OptionKeys::membrane::normal_start_angle, "magnitude of starting angle during membrane normal search (degrees)" ).def(10);
option.add( basic::options::OptionKeys::membrane::normal_delta_angle, "magnitude of angle deviation during membrane normal search (degrees)" ).def(10);
option.add( basic::options::OptionKeys::membrane::normal_max_angle, "magnitude of maximum angle deviation during membrane normal search (degrees)" ).def(40);
option.add( basic::options::OptionKeys::membrane::debug, "No description" ).def(false);
option.add( basic::options::OptionKeys::membrane::fixed_membrane, "fix membrane position, by default the center is at [0,0,0] and membrane normal is the z-axis" ).def(false);
option.add( basic::options::OptionKeys::membrane::membrane_center, "membrane center x,y,z" );
option.add( basic::options::OptionKeys::membrane::membrane_normal, "membrane normal x,y,z" );
option.add( basic::options::OptionKeys::membrane::view, "viewing pose during protocol" ).def(false);
option.add( basic::options::OptionKeys::membrane::Mhbond_depth, "membrane depth dependent correction to the hbond potential" ).def(false);
option.add( basic::options::OptionKeys::membrane::thickness, "one leaflet hydrocarbon thickness for solvation calculations (Angstroms)" ).def(15);
option.add( basic::options::OptionKeys::mistakes::mistakes, "mistakes option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mistakes::restore_pre_talaris_2013_behavior, "Restore the set of defaults that were in place before the Talaris2013 parameters were made default.  This is an umbrella flag and sets the following flags if they are not set on the command line to some other value -mistakes::chemical::pre_talaris2013_geometries true -corrections::score::dun10 false -corrections::score::use_bicubic_interpolation false -corrections::score:hb_sp2_chipen false -corrections::score::hb_fade_energy false -corrections::score::hbond_measure_sp3acc_BAH_from_hvy false -corrections::score::lj_hbond_hdis 1.95 -corrections::score::lj_hbond_OH_donor_dis 3.0 -corrections::chemical::expand_st_chi2sampling false -score::weights pre_talaris_2013_standard.wts -score::patch score12.wts_patch -score::analytic_etable_evaluation false -score::hbond_params score12_params -score::smooth_fa_elec false -score::elec_min_dis 1.5 -chemical::set_atom_properties fa_standard:ONH2:LK_DGFREE:-10.0 fa_standard:NH2O:LK_DGFREE:-10.0 fa_standard:Narg:LK_DGFREE:-11.0 fa_standard:OH:LK_DGFREE:-6.77" ).def(false);
option.add( basic::options::OptionKeys::mistakes::chemical::chemical, "chemical option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mistakes::chemical::pre_talaris2013_geometries, "Use the version of the fa_standard geometries that were active before the Talaris2013 parameters were taken as default" ).def(false);
option.add( basic::options::OptionKeys::MonteCarlo::MonteCarlo, "MonteCarlo option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::MonteCarlo::temp_initial, "initial temperature for Monte Carlo considerations" ).lower(0.001).def(2);
option.add( basic::options::OptionKeys::MonteCarlo::temp_final, "final temperature for Monte Carlo considerations" ).lower(0.001).def(0.6);
option.add( basic::options::OptionKeys::optimization::optimization, "optimization option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::optimization::default_max_cycles, "max cycles for MinimizerOptions" ).def(2000);
option.add( basic::options::OptionKeys::optimization::armijo_min_stepsize, "min stepsize in armijo minimizer" ).def(1e-8);
option.add( basic::options::OptionKeys::optimization::scale_normalmode_dampen, "dampening scale over normal mode index, used for NormalModeMinimizer" ).def(0.05);
option.add( basic::options::OptionKeys::optimization::lbfgs_M, "number of corrections to approximate the inverse hessian matrix." ).def(128);
option.add( basic::options::OptionKeys::optimization::scale_d, "max cycles for MinimizerOptions" ).def(1);
option.add( basic::options::OptionKeys::optimization::scale_theta, "max cycles for MinimizerOptions" ).def(1);
option.add( basic::options::OptionKeys::optimization::scale_rb, "max cycles for MinimizerOptions" ).def(10);
option.add( basic::options::OptionKeys::optimization::scale_rbangle, "max cycles for MinimizerOptions" ).def(1);
option.add( basic::options::OptionKeys::optimization::scmin_nonideal, "Do we allow sidechain nonideality during scmin (e.g. rtmin and min_pack)" ).def(false);
option.add( basic::options::OptionKeys::optimization::scmin_cartesian, "Toggle Cartesian-space minimization during scmin (e.g. rmin and min_pack)" ).def(false);
option.add( basic::options::OptionKeys::optimization::nonideal, "Permit bond geometries to vary from ideal values" ).def(false);
option.add( basic::options::OptionKeys::optimization::old_sym_min, "Use the old approach to symmetric minimization" ).def(false);
option.add( basic::options::OptionKeys::optimization::debug_inaccurate_G, "Debug innacurate G messages" ).def(false);
option.add( basic::options::OptionKeys::orbitals::orbitals, "orbitals option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::orbitals::Hpol, "look at only polar hydrogen interactions" ).def(false);
option.add( basic::options::OptionKeys::orbitals::Haro, "look at only aromatic hydrogen interactions" ).def(false);
option.add( basic::options::OptionKeys::orbitals::bb_stats, "look at orbital backbone stats" ).def(false);
option.add( basic::options::OptionKeys::orbitals::sc_stats, "look at orbital sc stats" ).def(false);
option.add( basic::options::OptionKeys::pose_metrics::pose_metrics, "pose_metrics option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::pose_metrics::atomic_burial_cutoff, " maximum SASA that is allowed for an atom to count as buried for the BuriedUnsatisfiedPolarsCalculator" ).def(0.3);
option.add( basic::options::OptionKeys::pose_metrics::sasa_calculator_probe_radius, " the probe radius used in the SASA calculator (and thus implicitly in the BuriedUnsatisfiedPolarsCalculator" ).def(1.4);
option.add( basic::options::OptionKeys::pose_metrics::interface_cutoff, "distance in angstroms (def. 10.0) for calculating what residues are at an interface via InterfaceNeighborDefinitionCalculator" ).def(10.0);
option.add( basic::options::OptionKeys::pose_metrics::min_sequence_separation, " minimum number of sequence positions that two residues need to be apart to count as nonlocal in the NonlocalContactsCalculator" ).def(6);
option.add( basic::options::OptionKeys::pose_metrics::contact_cutoffE, " maximum interaction energy allowed between two residues to count as a contact in the NonlocalContactsCalculator" ).def(-1.0);
option.add( basic::options::OptionKeys::pose_metrics::neighbor_by_distance_cutoff, "distance in angstroms (def. 10.0) for calculating neighbors of a residue via NeighborByDistanceCalculator" ).def(10.0);
option.add( basic::options::OptionKeys::pose_metrics::inter_group_neighbors_cutoff, "distance in angstroms (def. 10.0) for calculating interfaces between domains with InterGroupNeighborsCalculator" ).def(10.0);
option.add( basic::options::OptionKeys::pose_metrics::semiex_water_burial_cutoff, "water hbond states fraction cutiff for SemiExplicitWaterUnsatisfiedPolarsCalculator (0.0,1.0)" ).def(0.25);
option.add( basic::options::OptionKeys::pose_metrics::shobuns::shobuns, "shobuns option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::pose_metrics::shobuns::tgt_amino, "Target amino acid type" ).def("_none_");
option.add( basic::options::OptionKeys::pose_metrics::shobuns::tgt_atom, "Target atom name" ).def("_none_");
option.add( basic::options::OptionKeys::pose_metrics::shobuns::tgt_res, "File specifying a subset of target residues" ).def("");
option.add( basic::options::OptionKeys::pose_metrics::shobuns::sho_cutoff, "max SHO value for an atom to be considered solvent exposed" ).def(4.9);
option.add( basic::options::OptionKeys::rigid::rigid, "rigid option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rigid::chainbreak_bias, "Strength of bias applied to the translation component of rigid body moves to close chainbreak" ).def(0.00);
option.add( basic::options::OptionKeys::rigid::close_loops, "Perform loop closure at the end of medal" ).def(true);
option.add( basic::options::OptionKeys::rigid::fragment_cycles, "Number of fragment insertion/rigid body cycles" ).def(10000);
option.add( basic::options::OptionKeys::rigid::log_accepted_moves, "Write accepted moves to silent file output" ).def(false);
option.add( basic::options::OptionKeys::rigid::max_ca_ca_dist, "Maximum distance between consecutive CA atoms before chunk partitioning occurs" ).def(5.0);
option.add( basic::options::OptionKeys::rigid::patch, "Patch file containing energy terms and their respective weights" );
option.add( basic::options::OptionKeys::rigid::residues_backbone_move, "Number of residues perturbed by a backbone move" ).def(5);
option.add( basic::options::OptionKeys::rigid::rotation, "Rotation magnitude" ).def(2.5);
option.add( basic::options::OptionKeys::rigid::sampling_prob, "Normalized, per-residue sampling probabilities" );
option.add( basic::options::OptionKeys::rigid::score, "Centroid-level score function" ).def("score3");
option.add( basic::options::OptionKeys::rigid::sequence_separation, "Maximum sequence separation for scoring chainbreaks" ).def(20);
option.add( basic::options::OptionKeys::rigid::small_cycles, "Number of small/shear cycles" ).def(8000);
option.add( basic::options::OptionKeys::rigid::stages, "Number of stages over which to interpolate ramped values" ).def(4);
option.add( basic::options::OptionKeys::rigid::temperature, "Monte Carlo temperature" ).def(2.0);
option.add( basic::options::OptionKeys::rigid::translation, "Translation magnitude" ).def(0.5);
option.add( basic::options::OptionKeys::sasa::sasa, "sasa option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::sasa::method, "The method used to calculate sasa.  More will hopefully be added in the future." ).legal("LeGrand").def("LeGrand");
option.add( basic::options::OptionKeys::sasa::include_hydrogens_explicitly, "Include hydrogens explicitly in the calculation.  Explicit vs implicit calculations use different radii sets.  These default sets can be controlled via cmd line.  Historically, calculations included hydrogens implicitly.  Some protocols may overwrite this setting to their needs." ).def(true);
option.add( basic::options::OptionKeys::sasa::probe_radius, "Probe radius used by SasaCalc.  Default is radius of water.  1.2 is also commonly used." ).def(1.4);
option.add( basic::options::OptionKeys::sasa::include_probe_radius_in_atom_radii, "This is typically done in calculation of SASA, and in fact is one of the defining features of SASA.  Turn this off to calculate the Surface Area instead." ).def(true);
option.add( basic::options::OptionKeys::sasa::include_only_C_S_in_hsasa, "Include only carbon or sulfer in hsasa calculation.  This is typical.  Only revert to false if excluding polar atoms by charge or everything will be counted as hydrophobic. Note hydrogens are dealt with automatically." ).def(true);
option.add( basic::options::OptionKeys::sasa::exclude_polar_atoms_by_charge_in_hsasa, "Polar carbons and other atoms should not be included in hydrophobic hSASA - though historically they were.  Set this to false to get historic hsasa" ).def(false);
option.add( basic::options::OptionKeys::sasa::polar_charge_cutoff, "Charge cutoff (abs value) to use on heavy atoms if excluding hydrophobic atoms from hSASA calculation by charge. The default is optimized for protein atom types (which excludes only carbonyl and carboxyl carbons.  By default only carbon and sulfer are excluded." ).def(.4);
option.add( basic::options::OptionKeys::sasa::implicit_hydrogen_radii_set, "The radii set to use when including hydrogens implicitly instead of explicitly. Chothia 1976 radii are used by the program Naccess.  chothia=naccess" ).legal("chothia").legal("naccess").def("chothia");
option.add( basic::options::OptionKeys::sasa::explicit_hydrogen_radii_set, "The radii set to use when including hydrogens explicitly. Default is reduce, which was generally agreed upon at Minicon 2014 and come from original data from Bondi (1964) and Gavezzotti (1983) .  LJ are the Rosetta leonard-jones radii, which are not quite exactly from Charmm.  Legacy radii were optimized for a no-longer-in-Rosetta scoreterm (Jerry Tsai et al 2003)" ).legal("reduce").legal("LJ").legal("legacy").def("reduce");
option.add( basic::options::OptionKeys::symmetry::symmetry, "symmetry option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::symmetry::symmetry_definition, "Text file describing symmetry setup" );
option.add( basic::options::OptionKeys::symmetry::reweight_symm_interactions, "Scale intersubunit interactions by a specified weight" ).def(1.0);
option.add( basic::options::OptionKeys::symmetry::initialize_rigid_body_dofs, "Initialize the RB dofs from the symmetry definition file?" ).def(false);
option.add( basic::options::OptionKeys::symmetry::detect_bonds, "allow new cross subunit bond formation" ).def(true);
option.add( basic::options::OptionKeys::symmetry::perturb_rigid_body_dofs, "(As in docking) Do a small perturbation of the symmetric DOFs: -perturb_rigid_body_dofs ANGSTROMS DEGREES" ).n(2);
option.add( basic::options::OptionKeys::symmetry::symmetric_rmsd, "calculate the rmsd symmetrically by checking all chain orderings" );
option.add( basic::options::OptionKeys::abinitio::abinitio, "Ab initio mode" ).is_group(true);
option.add( basic::options::OptionKeys::abinitio::membrane, "will use the membrane abinitio protocol. sequential insertion of TMH" ).def(false);
option.add( basic::options::OptionKeys::abinitio::use_loophash_filter, "use loophash filter to determine if SSEs too far away" );
option.add( basic::options::OptionKeys::abinitio::loophash_filter_acceptance_rate, "fraction at which want to accept poses from loophash filter if no loophash hits found" );
option.add( basic::options::OptionKeys::abinitio::kill_hairpins, "setup hairpin killing in score (kill hairpin file or psipred file)" );
option.add( basic::options::OptionKeys::abinitio::kill_hairpins_frequency, "automated hairpin killing frequency (for use with psipred file)" ).def(0.2);
option.add( basic::options::OptionKeys::abinitio::smooth_cycles_only, "Only smooth cycles in abinitio protocol" ).def(false);
option.add( basic::options::OptionKeys::abinitio::relax, "Do a relax after abinitio = abrelax ?" );
option.add( basic::options::OptionKeys::abinitio::final_clean_relax, "Do a final relax without constraints" );
option.add( basic::options::OptionKeys::abinitio::fastrelax, "Do a fastrelax after abinitio = abfastrelax ?" );
option.add( basic::options::OptionKeys::abinitio::multifastrelax, "Do a fastrelax after abinitio = abfastrelax ?" );
option.add( basic::options::OptionKeys::abinitio::debug, "No description" ).def(false);
option.add( basic::options::OptionKeys::abinitio::clear_pose_cache, "always clear extra-scores away before output" ).def(false);
option.add( basic::options::OptionKeys::abinitio::explicit_pdb_debug, "always dump pdb (not silent ) files during abinitio stages" ).def(false);
option.add( basic::options::OptionKeys::abinitio::use_filters, "use RG, contact-order and sheet filters " ).def(false);
option.add( basic::options::OptionKeys::abinitio::increase_cycles, "Increase number of cycles at each stage of fold_abinitio (or pose_abinitio) by this factor" ).lower(0.001).def(1.0);
option.add( basic::options::OptionKeys::abinitio::jMetal_strategy, "Specifies search strategy and parameters to use - Maria 8/05/2017" ).def("ROSETTA");

}
inline void add_rosetta_options_5( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::abinitio::number_3mer_frags, "Number of top 3mer fragments to use in fold_abinitio protocol" ).lower(0).def(200);
option.add( basic::options::OptionKeys::abinitio::number_9mer_frags, "Number of top 9mer fragments to use in fold_abinitio protocol" ).lower(0).def(25);
option.add( basic::options::OptionKeys::abinitio::temperature, "Temperature used in fold_abinitio" ).def(2.0);
option.add( basic::options::OptionKeys::abinitio::rg_reweight, "Reweight contribution of radius of gyration to total score by this scale factor" ).def(1.0);
option.add( basic::options::OptionKeys::abinitio::rsd_wt_helix, "Reweight env,pair,cb for helix residues by this factor" ).def(1.0);
option.add( basic::options::OptionKeys::abinitio::rsd_wt_strand, "Reweight env,pair,cb for strand residues by this factor" ).def(1.0);
option.add( basic::options::OptionKeys::abinitio::rsd_wt_loop, "Reweight env,pair,cb for loop residues by this factor" ).def(1.0);
option.add( basic::options::OptionKeys::abinitio::skip_convergence_check, "this option turns off the convergence check in stage3 (score 2/5)" );
option.add( basic::options::OptionKeys::abinitio::stage1_patch, "Name of weights patch file (without extension .wts) to use during stage1 abinitio" );
option.add( basic::options::OptionKeys::abinitio::stage2_patch, "Name of weights patch file (without extension .wts) to use during stage2 abinitio" );
option.add( basic::options::OptionKeys::abinitio::stage3a_patch, "Name of weights patch file (without extension .wts) to use during stage3a abinitio" );
option.add( basic::options::OptionKeys::abinitio::stage3b_patch, "Name of weights patch file (without extension .wts) to use during stage3b abinitio" );
option.add( basic::options::OptionKeys::abinitio::stage4_patch, "Name of weights patch file (without extension .wts) to use during stage4 abinitio" );
option.add( basic::options::OptionKeys::abinitio::stage5_patch, "Name of weights patch file (without extension .wts) to use during stage5 abinitio" );
option.add( basic::options::OptionKeys::abinitio::steal_3mers, "stealing: use 3mers from native" ).def(false);
option.add( basic::options::OptionKeys::abinitio::steal_9mers, "stealing: use 9mers from native" ).def(false);
option.add( basic::options::OptionKeys::abinitio::no_write_failures, "dont write failed structures to silent-out" ).def(false);
option.add( basic::options::OptionKeys::abinitio::relax_failures, "relax failures anyway" ).def(false);
option.add( basic::options::OptionKeys::abinitio::relax_with_jumps, "switch to allow relax even if loops are not closed " ).def(false);
option.add( basic::options::OptionKeys::abinitio::process_store, "run process_decoy on each structure in the structure store" ).def(false);
option.add( basic::options::OptionKeys::abinitio::fix_residues_to_native, "these residues torsions are copied from native and fixed" ).def(0);
option.add( basic::options::OptionKeys::abinitio::return_full_atom, "return a full-atom structure even if no relax is done" ).def(false);
option.add( basic::options::OptionKeys::abinitio::detect_disulfide_before_relax, "run detect_disulfides() before relax" ).def(false);
option.add( basic::options::OptionKeys::abinitio::close_loops, "close loops" ).def(false);
option.add( basic::options::OptionKeys::abinitio::bGDT, "compute gdtmmm" ).def(true);
option.add( basic::options::OptionKeys::abinitio::dump_frags, "for control purposes... dump fragments" ).def(false);
option.add( basic::options::OptionKeys::abinitio::jdist_rerun, "go through intput structures and evaluate ( pca, rmsd, cst-energy )" ).def(false);
option.add( basic::options::OptionKeys::abinitio::perturb, "add some perturbation (gaussian) to phi/psi of native" ).def(0.0);
option.add( basic::options::OptionKeys::abinitio::rerun, "go through intput structures and evaluate ( pca, rmsd, cst-energy )" ).def(false);
option.add( basic::options::OptionKeys::abinitio::rmsd_residues, "give start and end residue for rmsd calcul." ).def(-1);
option.add( basic::options::OptionKeys::abinitio::start_native, "start from native structure (instead of extended)" ).def(false);
option.add( basic::options::OptionKeys::abinitio::cyclic_peptide, "set up cyclic peptide (N-to-C cyclization) constraints for abinitio runs" ).def(false);
option.add( basic::options::OptionKeys::abinitio::debug_structures, "write structures to debug-out files" ).def(false);
option.add( basic::options::OptionKeys::abinitio::log_frags, "fragment insertions (each trial) will be logged to file" ).def("");
option.add( basic::options::OptionKeys::abinitio::only_stage1, "useful for benchmarks sets cycle of all higher stages to 0" ).def(false);
option.add( basic::options::OptionKeys::abinitio::end_bias, "set the endbias for Fragment moves" ).def(30.0);
option.add( basic::options::OptionKeys::abinitio::apply_end_bias, "eliminate the endbias for Fragment moves" ).def(true);
option.add( basic::options::OptionKeys::abinitio::symmetry_residue, "hacky symmetry mode for dimers, fragments are inserted at i and i + SR - 1" ).def(-1);
option.add( basic::options::OptionKeys::abinitio::vdw_weight_stage1, "vdw weight in stage1" ).def(1.0);
option.add( basic::options::OptionKeys::abinitio::override_vdw_all_stages, "apply vdw_weight_stage1 for all stages" ).def(false);
option.add( basic::options::OptionKeys::abinitio::recover_low_in_stages, "say default: 2 3 4 recover_low happens in stages 2 3 4" ).def(0);
option.add( basic::options::OptionKeys::abinitio::skip_stages, "say: 2 3 4, and it will skip stages 2 3 4" ).def(0);
option.add( basic::options::OptionKeys::abinitio::close_chbrk, "Chain break closure during classic abinito " ).def(false);
option.add( basic::options::OptionKeys::abinitio::include_stage5, "stage5 contains small moves only" ).def(false);
option.add( basic::options::OptionKeys::abinitio::close_loops_by_idealizing, "close loops by idealizing the structure after stage 4" ).def(false);
option.add( basic::options::OptionKeys::abinitio::optimize_cutpoints_using_kic, "optimize around cutpoints using kinematic relax" ).def(false);
option.add( basic::options::OptionKeys::abinitio::optimize_cutpoints_margin, "" ).def(5);
option.add( basic::options::OptionKeys::abinitio::star::star, "star option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::abinitio::star::initial_dist_cutoff, "Maximum distance cutoff for restraints that constrain aligned residues to their initial positions" ).def(8.0);
option.add( basic::options::OptionKeys::abinitio::star::min_unaligned_len, "Minimum length of an unaligned region" ).def(3);
option.add( basic::options::OptionKeys::abrelax::abrelax, "ab initio relax mode" ).is_group(true);
option.add( basic::options::OptionKeys::abrelax::fail_unclosed, "structures which don't close loops are reported as FAIL_DO_NOT_RETRY" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::AnchoredDesign, "AnchoredDesign option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::AnchoredDesign::anchor, "anchor specification file" ).def("anchor");
option.add( basic::options::OptionKeys::AnchoredDesign::allow_anchor_repack, "allow repacking of anchor (default is to prevent)" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::vary_cutpoints, "vary loop cutpoints.  Picks new cutpoints at start of each nstruct" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::no_frags, "use no fragments.  Overrides passing an old-style fragment file.  Skips new-style fragment generation." ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::debug, "debug mode (extra checks and pdb dumps)" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::show_extended, "dump pre-perturb PDB to check if loop torsions are extended and/or sequence is fuzzed; debugging only" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::refine_only, "refine only mode (skip perturbation step)" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::perturb_show, "dump perturbed centroid pdbs as well as final results" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::perturb_cycles, "perturbation phase runs for <input> cycles" ).def(5);
option.add( basic::options::OptionKeys::AnchoredDesign::perturb_temp, "perturbation phase temperature for monte carlo" ).def(0.8);
option.add( basic::options::OptionKeys::AnchoredDesign::perturb_CCD_off, "CCD-style loop remodeling off in perturb phase (meaning, KIC only)" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::perturb_KIC_off, "KIC-style loop remodeling off in perturb phase (meaning, CCD only)" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::refine_CCD_off, "CCD-style loop remodeling off in refine phase (meaning, KIC only)" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::refine_KIC_off, "KIC-style loop remodeling off in refine phase (meaning, CCD only)" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::refine_cycles, "refinement phase runs for <input> cycles" ).def(5);
option.add( basic::options::OptionKeys::AnchoredDesign::refine_temp, "refinement phase temperature for monte carlo" ).def(0.8);
option.add( basic::options::OptionKeys::AnchoredDesign::refine_repack_cycles, "refinement phase runs repack every <input> cycles" ).lower(2).def(20);
option.add( basic::options::OptionKeys::AnchoredDesign::rmsd, "Calculate result structure CA RMSD from starting structure" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::unbound_mode, "Ignore the anchor, as if this were loop modeling" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::chainbreak_weight, "Chainbreak term weight" ).def(2.0);
option.add( basic::options::OptionKeys::AnchoredDesign::filters::filters, "filters option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::AnchoredDesign::filters::score, "do not print trajectories with scores greater than this total scorefunction value" ).def(0);
option.add( basic::options::OptionKeys::AnchoredDesign::filters::sasa, "do not print trajectories with sasas less than this interface delta sasa value" ).def(500);
option.add( basic::options::OptionKeys::AnchoredDesign::filters::omega, "filter out non-trans omegas" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::akash::akash, "akash option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::AnchoredDesign::akash::dyepos, "dye position" ).def(0);
option.add( basic::options::OptionKeys::AnchoredDesign::testing::testing, "testing option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::AnchoredDesign::testing::VDW_weight, "centroid VDW weight; testing if 2 better than 1" ).lower(0).def(1.0);
option.add( basic::options::OptionKeys::AnchoredDesign::testing::anchor_via_constraints, "allow anchor&jump to move; anchor held in place via constraints - you must specify constraints!" ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::testing::delete_interface_native_sidechains, "benchmarking option.  delete input sidechains as prepacking step before running centroid or fullatom phases.  use if also using use_input_sc and doing benchmarking.  use_input_sc is used because of sidechain minimization, not to maintain input sidechains." );
option.add( basic::options::OptionKeys::AnchoredDesign::testing::RMSD_only_this, "Perform only RMSD calculations without modifying input.  Only used for re-running metrics during benchmarking/debugging." );
option.add( basic::options::OptionKeys::AnchoredDesign::testing::anchor_noise_constraints_mode, "Hold the anchor loosely (via constraints), not rigidly.  Automatically generate the constraints from the starting pose.  Mildly randomize the anchor's placement before modeling (up to 1 angstrom in x,y,z from initial placement.)  Only compatible with single-residue anchors.  Used to meet a reviewer's commentary." ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::testing::super_secret_fixed_interface_mode, "hold the anchor-containing loop fixed.  Currently in testing." ).def(false);
option.add( basic::options::OptionKeys::AnchoredDesign::testing::randomize_input_sequence, "randomizes the input sequence by packing with a null scorefunction; uses the AnchoredDesign-specified packer task (obeys resfile, etc)." ).def(false);
option.add( basic::options::OptionKeys::antibody::antibody, "Antibody option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::antibody::input_ab_scheme, "The numbering scheme of the PDB file." ).legal("Chothia").legal("Enhanced_Chothia").legal("AHo").legal("AHOIMGT").legal("Kabat").legal("Chothia_Scheme").legal("Enhanced_Chothia_Scheme").legal("AHo_Scheme").legal("AHO_Scheme").legal("IMGT_Scheme").legal("Kabat_Scheme").def("Chothia_Scheme");
option.add( basic::options::OptionKeys::antibody::output_ab_scheme, "Output numbering scheme supported by most antibody apps that output pdbs.  Please see documentation." ).legal("Chothia").legal("Enhanced_Chothia").legal("AHo").legal("AHOIMGT").legal("Kabat").legal("Chothia_Scheme").legal("Enhanced_Chothia_Scheme").legal("AHo_Scheme").legal("AHO_Scheme").legal("IMGT_Scheme").legal("Kabat_Scheme").def("Chothia_Scheme");
option.add( basic::options::OptionKeys::antibody::cdr_definition, "The CDR definition to use.  Current Options are: Chothia, Aroop, North, Kabat, Martin" ).def("Aroop");
option.add( basic::options::OptionKeys::antibody::light_chain, "Type of light chain if known.  Only used for design for now." ).legal("unknown").legal("lambda").legal("kappa").def("unknown");
option.add( basic::options::OptionKeys::antibody::check_cdr_chainbreaks, "Check CDRs of input antibody for chainbreaks upon initializing RosettaAntibody and RosettaAntibodyDesign.  Chainbreaks found will result in the model not proceeding. A peptide bond in the loop is considered broken if its C-N bond is > 2.0 A" ).def(true);
option.add( basic::options::OptionKeys::antibody::check_cdr_pep_bond_geom, "Check CDRs of input antibody for bad peptide bond geometry.  This checks Ca-C-N and C-N-Ca bond angles for -large- deviations from the min max values found in a recent analysis of protein geometry  - Conformation dependence of backbone geometry in proteins. Structure -.  If found, the model will not proceed.  Use FastRelax with bond angle min to fix issues.  These issues usually arise from poorly resolved crystal loops or incorrectly solved structures.  Many older antibody structures have some of these issues." ).def(false);
option.add( basic::options::OptionKeys::antibody::numbering_scheme, "Deprecated Numbering Scheme option" ).def("Chothia_Scheme");
option.add( basic::options::OptionKeys::antibody::graft_l1, "Graft CDR L1 from template" ).def(false);
option.add( basic::options::OptionKeys::antibody::l1_template, "Choose specified template for CDR L1 grafting" ).def("l1.pdb");
option.add( basic::options::OptionKeys::antibody::graft_l2, "Graft CDR L2 from template" ).def(false);
option.add( basic::options::OptionKeys::antibody::l2_template, "Choose specified template for CDR L2 grafting" ).def("l2.pdb");
option.add( basic::options::OptionKeys::antibody::graft_l3, "Graft CDR L3 from template" ).def(false);
option.add( basic::options::OptionKeys::antibody::l3_template, "Choose specified template for CDR L3 grafting" ).def("l3.pdb");
option.add( basic::options::OptionKeys::antibody::graft_h1, "Graft CDR H1 from template" ).def(false);
option.add( basic::options::OptionKeys::antibody::h1_template, "Choose specified template for CDR H1 grafting" ).def("h1.pdb");
option.add( basic::options::OptionKeys::antibody::graft_h2, "Graft CDR H2 from template" ).def(false);
option.add( basic::options::OptionKeys::antibody::h2_template, "Choose specified template for CDR H2 grafting" ).def("h2.pdb");
option.add( basic::options::OptionKeys::antibody::graft_h3, "Graft CDR H3 from template" ).def(false);
option.add( basic::options::OptionKeys::antibody::h3_template, "Choose specified template for CDR H3 grafting" ).def("h3.pdb");
option.add( basic::options::OptionKeys::antibody::light_heavy_template, "Choose specified template for VL-VH orientation" ).def("");
option.add( basic::options::OptionKeys::antibody::frl_template, "Choose specified template for light chain framework" ).def("");
option.add( basic::options::OptionKeys::antibody::frh_template, "Choose specified template for heavy chain framework" ).def("");
option.add( basic::options::OptionKeys::antibody::h3_no_stem_graft, "Graft CDR H3 from template, use stem to superimpose, but do not copy the stem" ).def(false);
option.add( basic::options::OptionKeys::antibody::packonly_after_graft, "Only do packing after grafting, do not do minimization" ).def(false);
option.add( basic::options::OptionKeys::antibody::stem_optimize, "turn on/off the option to optimize the grafted stems" ).def(true);
option.add( basic::options::OptionKeys::antibody::stem_optimize_size, " define the size of the stem to optimize " ).def(4);
option.add( basic::options::OptionKeys::antibody::preprocessing_script_version, "Rosetta 2 using Perl script has errors for grafting" ).def("R3_Python");
option.add( basic::options::OptionKeys::antibody::model_h3, "Model CDR H3 from scratch using fragments" ).def(false);
option.add( basic::options::OptionKeys::antibody::snugfit, "Adjust relative orientation of VL-VH" ).def(false);
option.add( basic::options::OptionKeys::antibody::refine_h3, "Refine CDR H3 in high resolution" ).def(true);
option.add( basic::options::OptionKeys::antibody::h3_filter, "filter decoys having neither kink nor extend form" ).def(true);
option.add( basic::options::OptionKeys::antibody::h3_filter_tolerance, "maximum number of tries for the filter" ).def(5);
option.add( basic::options::OptionKeys::antibody::cter_insert, "insert kind or extend Ab fragments to CDR H3" ).def(true);
option.add( basic::options::OptionKeys::antibody::flank_residue_min, "minimize flank residues of CDR H3 during high-reso refinement" ).def(true);
option.add( basic::options::OptionKeys::antibody::sc_min, "minimize the side chain after finishing the rotamer packing" ).def(false);
option.add( basic::options::OptionKeys::antibody::rt_min, "minimize the rotamer each packing" ).def(false);
option.add( basic::options::OptionKeys::antibody::bad_nter, "the n-terminal is bad because of bad H3 grafting" ).def(true);
option.add( basic::options::OptionKeys::antibody::extend_h3_before_modeling, "extend the H3 to forget the intial H3 configuration" ).def(true);
option.add( basic::options::OptionKeys::antibody::idealize_h3_stems_before_modeling, "idealize the H3 stem, H3 grafting does not copy the coordinates which makes the grafting bad " ).def(true);
option.add( basic::options::OptionKeys::antibody::remodel, "Choose a perturb method to model H3 in centroid mode" ).def("legacy_perturb_ccd");
option.add( basic::options::OptionKeys::antibody::refine, "Choose a refine method to model H3 in high-resol model" ).def("legacy_perturb_ccd");
option.add( basic::options::OptionKeys::antibody::centroid_refine, "Choose a refine method to refine a loop in centroid mode" ).def("refine_kic");
option.add( basic::options::OptionKeys::antibody::constrain_cter, "The option to turn on/off the cterminal constrain penalty in loop scoring function" ).def(false);
option.add( basic::options::OptionKeys::antibody::constrain_vlvh_qq, "The option to turn on/off the VL-VH QQ H-bond in docking scoring function" ).def(false);
option.add( basic::options::OptionKeys::antibody::auto_generate_kink_constraint, "Generate the kink constraint on-the-fly" ).def(false);
option.add( basic::options::OptionKeys::antibody::all_atom_mode_kink_constraint, "Enable the kink constraint in the all-atom phase of the simulation" ).def(false);
option.add( basic::options::OptionKeys::antibody::snug_loops, "Allow CDR loop backbone flexibility during minimization" ).def(false);
option.add( basic::options::OptionKeys::antibody::input_fv, "input antibody variable (Fv) region" ).def("FR02.pdb");
option.add( basic::options::OptionKeys::antibody::camelid, "Camelid input with only heavy (VH) chain" ).def(false);
option.add( basic::options::OptionKeys::antibody::camelid_constraints, "Display constraints file for use with camelid H3 modeler" ).def(false);
option.add( basic::options::OptionKeys::antibody::use_mean_cluster_cst_data, "Use CDR Dihedral cluster-based constraints which have the means as the actual cluster means.  Setting this to false will use constraints that have the means set as cluster center data." ).def(true);
option.add( basic::options::OptionKeys::antibody::force_use_of_cluster_csts_with_outliers, "Force the use of cluster dihedral constraints to use ones with outliers." ).def(false);
option.add( basic::options::OptionKeys::antibody::cluster_csts_stats_cutoff, "Value for cluster-based dihedral csts -> general dihedral csts switch.  If number of total structures used for cluster-based constraints is less than this value, general dihedral constraints will be used.  More data = better predictability." ).def(10);
option.add( basic::options::OptionKeys::antibody::general_dihedral_cst_phi_sd, "Standard deviation to use for phi while using general dihedral circular harmonic constraints" ).def(16.0);
option.add( basic::options::OptionKeys::antibody::general_dihedral_cst_psi_sd, "Standard deviation to use for psi while using general dihedral circular harmonic constraints" ).def(16.0);
option.add( basic::options::OptionKeys::antibody::allow_omega_mismatches_for_north_clusters, "Skip first grouping Cis and Trans for clusters in which a Cis/Trans designation currently does not exist." ).def(false);
option.add( basic::options::OptionKeys::antibody::prefix, "Base/dir name prefix for antibody grafting output, split on /. By default this is grafting/." ).def("grafting/");
option.add( basic::options::OptionKeys::antibody::grafting_database, "Path to the Antibody Grafting Database from Rosetta tools repository. By default this option is empty and grafting_database is looked at ../../tools/antibody and then $ROSETTA/tools/antibody" ).def("");
option.add( basic::options::OptionKeys::antibody::blastp, "Path to NCBI-Blast+ executable" ).def("blastp");
option.add( basic::options::OptionKeys::antibody::exclude_homologs, "Filter BLAST matches by sequence identity? (false by default)" ).def(false);
option.add( basic::options::OptionKeys::antibody::exclude_homologs_cdr_cutoff, "Sequence identity cutoff for complementarity determining regions (80 percent is default)." ).def(80.0);
option.add( basic::options::OptionKeys::antibody::exclude_homologs_fr_cutoff, "Sequence identity cutoff for framework regions (80 percent is default)." ).def(80.0);
option.add( basic::options::OptionKeys::antibody::ocd_cutoff, "Orientational coordinate distance cutoff for templates. Introduces diversity when using multi-template grafting (0.5 is default)." ).def(0.5);
option.add( basic::options::OptionKeys::antibody::n_multi_templates, "Number of multiple templates to use during grafting. Default is 10." ).def(10);
option.add( basic::options::OptionKeys::antibody::design::design, "design option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::antibody::design::base_cdr_instructions, "The Default/Baseline instructions file. Should not need to be changed." ).def("/sampling/antibodies/design/default_instructions.txt");
option.add( basic::options::OptionKeys::antibody::design::cdr_instructions, "Path to CDR Instruction File" );
option.add( basic::options::OptionKeys::antibody::design::antibody_database, "Path to the current Antibody Database, updated weekly.  Download from http://dunbrack2.fccc.edu/PyIgClassify/ " ).def("/sampling/antibodies/antibody_database_rosetta_design.db");
option.add( basic::options::OptionKeys::antibody::design::paper_ab_db, "Force the use the Antibody Database with data from the North clustering paper.  This is included in Rosetta. If a newer antibody database is not found, we will use this. The full ab db is available at http://dunbrack2.fccc.edu/PyIgClassify/" ).def(false);
option.add( basic::options::OptionKeys::antibody::design::paper_ab_db_path, "Path to the North paper ab_db path.  Only used if -paper_ab_db option is passed" ).def("/sampling/antibodies/antibody_database_rosetta_design_north_paper.db");
option.add( basic::options::OptionKeys::antibody::design::design_cdrs, "Design these CDRs in graft and sequence design steps.  Use to override instructions file" ).legal("L1").legal("L2").legal("L3").legal("H1").legal("H2").legal("H3").legal("l1").legal("l2").legal("l3").legal("h1").legal("h2").legal("h3");
option.add( basic::options::OptionKeys::antibody::design::top_designs, "Number of top designs to keep (ensemble).  These will be written to a PDB and each move onto the next step in the protocol." ).def(1);
option.add( basic::options::OptionKeys::antibody::design::design_protocol, "Set the main protocol to use.  Note that deterministic is currently only available for the grafting of one CDR." ).legal("gen_mc").legal("even_cluster_mc").legal("even_length_cluster_mc").legal("deterministic_graft").def("even_cluster_mc");
option.add( basic::options::OptionKeys::antibody::design::run_snugdock, "Run snugdock on each ensemble after designing." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::run_relax, "Run Dualspace Relax on each ensemble after designing (after snugdock if run). Also output pre-relaxed structures" ).def(false);
option.add( basic::options::OptionKeys::antibody::design::run_interface_analyzer, "Run the Interface Analyzer and add the information to the resulting score function for each top design output." ).def(true);
option.add( basic::options::OptionKeys::antibody::design::paratope, "Use these CDRs as the paratope. Default is all of them.  Currently only used for constraints. Note that these site constraints are only used during docking unless -enable_full_protocol_atom_pair_cst is set." ).legal("L1").legal("L2").legal("L3").legal("H1").legal("H2").legal("H3").legal("l1").legal("l2").legal("l3").legal("h1").legal("h2").legal("h3");
option.add( basic::options::OptionKeys::antibody::design::epitope, "Use these residues as the antigen epitope.  Default is to auto-identify them within the set interface distance at protocol start if epitope constraints are enabled. Currently only used for constraints.  PDB Numbering. Optional insertion code. Example: 1A 1B 1B:A. Note that these site constraints are only used during docking unless -enable_full_protocol_atom_pair_cst is set." ).def();
option.add( basic::options::OptionKeys::antibody::design::use_epitope_constraints, "Enable use of epitope constraints to add SiteConstraints between the epitope and paratope.  Note that paratope constraints are always used.  Note that these site constraints are only used during docking unless -global_atom_pair_cst_scoring is set." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::dihedral_cst_weight, "Weight to use for CDR CircularHarmonic cluster-based or general constraints that are automatically added to each structure and updated after each graft. Set to zero if you dont want to use these constraints. Note that they are not used for the backrub mintype. Overrides weight/patch settings." ).def(.3);
option.add( basic::options::OptionKeys::antibody::design::atom_pair_cst_weight, "Weight to use for Epitope/Paratope SiteConstraints.  Paratope Side contraints are always used.  Set to zero to completely abbrogate these constraints. Overrides weight/patch settings." ).def(0.01);
option.add( basic::options::OptionKeys::antibody::design::global_dihedral_cst_scoring, "Use the dihedral cst score throughout the protocol, including final scoring of the poses instead of just during minimization step" ).def(false);
option.add( basic::options::OptionKeys::antibody::design::global_atom_pair_cst_scoring, "Use the atom pair cst score throughout the protocol, including final scoring of the poses instead of just during docking. Typically, the scoreterm is set to zero for scorefxns other than docking to decrease bias via loop lengths, relax, etc.  It may indeed help to target a particular epitope quicker during monte carlo design if epitope constraints are in use, as well for filtering final models on score towards a particular epitope if docking." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::do_dock, "Run a short lowres + highres docking step after each graft and before any minimization. Inner/Outer loops for highres are hard coded, while low-res can be changed through regular low_res options.  If sequence design is enabled, will design regions/CDRs set during the high-res dock. Recommended to " ).def(false);
option.add( basic::options::OptionKeys::antibody::design::do_rb_min, "Minimize the ab-ag interface post graft and any docking/cdr min by minimizing the jump" ).def(false);
option.add( basic::options::OptionKeys::antibody::design::dock_min_dock, "Do Dock -> Min -> Dock instead of Dock->Min where you would otherwise want 2 cycles. Must already be passing do_dock" ).def(false);
option.add( basic::options::OptionKeys::antibody::design::outer_cycle_rounds, "Rounds for outer loop of the protocol (not for deterministic_graft ).  Each round chooses a CDR and designs. One run of 100 cycles with relax takes about 12 hours.				  If you decrease this number, you will decrease your run time significantly, but your final decoys will be higher energy.  Make sure to increase the total number of output 				  structures (nstruct) if you use lower than this number.  Typically about 500 - 1000 nstruct is more than sufficient.  Full DeNovo design will require significantly more rounds 				  and nstruct.  If you are docking, runs take about 30 percent longer." ).def(100);
option.add( basic::options::OptionKeys::antibody::design::inner_cycle_rounds, "Number of times to run the inner minimization protocol after each graft.  Higher (2-3) rounds recommended for pack/min/backrub mintypes or if including dock in the protocol." ).def(1);
option.add( basic::options::OptionKeys::antibody::design::dock_cycle_rounds, "Number of rounds for any docking.  If you are seeing badly docked structures, increase this value." ).def(1);
option.add( basic::options::OptionKeys::antibody::design::interface_dis, "Interface distance cutoff.  Used for repacking of interface, epitope detection, etc." ).def(8.0);
option.add( basic::options::OptionKeys::antibody::design::neighbor_dis, "Neighbor distance cutoff.  Used for repacking after graft, minimization, etc." ).def(6.0);
option.add( basic::options::OptionKeys::antibody::design::use_outliers, "Include outlier data for GraftDesign, profile-based sequence design stats, and cluster-based dihedral constraints.  Outliers are defined as having a dihedral distance of > 40 degrees and an RMSD of >1.5 A to the cluster center.  Use to increase sampling of small or rare clusters." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::use_H3_graft_outliers, "Include outliers when grafting H3.  H3 does not cluster well, so most structures have high dihedral distance and RMSD to the cluster center.  Due to this, cluster-based dihedral constraints for H3 are not used.  Sequence profiles can be used for clusters, but not usually." ).def(true);
option.add( basic::options::OptionKeys::antibody::design::use_only_H3_kinked, "Remove any non-kinked CDRs from the CDRSet if grafting H3.  For now, the match is based on the ramachandran area of the last two residues of the H3. Kinked in this case is defined as having AB or DB regions at the end.  Will be improved for detection." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::design_antigen, "Design antigen residues during sequence design.  Intelligently.  Typically, only the neighbor antigen residues of designing cdrs or interfaces will be co-designed.  Useful for specific applications." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::design_framework, "Design framework residues during sequence design.  Typically done with only neighbor residues of designing CDRs or during interface minimization." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::conservative_framework_design, "If designing Framework positions, use conservative mutations instead of all of them." ).def(true);
option.add( basic::options::OptionKeys::antibody::design::design_H3_stem, "Enable design of the first 2 and last 3 residues of the H3 loop if sequence designing H3.  These residues play a role in the extended vs kinked H3 conformation.  Designing these residues may negatively effect the overall H3 structure by potentially switching a kinked loop to an extended and vice versa.  Rosetta may get it right.  But it is off by default to err on the cautious side of design. Sequence designing H3 may be already risky." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::design_proline, "Enable proline design.  Profiles for proline are very good, but designing them is a bit risky.  Enable this if you are feeling daring." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::sample_zero_probs_at, "Value for probabilstic design.  Probability that a normally zero prob will be chosen as a potential residue each time packer task is called.  Increase to increase variablility of positions. " ).def(0);
option.add( basic::options::OptionKeys::antibody::design::force_mutate_framework_for_cluster, "Force framework mutations that maintain certain clusters. Currently L1-11-1 vs L1-11-2.  See North cluster paper for these dependencies, or checkout rosetta/database/sampling/antibodies/design/cluster_framework_mutations.txt" ).def(true);
option.add( basic::options::OptionKeys::antibody::design::seq_design_stats_cutoff, "Value for probabilistic -> conservative sequence design switch.  If number of total sequences used for probabilistic design for a particular cdr cluster being designed is less than this value, conservative design will occur. More data = better predictability." ).def(10);
option.add( basic::options::OptionKeys::antibody::design::seq_design_profile_samples, "If designing using profiles, this is the number of times the profile is sampled each time packing done.  Increase this number to increase variability of designs - especially if not using relax as the mintype." ).def(1);
option.add( basic::options::OptionKeys::antibody::design::use_light_chain_type, "Use the light chain type, lambda or kappa IF given via option -antibody:light_chain.  This limits any aspect of the design protocol to use only data and cdrs for the given antibody type.  It (will) also add lambda vs kappa optimization steps such as L4 optimization.  Extremely useful for denovo design as lambda/kappa mixing can result in lower stability and non-expression of designs.  Failed mixed designs would then require manual framework mutations, framework switching, or other optimizations for succes.  Use PyIgClassify (see docs) to identify your framework as lambda or kappa.  Switch this to false or do not pass the -light_chain option to increase sampling with a greater risk of failed designs." ).def(true);
option.add( basic::options::OptionKeys::antibody::design::idealize_graft_cdrs, "Idealize the CDR before grafting.  May help or hinder.  Still testing." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::add_backrub_pivots, "Additional backrub pivot residues if running backrub as the MinType. PDB Numbering. Optional insertion code. Example: 1A 1B 1B:A.  Can also specify ranges: 1A-10:A.  Note no spaces in the range." );
option.add( basic::options::OptionKeys::antibody::design::inner_kt, "KT used in the inner min monte carlo after each graft." ).def(2.0);
option.add( basic::options::OptionKeys::antibody::design::outer_kt, "KT used for the outer graft Monte Carlo.  Each graft step will use this value" ).def(1.0);
option.add( basic::options::OptionKeys::antibody::design::random_start, "Start graft design (currently) with a new set of CDRs from the CDRSets as to not bias the run with native CDRs." ).def(false);
option.add( basic::options::OptionKeys::antibody::design::adapt_graft, "Adapt the grafting algorithm to increase rate of closed grafts.  Takes more time.  Grafts that cannot be closed may not be very compatable with the framework in the first place." ).def(true);
option.add( basic::options::OptionKeys::antibody::design::enable_adapt_graft_cartesian, "Cartesian minimization seems to be causing numerous bugs since the Lukis AST pointer rewrite.  These only happen on the cluster and it is very difficult to reproduce them. Until this is fixed, we can skip the cartesian adaptation where cartesian minimization would run when the graft could not close properly.  Exceptions are wrapped so that when it does fail we skip the graft. Set this to false to disable its use" ).def(false);
option.add( basic::options::OptionKeys::antibody::design::remove_antigen, "Remove the antigen from the pose before doing any design on it" ).def(false);
option.add( basic::options::OptionKeys::antibody::design::add_graft_log_to_pdb, "Add the full graft log to the output pose.  Must also pass -pdb_comments option." ).def(true);
option.add( basic::options::OptionKeys::antibody::design::mutate_framework_for_cluster, "Mutate the framework to maintain certain clusters post-graft." ).def(false);
option.add( basic::options::OptionKeys::task_operations::task_operations, "task_operations option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::task_operations::cons_design_data_source, "Data source used for the ConservativeDesignOperation.  This guides the set of allowed mutations.  Higher blosum means higher conservation (numbers indicate sequence similarity cutoffs." ).legal("chothia_1976").legal("BLOSUM30").legal("blosum30").legal("BLOSUM35").legal("blosum35").legal("BLOSUM40").legal("blosum40").legal("BLOSUM45").legal("blosum45").legal("BLOSUM50").legal("blosum50").legal("BLOSUM55").legal("blosum55").legal("BLOSUM60").legal("blosum60").legal("BLOSUM62").legal("blosum62").legal("BLOSUM65").legal("blosum65").legal("BLOSUM70").legal("blosum70").legal("BLOSUM75").legal("blosum75").legal("BLOSUM80").legal("blosum80").legal("BLOSUM85").legal("blosum85").legal("BLOSUM90").legal("blosum90").legal("BLOSUM100").legal("blosum100").def("blosum62");
option.add( basic::options::OptionKeys::assembly::assembly, "assembly option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::assembly::pdb1, "pdb1 file" );
option.add( basic::options::OptionKeys::assembly::pdb2, "pdb2 file" );
option.add( basic::options::OptionKeys::backrub::backrub, "backrub option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::backrub::pivot_residues, "residues for which contiguous stretches can contain segments (internal residue numbers, defaults to all residues)" ).def(utility::vector1<int>());
option.add( basic::options::OptionKeys::backrub::pivot_atoms, "main chain atoms usable as pivots" ).def(utility::vector1<std::string>(1, "CA"));
option.add( basic::options::OptionKeys::backrub::min_atoms, "minimum backrub segment size (atoms)" ).def(3);
option.add( basic::options::OptionKeys::backrub::max_atoms, "maximum backrub segment size (atoms)" ).def(34);
option.add( basic::options::OptionKeys::backrub::ntrials, "number of Monte Carlo trials to run" ).def(1000);
option.add( basic::options::OptionKeys::backrub::sc_prob, "probability of making a side chain move" ).def(0.25);
option.add( basic::options::OptionKeys::backrub::sm_prob, "probability of making a small move" ).def(0);
option.add( basic::options::OptionKeys::backrub::sc_prob_uniform, "probability of uniformly sampling chi angles" ).def(0.1);
option.add( basic::options::OptionKeys::backrub::sc_prob_withinrot, "probability of sampling within the current rotamer" ).def(0.0);
option.add( basic::options::OptionKeys::backrub::mc_kt, "value of kT for Monte Carlo" ).def(0.6);
option.add( basic::options::OptionKeys::backrub::mm_bend_weight, "weight of mm_bend bond angle energy term" ).def(1.0);
option.add( basic::options::OptionKeys::backrub::initial_pack, "force a repack at the beginning regardless of whether mutations are set in the resfile" ).def(false);
option.add( basic::options::OptionKeys::backrub::minimize_movemap, "specify degrees of freedom for minimization" );
option.add( basic::options::OptionKeys::backrub::trajectory, "record a trajectory" ).def(false);
option.add( basic::options::OptionKeys::backrub::trajectory_gz, "gzip the trajectory" ).def(false);
option.add( basic::options::OptionKeys::backrub::trajectory_stride, "write out a trajectory frame every N steps" ).def(100);
option.add( basic::options::OptionKeys::batch_relax::batch_relax, "batch_relax option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::batch_relax::batch_size, "Size of batches - note that thsie affects memory usage significantly" ).def(100);
option.add( basic::options::OptionKeys::bbg::bbg, "bbg option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::bbg::factorA, "Control how big the move would be(acceptance rate), default 1.0" ).def(1.0);
option.add( basic::options::OptionKeys::bbg::factorB, "Control how local the move would be(folded 10.0, unfolded 0.1), default 10.0" ).def(10.0);
option.add( basic::options::OptionKeys::bbg::ignore_improper_res, "Skip improper residues (proline)" ).def(false);
option.add( basic::options::OptionKeys::bbg::fix_short_segment, "Do not apply small mover to short segments, for loop" ).def(false);
option.add( basic::options::OptionKeys::boinc::boinc, "boinc option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::boinc::graphics, "The boinc client uses this option for the windowed graphics" ).def(false);
option.add( basic::options::OptionKeys::boinc::fullscreen, "The boinc client uses this option for the screensaver full screen graphics" ).def(false);
option.add( basic::options::OptionKeys::boinc::max_fps, "Maximum frames per second, overrides user preference." ).def(0);
option.add( basic::options::OptionKeys::boinc::max_cpu, "Maximum cpu percentage, overrides user preferecne." ).def(0);
option.add( basic::options::OptionKeys::boinc::noshmem, "for testing graphics without shared memory." ).def(false);
option.add( basic::options::OptionKeys::boinc::cpu_run_time, "Target cpu run time in seconds" ).def(10800);
option.add( basic::options::OptionKeys::boinc::max_nstruct, "Maximum number of output models (failed or successful) for a given client" ).def(99);
option.add( basic::options::OptionKeys::boinc::cpu_frac, "Percentage of CPU time used for graphics" ).def(10.0);
option.add( basic::options::OptionKeys::boinc::frame_rate, "Number of frames per second for graphics" ).def(10.0);
option.add( basic::options::OptionKeys::boinc::watchdog, "Turn watchdog on" ).def(false);
option.add( basic::options::OptionKeys::boinc::watchdog_time, "Time interval in seconds used by watchdog to check if run is stuck or going too long (default every 5 minutes)" ).def(300);
option.add( basic::options::OptionKeys::boinc::cpu_run_timeout, "Maximum time the WU may exceed the users WU time settings. Default is 4 hours.  Used by watchdog." ).def(14400);
option.add( basic::options::OptionKeys::boinc::description_file, "work unit description file" ).def("rosetta_description.txt");
option.add( basic::options::OptionKeys::boinc::score_cut_pct, "score cut done on the local nodes by percentage, required to return centroid models" );

}
inline void add_rosetta_options_6( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::boinc::score_cut_fl, "temp file where output is stored in" ).def("score_cut_tmp.out");
option.add( basic::options::OptionKeys::boinc::score_cut_smart_throttle, "makes absolutely sure you are generating < 1 model per 60 seconds.(set to 65 sec to be safe)" );
option.add( basic::options::OptionKeys::broker::broker, "broker option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::broker::setup, "setup file for topology-broker" ).def("NO_SETUP_FILE");
option.add( basic::options::OptionKeys::broker::rb_mover_stage1_weight, "weight of RB mover in abinitio stage 1" ).def(5.0);
option.add( basic::options::OptionKeys::broker::large_frag_mover_stage1_weight, "weight of fragment mover in abinitio stage 1" ).def(1.0);
option.add( basic::options::OptionKeys::broker::small_frag_mover_stage1_weight, "weight of fragment mover in abinitio stage 1" ).def(1.0);
option.add( basic::options::OptionKeys::bunsat_calc2::bunsat_calc2, "bunsat_calc2 option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::bunsat_calc2::sasa_burial_cutoff, "Minimum SASA to be considered exposed" ).def(0.01);
option.add( basic::options::OptionKeys::bunsat_calc2::layered_sasa, "Use the variable distance solvent SASA calculator for finding buried unsats" ).def(true);
option.add( basic::options::OptionKeys::bunsat_calc2::generous_hbonds, "Use generous hbond criteria" ).def(true);
option.add( basic::options::OptionKeys::bunsat_calc2::AHD_cutoff, "Minimum AHD angle for secondary geometry based h-bond detection" ).def(120);
option.add( basic::options::OptionKeys::bunsat_calc2::dist_cutoff, "max dist" ).def(3.0);
option.add( basic::options::OptionKeys::bunsat_calc2::hxl_dist_cutoff, "hxl max dist" ).def(3.5);
option.add( basic::options::OptionKeys::bunsat_calc2::sulph_dist_cutoff, "max sulph dist" ).def(3.3);
option.add( basic::options::OptionKeys::bunsat_calc2::metal_dist_cutoff, "max metal dist" ).def(2.7);
option.add( basic::options::OptionKeys::canonical_sampling::canonical_sampling, "canonical_sampling option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::probabilities, "probabilities option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::sc, "probability of making a side chain move" ).def(0.25);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::localbb, "probability of making a small move" ).def(0.75);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::sc_prob_uniform, "probability of uniformly sampling chi angles" ).def(0.1);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::sc_prob_withinrot, "probability of sampling within the current rotamer" ).def(0.9);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::sc_prob_perturbcurrent, "probability of perturbing the current rotamer" ).def(0.0);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::MPI_sync_pools, "use MPI to synchronize pools and communicate between nodes" ).def(false);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::MPI_bcast, "use broadcasting in syncing" ).def(false);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::fast_sc_moves, "use the fast SidechainMCMover" ).def(false);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::fast_sc_moves_ntrials, "specify the number of ntrials for each call of scmover apply" ).def(1000);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::no_jd2_output, "do not write to silent-file specified by -out:file:silent" ).def(false);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::use_hierarchical_clustering, "use the HierarchicalLevel class" ).def(false);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::backrub, "set the probability of executing a backrub move when making a backbone move" ).def(0.5);
option.add( basic::options::OptionKeys::canonical_sampling::probabilities::conrot, "set relative probability of executing a conrot move when making a backbone move" ).def(0.0);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::sampling, "sampling option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::no_detailed_balance, "preserve detailed balance" ).def(false);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::ntrials, "number of Monte Carlo trials to run" ).def(1000);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::mc_kt, "value of kT for Monte Carlo" ).def(0.6);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::interval_pose_dump, "dump a pose out every x steps" ).def(1000);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::interval_data_dump, "dump data out every x steps" ).def(100);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::output_only_cluster_transitions, "output only cluster transitions" ).def(false);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::transition_threshold, "if rmsd to known_structures larger than X, add a new structure to pool" ).def(2.0);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::max_files_per_dir, "distribute traj and transition files into subdirectories with max N entries" ).def(1000);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::save_loops_only, "save only loop conformation to pool" ).def(false);
option.add( basic::options::OptionKeys::canonical_sampling::sampling::dump_loops_only, "dump only loop conformation in silent-files" ).def(false);
option.add( basic::options::OptionKeys::canonical_sampling::out::out, "out option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::canonical_sampling::out::new_structures, "" ).def("discovered_decoys.out");
option.add( basic::options::OptionKeys::casp::casp, "casp option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::casp::opt_radius, "optimization radius for repacking and minimization" );
option.add( basic::options::OptionKeys::casp::repack, "should we repack the structure?" );
option.add( basic::options::OptionKeys::casp::sc_min, "should we sidechain minimize the structure?" );
option.add( basic::options::OptionKeys::casp::sequential, "should mutations be considered in sequence or all together?" );
option.add( basic::options::OptionKeys::casp::num_iterations, "number of iterations to perform" );
option.add( basic::options::OptionKeys::casp::refine_res, "specifies file that contains which residues to refine" );
option.add( basic::options::OptionKeys::chemically_conjugated_docking::chemically_conjugated_docking, "chemically_conjugated_docking option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::chemically_conjugated_docking::UBQpdb, "ubiquitin structure, or the structure for the attached thing that is moving" ).def("1UBQ.pdb");
option.add( basic::options::OptionKeys::chemically_conjugated_docking::E2pdb, "E2 structure, or the structure of the thing that is attached to (has cysteine) and does not move; should be one chain" ).def("2OB4.pdb");
option.add( basic::options::OptionKeys::chemically_conjugated_docking::E2_residue, "E2 catalytic cysteine (PDB numbering) (where the ubiquitin gets attached; assumed to be on the first chain of E2pdb" ).def(85);
option.add( basic::options::OptionKeys::chemically_conjugated_docking::SASAfilter, "filter out structures with interface dSASA less than this" ).def(1000);
option.add( basic::options::OptionKeys::chemically_conjugated_docking::scorefilter, "filter out structures with total score greater than this" ).def(10);
option.add( basic::options::OptionKeys::chemically_conjugated_docking::publication, "output statistics used in publication.  TURN OFF if not running (original Saha et al.) publication demo." ).def(false);
option.add( basic::options::OptionKeys::chemically_conjugated_docking::n_tail_res, "Number of c-terminal ~tail~ residues to make flexible (terminus inclusive)" ).def(3);
option.add( basic::options::OptionKeys::chemically_conjugated_docking::two_ubiquitins, "Mind-blowing - use two ubiquitins (assembled for a K48 linkage) to try to examine the transition state.  Don't use this option unless trying to reproduce publication XXXX" ).def(false);
option.add( basic::options::OptionKeys::chemically_conjugated_docking::extra_bodies, "extra structures to add before modeling.  Should be in the coordinate frame of the non-moving partner.  Will not move during modeling.  Will be detected as part of the nonmoving body for repacking purposes." ).def("");
option.add( basic::options::OptionKeys::chemically_conjugated_docking::UBQ2_lys, "which Lys on the second UB will be conjugated" ).def(48);
option.add( basic::options::OptionKeys::chemically_conjugated_docking::UBQ2_pdb, "PDB for second ubiquitin (second moving chain).  Only active if -two_ubiquitins is used; inactive otherwise.  Optional; defaults to value of -UBQpdb if not passed." );
option.add( basic::options::OptionKeys::chemically_conjugated_docking::dont_minimize_omega, "disable minimization of omega angles near thioester in MoveMap; not present in original publications (Saha; Baker)" ).def(false);
option.add( basic::options::OptionKeys::chemically_conjugated_docking::pdz, "For the UBQ_Gp_LYX-Cterm executable, if -publication is already on, switch to the PDZ center of mass instead of ubiquitin center of mass for the extra statistics calculations.  Don't use this option unless trying to reproduce publication XXXX" ).def(false);
option.add( basic::options::OptionKeys::chemically_conjugated_docking::GTPasepdb, "GTPase structure, or the structure of the thing that is attached to (has cysteine) and does not move; should be one chain" ).def("2OB4.pdb");
option.add( basic::options::OptionKeys::chemically_conjugated_docking::GTPase_residue, "GTPase lysine (PDB numbering) (where the ubiquitin gets attached; assumed to be on the first chain of GTPase_pdb" ).def(85);
option.add( basic::options::OptionKeys::chunk::chunk, "chunk option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::chunk::pdb2, "file for chunk2" );
option.add( basic::options::OptionKeys::chunk::loop2, "rigid region for chunk2" );
option.add( basic::options::OptionKeys::cluster::cluster, "cluster option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cluster::lite, "uses light-weight method of outputting cluster-centers, useful for when there's a HUGE amount of data!" ).def(false);
option.add( basic::options::OptionKeys::cluster::input_score_filter, "Only read in structures below a certain energy" ).def(1000000.0);
option.add( basic::options::OptionKeys::cluster::output_score_filter, "Only read in structures below a certain energy" ).def(1000000.0);
option.add( basic::options::OptionKeys::cluster::exclude_res, "Residue numbers to be excluded from cluster RMS calculation" ).def(-1);
option.add( basic::options::OptionKeys::cluster::thinout_factor, "Ignore this fraction of decoys in the first round !" ).def(-1);
option.add( basic::options::OptionKeys::cluster::radius, "Cluster radius" ).def(3.0);
option.add( basic::options::OptionKeys::cluster::limit_cluster_size, "For each cluster only retain top N " ).def(-1);
option.add( basic::options::OptionKeys::cluster::limit_cluster_size_percent, "0 to 1. For each cluster only retain top N % " );
option.add( basic::options::OptionKeys::cluster::random_limit_cluster_size_percent, "0 to 1. For each cluster only retain random N % " );
option.add( basic::options::OptionKeys::cluster::limit_clusters, "Only retain largest N clusters" ).def(100);
option.add( basic::options::OptionKeys::cluster::limit_total_structures, "Only retain the first N structures (ordered by cluster number)" ).def(-1);
option.add( basic::options::OptionKeys::cluster::max_total_cluster, "Only ever make N clusters or less" ).def(1000);
option.add( basic::options::OptionKeys::cluster::gdtmm, "Cluster by gdtmm instead of RMS" ).def(false);
option.add( basic::options::OptionKeys::cluster::skip_align, "Cluster without aligning the structures" ).def(false);
option.add( basic::options::OptionKeys::cluster::max_rms_matrix, "Maximum number of structures to use to calculate the full RMSD matrix" ).def(400);
option.add( basic::options::OptionKeys::cluster::rna_P, "Calculate rmsd from backbone phosphate positions only" ).def(false);
option.add( basic::options::OptionKeys::cluster::sort_groups_by_energy, "Sort clusters by energy" ).def(false);
option.add( basic::options::OptionKeys::cluster::sort_groups_by_size, "Sort clusters by energy" ).def(false);
option.add( basic::options::OptionKeys::cluster::remove_singletons, "Get rid of single-member clusters" ).def(false);
option.add( basic::options::OptionKeys::cluster::export_only_low, "Print only the lowest energy member" ).def(false);
option.add( basic::options::OptionKeys::cluster::remove_highest_energy_member, "Remove highest energy member from each cluster" ).def(false);
option.add( basic::options::OptionKeys::cluster::idealize_final_structures, "Run an idealization over the resulting structures" ).def(false);
option.add( basic::options::OptionKeys::cluster::limit_dist_matrix, "Only calculate full matrix for a subset of structres. Then simply assign structures to nearest cluster" ).def(-1);
option.add( basic::options::OptionKeys::cluster::make_ensemble_cst, "Create a set of constraints describing the variablity in each cluster of each residue." ).def(false);
option.add( basic::options::OptionKeys::cluster::hotspot_hash, "Cluster hotspot hashing results. Each input PDB must contain both the target and the newly docked hotspot (which should be the last residue in the pose)." ).def(false);
option.add( basic::options::OptionKeys::cluster::loops, "Cluster the loop specified with the -loops:loop_file option" ).def(false);
option.add( basic::options::OptionKeys::cluster::population_weight, "Order Clusters by (1-p)*score - p*size whpere p = population_weight " ).def(0.09);
option.add( basic::options::OptionKeys::cluster::template_scores, "imple textfile containing template names (in caps) and scores." );
option.add( basic::options::OptionKeys::cluster::K_level, "Hierarchical cluster level number" ).def(1);
option.add( basic::options::OptionKeys::cluster::K_radius, "Radius list of different level of cluster" ).def(utility::vector1<float>(1, 2.0));
option.add( basic::options::OptionKeys::cluster::K_n_cluster, "How many clusters in each level" ).def(utility::vector1<int>(1, 10000));
option.add( basic::options::OptionKeys::cluster::K_style, "Which K-cluster engine to use" ).def(utility::vector1<std::string>(9, "GKC"));
option.add( basic::options::OptionKeys::cluster::K_n_sub, "Number of clusters in subdir" ).def(100);
option.add( basic::options::OptionKeys::cluster::K_deque_size, "Size of subcluster deque" ).def(20);
option.add( basic::options::OptionKeys::cluster::K_deque_level, "Provide deque in top level" ).def(1);
option.add( basic::options::OptionKeys::cluster::K_redundant, "Keep all the higher level center structure in sub-pools" ).def(true);
option.add( basic::options::OptionKeys::cluster::K_not_fit_xyz, "Do not rotate xyz when calculate rmsd" ).def(false);
option.add( basic::options::OptionKeys::cluster::K_save_headers, "Save headers in silent file" ).def(false);
option.add( basic::options::OptionKeys::cluster::score_diff_cut, "score difference cut for RNA and SWA clustering" ).def(1000000.0);
option.add( basic::options::OptionKeys::cluster::auto_tune, "autotune rmsd for clustering between 0.1A up to 2.0A, for SWA clusterer" ).def(false);
option.add( basic::options::OptionKeys::cluster::write_centers, "Write out a silent file with the cluster centers" ).def(false);
option.add( basic::options::OptionKeys::cm::cm, "cm option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cm::sanitize::sanitize, "sanitize option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cm::sanitize::num_fragments, "Use the top k fragments at each position during sanitization" ).def(25);
option.add( basic::options::OptionKeys::cm::sanitize::cst_weight_pair, "atom_pair_constraint weight" ).def(1.0);
option.add( basic::options::OptionKeys::cm::sanitize::cst_weight_coord, "coordinate_constraint weight" ).def(1.0);
option.add( basic::options::OptionKeys::cm::start_models_only, "Make starting models only!" ).def(false);
option.add( basic::options::OptionKeys::cm::aln_format, "No description" ).legal("grishin").legal("general").def("grishin");
option.add( basic::options::OptionKeys::cm::recover_side_chains, "recover side-chains" ).def(false);
option.add( basic::options::OptionKeys::cm::steal_extra_residues, "list of template extra residues (ie ligands) to add to query pose in comparative modeling" );
option.add( basic::options::OptionKeys::cm::loop_mover, "No description" ).legal("quick_ccd").legal("quick_ccd_moves").legal("perturb_ccd").legal("perturb_kic").legal("sdwindow").def("quick_ccd");
option.add( basic::options::OptionKeys::cm::loop_close_level, "level of aggressiveness to use in closing loops. 					The integers that follow flags specify how aggressively 					loops are rebuilt. Each option implies all non-zero levels below it,					so that loop_close_level 2 implies level 1 as well. Meaning of 					the options are: 					NO_REBUILD              0     don't rebuild loops at all 					REBUILD_UNALIGNED       1     rebuild loops around unaligned regions 					REBUILD_CHAINBREAK      2     rebuild loops around chainbreaks 					REBUILD_EXHAUSTIVE      3     rebuild loops around regions with a chainbreak until no chainbreaks remain" ).legal(0).legal(1).legal(2).legal(3).def(0);
option.add( basic::options::OptionKeys::cm::min_loop_size, "Minimum size of loops to remodel when building threading models." ).def(5);
option.add( basic::options::OptionKeys::cm::max_loop_rebuild, "Maximum number of times to try to rebuild a loop before giving up." ).def(10);
option.add( basic::options::OptionKeys::cm::loop_rebuild_filter, "Maximum score a structure must have after loop rebuilding." ).def(0);
option.add( basic::options::OptionKeys::cm::aln_length_filter_quantile, "Only use alignment lengths longer than the Xth quantile. e.g. setting this to 0.75 will only use the 25% longest alignments" ).def(0.0);
option.add( basic::options::OptionKeys::cm::aln_length_filter, "Only use alignment longer or equal to this length" ).def(-1);
option.add( basic::options::OptionKeys::cm::seq_score, "sequence-based scoring scheme used for generating alignments" ).legal("L1").legal("ProfSim").legal("DP").legal("Matrix").legal("Simple").legal("ChemicalShift").def(utility::vector1<std::string>(1,"Simple"));
option.add( basic::options::OptionKeys::cm::aligner, "algorithm for making sequence alignments" ).legal("local").legal("global").legal("mc");
option.add( basic::options::OptionKeys::cm::min_gap_open, "gap opening penalty for sequence alignments (usually negative)" ).def(-2.0);
option.add( basic::options::OptionKeys::cm::max_gap_open, "gap opening penalty for sequence alignments (usually negative)" ).def(-2.0);
option.add( basic::options::OptionKeys::cm::min_gap_extend, "gap extension penalty for sequence alignments (usually negative)" ).def(-0.2);
option.add( basic::options::OptionKeys::cm::max_gap_extend, "gap extension penalty for sequence alignments (usually negative)" ).def(-0.2);
option.add( basic::options::OptionKeys::cm::nn, "number of neighbors to include in constraint derivation" ).def(500);
option.add( basic::options::OptionKeys::cm::ev_map, "Input file that maps pdbChains to blast e-values" );
option.add( basic::options::OptionKeys::cm::hh_map, "Input file that maps pdbChains to hhsearch probabilities" );
option.add( basic::options::OptionKeys::cm::hybridize::hybridize, "hybridize option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cm::hybridize::starting_template, "Define starting templates" );
option.add( basic::options::OptionKeys::cm::hybridize::realign_domains, "domain parse and realign the starting templates" ).def(true);
option.add( basic::options::OptionKeys::cm::hybridize::realign_domains_stage2, "realign the starting templates to the pose after stage1" ).def(true);
option.add( basic::options::OptionKeys::cm::hybridize::add_non_init_chunks, "add (on average) this many non-template chunks" ).def(0);
option.add( basic::options::OptionKeys::cm::hybridize::stage1_increase_cycles, "Scale stage 1 cycles" ).def(1.0);
option.add( basic::options::OptionKeys::cm::hybridize::stage2_increase_cycles, "Scale stage 2 cycles" ).def(1.0);
option.add( basic::options::OptionKeys::cm::hybridize::stage2min_increase_cycles, "Scale minimizer cycles after stage 2" ).def(1.0);
option.add( basic::options::OptionKeys::cm::hybridize::stage1_probability, "Probability of hybridizing in stage 1, 0=never, 1=always" ).def(1.0);
option.add( basic::options::OptionKeys::cm::hybridize::skip_stage2, "skip cartesian fragment hybridize stage" ).def(false);
option.add( basic::options::OptionKeys::cm::hybridize::no_global_frame, "no global-frame fragment insertions" ).def(false);
option.add( basic::options::OptionKeys::cm::hybridize::linmin_only, "linmin only in stage 2" ).def(false);
option.add( basic::options::OptionKeys::cm::hybridize::relax, "if n==1, perform relax at end; if n>1 perform batch relax over n centroids" ).def(0);
option.add( basic::options::OptionKeys::cm::hybridize::frag_weight_aligned, "Probability of fragment insertion in the aligned region" ).def(0.);
option.add( basic::options::OptionKeys::cm::hybridize::max_registry_shift, "maximum registry shift" ).def(0);
option.add( basic::options::OptionKeys::cm::hybridize::frag_1mer_insertion_weight, "weight for 1mer fragment insertions where fragments are not allowed vs. template chunk insertions in stage1" ).def(0.0);
option.add( basic::options::OptionKeys::cm::hybridize::small_frag_insertion_weight, "weight for small fragment insertions where large fragments are not allowed vs. template chunk insertions in stage1" ).def(0.0);
option.add( basic::options::OptionKeys::cm::hybridize::big_frag_insertion_weight, "weight for big fragment insertions vs. template chunk insertions in stage1" ).def(0.5);
option.add( basic::options::OptionKeys::cm::hybridize::auto_frag_insertion_weight, "automatically set the weight for fragment insertions vs. template chunk insertions in stage1" ).def(true);
option.add( basic::options::OptionKeys::cm::hybridize::stage1_1_cycles, "Number of cycles for ab initio stage 1 in Stage1" ).def(2000);
option.add( basic::options::OptionKeys::cm::hybridize::stage1_2_cycles, "Number of cycles for ab initio stage 2 in Stage1" ).def(2000);
option.add( basic::options::OptionKeys::cm::hybridize::stage1_3_cycles, "Number of cycles for ab initio stage 3 in Stage1" ).def(2000);
option.add( basic::options::OptionKeys::cm::hybridize::stage1_4_cycles, "Number of cycles for ab initio stage 4 in Stage1" ).def(400);
option.add( basic::options::OptionKeys::cm::hybridize::stage2_temperature, "Monte Carlo temperature in the stage2" ).def(2.0);
option.add( basic::options::OptionKeys::cm::hybridize::stage1_4_cenrot_score, "Switch to cenrot model in stage1_4" ).def("score_cenrot_cm_stage1_4.wts");
option.add( basic::options::OptionKeys::cm::hybridize::include_loop_ss_chunks, "include loop secondary structure chunks from templates" ).def(false);
option.add( basic::options::OptionKeys::contactMap::contactMap, "contactMap option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::contactMap::prefix, "Prefix of contactMap filename" ).def("contact_map_");
option.add( basic::options::OptionKeys::contactMap::distance_cutoff, "Cutoff Backbone distance for two atoms to be considered interacting" ).def(10.0);
option.add( basic::options::OptionKeys::contactMap::region_def, "Region definition for comparison eg: 1-10:20-30,40-50,A:ligand=X" ).def("");
option.add( basic::options::OptionKeys::contactMap::row_format, "Flag whether to output in row instead of matrix format" ).def(false);
option.add( basic::options::OptionKeys::contactMap::distance_matrix, "Output a distance matrix instead of a contact map" ).def(false);
option.add( basic::options::OptionKeys::coupled_moves::coupled_moves, "coupled_moves option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::coupled_moves::ntrials, "number of Monte Carlo trials to run" ).def(1000);
option.add( basic::options::OptionKeys::coupled_moves::number_ligands, "number of ligands in the pose" ).def(1);
option.add( basic::options::OptionKeys::coupled_moves::mc_kt, "value of kT for Monte Carlo" ).def(0.6);
option.add( basic::options::OptionKeys::coupled_moves::boltzmann_kt, "value of kT for Boltzmann weighted moves" ).def(0.6);
option.add( basic::options::OptionKeys::coupled_moves::mm_bend_weight, "weight of mm_bend bond angle energy term" ).def(1.0);
option.add( basic::options::OptionKeys::coupled_moves::trajectory, "record a trajectory" ).def(false);
option.add( basic::options::OptionKeys::coupled_moves::trajectory_gz, "gzip the trajectory" ).def(false);
option.add( basic::options::OptionKeys::coupled_moves::trajectory_stride, "write out a trajectory frame every N steps" ).def(100);
option.add( basic::options::OptionKeys::coupled_moves::trajectory_file, "name of trajectory file" ).def("traj.pdb");
option.add( basic::options::OptionKeys::coupled_moves::output_fasta, "name of FASTA output file" ).def("sequences.fasta");
option.add( basic::options::OptionKeys::coupled_moves::output_stats, "name of stats output file" ).def("sequences.stats");
option.add( basic::options::OptionKeys::coupled_moves::ligand_mode, "if true, model protein ligand interaction" ).def(false);
option.add( basic::options::OptionKeys::coupled_moves::initial_repack, "start simulation with repack and design step" ).def(true);
option.add( basic::options::OptionKeys::coupled_moves::min_pack, "use min_pack for initial repack and design step" ).def(false);
option.add( basic::options::OptionKeys::coupled_moves::save_sequences, "save all unique sequences" ).def(true);
option.add( basic::options::OptionKeys::coupled_moves::save_structures, "save structures for all unique sequences" ).def(false);
option.add( basic::options::OptionKeys::coupled_moves::ligand_prob, "probability of making a ligand move" ).def(0.1);
option.add( basic::options::OptionKeys::coupled_moves::fix_backbone, "do not make any backbone moves" ).def(false);
option.add( basic::options::OptionKeys::coupled_moves::uniform_backrub, "select backrub rotation angle from uniform distribution" ).def(false);
option.add( basic::options::OptionKeys::coupled_moves::bias_sampling, "if true, bias rotamer selection based on energy" ).def(true);
option.add( basic::options::OptionKeys::coupled_moves::bump_check, "if true, use bump check in generating rotamers" ).def(true);
option.add( basic::options::OptionKeys::coupled_moves::ligand_weight, "weight for residue - ligand interactions" ).def(1.0);
option.add( basic::options::OptionKeys::coupled_moves::output_prefix, "prefix for output files" ).def("");
option.add( basic::options::OptionKeys::cp::cp, "cp option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cp::cutoff, "designable neighbor cutoff" ).def(16);
option.add( basic::options::OptionKeys::cp::relax_sfxn, "score function for final relaxation step" ).def("score12_full");
option.add( basic::options::OptionKeys::cp::pack_sfxn, "score function for mutational trials" ).def("gauss");
option.add( basic::options::OptionKeys::cp::minimizer_score_fxn, "score function for initial minimization" ).def("score12_full");
option.add( basic::options::OptionKeys::cp::output, "file where we want to dump the final pose" ).def("final_mutant.pdb");
option.add( basic::options::OptionKeys::cp::ncycles, "how many cycles to run refinement for" ).def(0);
option.add( basic::options::OptionKeys::cp::max_failures, "how many failures to tolerate at each iteration before quitting" ).def(1);
option.add( basic::options::OptionKeys::cp::print_reports, "print reports to text file?" ).def(false);
option.add( basic::options::OptionKeys::cp::vipReportFile, "File to print reports to" ).def("reports.txt");
option.add( basic::options::OptionKeys::cp::exclude_file, "Optional input file to specify positions that should not be mutated" ).def("cp_excludes");
option.add( basic::options::OptionKeys::cp::relax_mover, "relax w/o constraints=relax, w constraints=cst_relax" ).def("relax");
option.add( basic::options::OptionKeys::cp::skip_relax, "Skip relax step... may reduce accurate identification of mutations" ).def(false);
option.add( basic::options::OptionKeys::cp::local_relax, "Limit relax step to neighbors" ).def(false);
option.add( basic::options::OptionKeys::cp::print_intermediate_pdbs, "Output a pdb file for each consecutive mutation" ).def(false);
option.add( basic::options::OptionKeys::cp::use_unrelaxed_starting_points, "For subsequent iterations, uses mutation before relaxation" ).def(false);
option.add( basic::options::OptionKeys::cp::easy_vip_acceptance, "For all iterations, use initial energy for acceptance test" ).def(false);
option.add( basic::options::OptionKeys::cryst::cryst, "cryst option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cryst::mtzfile, "mtz file" );
option.add( basic::options::OptionKeys::cryst::crystal_refine, "Turns on crystal-refinement-specific options" ).def(false);
option.add( basic::options::OptionKeys::cryst::refinable_lattice, "In MakeLatticeMover, are the lattice dimensions refineable?" ).def(true);
option.add( basic::options::OptionKeys::cryst::interaction_shell, "In MakeLatticeMover, what is default interaction shell?" ).def(12.0);
option.add( basic::options::OptionKeys::csa::csa, "csa option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::csa::useZ, "Use absolute zaxis for scoring csa" );
option.add( basic::options::OptionKeys::cutoutdomain::cutoutdomain, "cutoutdomain option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cutoutdomain::start, "start residue" ).def(1);
option.add( basic::options::OptionKeys::cutoutdomain::end, "end residue" ).def(2);
option.add( basic::options::OptionKeys::cyclization::cyclization, "cyclization option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cyclization::chains_to_cyclize, "The chain number to cyclize" );
option.add( basic::options::OptionKeys::cyclization::num_min_rebuild, "The number of time to iterate between minimization and rebuilding the connection dependant atom positions" ).def(3);
option.add( basic::options::OptionKeys::cyclization::add_constraints, "The add constraints to maintain cycle geometry" ).def(true);
option.add( basic::options::OptionKeys::cyclic_peptide::cyclic_peptide, "cyclic_peptide option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cyclic_peptide::rand_checkpoint_file, "The name of the checkpoint file used for the random number generator.  Defaults to rng.state.gz.  Not used if the -cyclic_peptide:checkpoint_job_identifier flag isn't used." ).def("rng.state.gz");
option.add( basic::options::OptionKeys::cyclic_peptide::checkpoint_file, "The name of the checkpoint file.  Defaults to checkpoint.txt.  Not used if the -cyclic_peptide:checkpoint_job_identifier flag isn't used." ).def("checkpoint.txt");
option.add( basic::options::OptionKeys::cyclic_peptide::checkpoint_job_identifier, "A unique job name for checkpointing.  If none is provided, jobs are not checkpointed." ).def("");
option.add( basic::options::OptionKeys::cyclic_peptide::default_rama_sampling_table, "A custom rama table used for sampling, applied by default to all residues unless the --cyclic_peptide:rama_sampling_table_by_res flag overrides this.  Default unused (in which case the default rama tables for each residue type are used)." ).def("");
option.add( basic::options::OptionKeys::cyclic_peptide::rama_sampling_table_by_res, "Custom rama tables that are to be used for sampling on a per-residue basis.  These must be specified as pairs of [residue_index table_name].  For example: -rama_sampling_table_by_res 2 flat_symm_gly_ramatable 3 flat_symm_pro_ramatable.  Specified values override the -default_rama_sampling_table at the relevant positions." ).def();
option.add( basic::options::OptionKeys::cyclic_peptide::sequence_file, "Filename of a file specfying the sequence, as a series of whitespace-separated full residue names (e.g. ALA LYS DARG DPRO HYP).  Required input for the simple_cycpep_predict app." );
option.add( basic::options::OptionKeys::cyclic_peptide::genkic_closure_attempts, "How many closure attempts should we make for each job attempted by the simple_cycpep_predict app?  Default 1,000." ).def(1000);
option.add( basic::options::OptionKeys::cyclic_peptide::genkic_min_solution_count, "How many solutions should genKIC find before picking one when used in the simple_cycpep_predict app?  Default 1." ).def(1);
option.add( basic::options::OptionKeys::cyclic_peptide::cyclic_permutations, "Should cyclic permutations of the sequence be considered when setting up the kinematic closure?  Default true." ).def(true);
option.add( basic::options::OptionKeys::cyclic_peptide::use_rama_filter, "Should GenKIC solutions be filtered based on rama score in the simple_cycpep_predict app?  True by default." ).def(true);
option.add( basic::options::OptionKeys::cyclic_peptide::rama_cutoff, "The maximum rama score value that's permitted in the accepted GenKIC solutions if the use_rama_filter option is passed to the simple_cycpep_predict app.  Default 0.8." ).def(0.8);
option.add( basic::options::OptionKeys::cyclic_peptide::high_hbond_weight_multiplier, "In parts of the simple_cycpep_predict protocol involving upweighting of the backbone hbond terms, by what factor should backbone hbond energy be upweighted?  Default 10.0." ).def(10.0);
option.add( basic::options::OptionKeys::cyclic_peptide::min_genkic_hbonds, "The minimum number of backbone hbonds for a solution to pass during GenKIC closure in the simple_cycpep_predict app.  Default 3." ).def(3.0);
option.add( basic::options::OptionKeys::cyclic_peptide::min_final_hbonds, "The minimum number of backbone hbonds for a solution to pass after final relaxtion in the simple_cycpep_predict app.  Default 0 (report only)." ).def(0.0);
option.add( basic::options::OptionKeys::cyclic_peptide::total_energy_cutoff, "An absolute energy threshold, above which solutions are discarded.  Unused if not specified." ).def(0.0);
option.add( basic::options::OptionKeys::cyclic_peptide::hbond_energy_cutoff, "The mainchain hbond energy threshold for something to be counted as a hydrogen bond in the simple_cycpep_predict app.  Default -0.25." ).def(-0.25);
option.add( basic::options::OptionKeys::cyclic_peptide::do_not_count_adjacent_res_hbonds, "When counting hydrogen bonds to a residue, should we skip hydrogen bonds to adjacent residues?  Default true." ).def(true);
option.add( basic::options::OptionKeys::cyclic_peptide::fast_relax_rounds, "The number of rounds of FastRelax to perform at each FastRelax step in the simple_cycpep_predict protocol.  Note that there are two such steps: a high-hbond initial FastRelax applied to all GenKIC solutions, and a regular scorefunction final FastRelax applied to the best GenKIC solution.  Default 3." ).def(3);
option.add( basic::options::OptionKeys::cyclic_peptide::count_sc_hbonds, "Should sidechain-backbone and sidechain-sidechain hydrogen bonds be counted in the total hydrogen bond count in the simple_cycpep_predict protocol?  Default false." ).def(false);
option.add( basic::options::OptionKeys::cyclic_peptide::require_disulfides, "If true, accepted conformations must permit disulfides to be formed.  All permutations of disulfides will be considered, between all disulfide-forming residues.  Default false." ).def(false);
option.add( basic::options::OptionKeys::cyclic_peptide::disulf_cutoff_prerelax, "If require_disulfides is true, this is the maximum disulfide energy per disulfide bond that is allowed prior to relaxation.  If the energy exceeds this value, the solution is rejected.  Default 15.0." ).def(15.0);

}
inline void add_rosetta_options_7( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::cyclic_peptide::disulf_cutoff_postrelax, "If require_disulfides is true, this is the maximum disulfide energy per disulfide bond that is allowed following relaxation.  If the energy exceeds this value, the solution is rejected.  Default 0.5." ).def(0.5);
option.add( basic::options::OptionKeys::cyclic_peptide::user_set_alpha_dihedrals, "Allows the user to specify the dihedrals values at one or more alpha-amino acid positions in the peptide.  The flag must be followed by groups of four numbers, where the first is the sequence position and the second, third, and fourth are the phi, psi, and omega values, respectively.  Not used if not specified." );
option.add( basic::options::OptionKeys::cyclic_peptide::user_set_alpha_dihedral_perturbation, "A small, random perturbation added to all dihedral values set with the -user_set_alpha_dihedrals value.  Zero if not specified." ).def(0.0);
option.add( basic::options::OptionKeys::cyclic_peptide::filter_oversaturated_hbond_acceptors, "If true, sampled conformations with more than the allowed number of hydrogen bonds to an acceptor are discarded.  True by default." ).def(true);
option.add( basic::options::OptionKeys::cyclic_peptide::hbond_acceptor_energy_cutoff, "The hydrogen bond energy above which we do not count a hydrogen bond.  Default -0.1." ).def(-0.1);
option.add( basic::options::OptionKeys::cyclic_peptide::sample_cis_pro_frequency, "The fraction of the time that omega=0 degrees is sampled at positions preceding L-proline or D-proline.  Defaults to 0.3.  Set this to 0.0 to prevent all cis-pro sampling." ).def(0.3);
option.add( basic::options::OptionKeys::cyclic_peptide::design_peptide, "If true, then design is attempted for every conformation sampled that passes filters.  Default false." ).def(false);
option.add( basic::options::OptionKeys::cyclic_peptide::allowed_residues_by_position, "A text file that lists allowed amino acid resides at each position in the peptide.  Each line must be a whiltespace-separated list of full amino acid names, with the positon index at the start of the line.  Optionally, a DEFAULT setting may be provided (where DEFAULT replaces the position index), which is applied to all positions in the absence of a line describing what's allowed at that position.  In the absence of a DEFAULT line, non-specified positions are repacked with no design.  Not used if not specified (in which case all D- and L-amino acids except cysteine, glycine, and methionine are allowed at all positions)." );
option.add( basic::options::OptionKeys::cyclic_peptide::prohibit_D_at_negative_phi, "If design is allowed, should D-amino acid residues be prohibited at positions with negative phi values?  Default true." ).def(true);
option.add( basic::options::OptionKeys::cyclic_peptide::prohibit_L_at_positive_phi, "If design is allowed, should L-amino acid residues be prohibited at positions with positive phi values?  Default true." ).def(true);
option.add( basic::options::OptionKeys::cyclic_peptide::L_alpha_comp_file, "If design is allowed, this is the (optional) aa_composition file used for the right-handed (L-amino acid) alpha-helical region of Ramachandran space.  Unused if not specified." );
option.add( basic::options::OptionKeys::cyclic_peptide::D_alpha_comp_file, "If design is allowed, this is the (optional) aa_composition file used for the left-handed (D-amino acid) alpha-helical region of Ramachandran space.  Unused if not specified." );
option.add( basic::options::OptionKeys::cyclic_peptide::L_beta_comp_file, "If design is allowed, this is the (optional) aa_composition file used for the negative-phi (L-amino acid) beta-strand region of Ramachandran space.  Unused if not specified." );
option.add( basic::options::OptionKeys::cyclic_peptide::D_beta_comp_file, "If design is allowed, this is the (optional) aa_composition file used for the positive-phi (D-amino acid) beta-strand region of Ramachandran space.  Unused if not specified." );
option.add( basic::options::OptionKeys::cyclic_peptide::angle_relax_rounds, "The number of rounds of FastRelax to perform with flexible bond angles after each standard FastRelax step in the simple_cycpep_predict protocol.  Default 0 (unused)." ).def(0);
option.add( basic::options::OptionKeys::cyclic_peptide::angle_length_relax_rounds, "The number of rounds of FastRelax to perform with flexible bond angles and bond lengths after each standard FastRelax step in the simple_cycpep_predict protocol.  Default 0 (unused)." ).def(0);
option.add( basic::options::OptionKeys::cyclic_peptide::cartesian_relax_rounds, "The number of rounds of Cartesian FastRelax to perform after each standard FastRelax step in the simple_cycpep_predict protocol.  Default 0 (unused)." ).def(0);
option.add( basic::options::OptionKeys::cyclic_peptide::use_classic_rama_for_sampling, "If true, classic Ramachandran tables are used for sampling instead of the RamaPrePro tables.  Default false (i.e. newer RamaPrePro tables are used by default)." ).def(false);
option.add( basic::options::OptionKeys::cyclic_peptide::n_methyl_positions, "If provided, then these positions are N-methylated.  Not used if not specified." );
option.add( basic::options::OptionKeys::cyclic_peptide::TBMB_positions, "If provided, then these positions will be linked by a 1,3,5-tris(bromomethyl)benzene crosslinker.  3N positions must be specified, and every group of three will be linked.  Unused if not specified." );
option.add( basic::options::OptionKeys::cyclic_peptide::use_TBMB_filters, "If true, then filters are applied based on distance between TBMB cysteines and on constraints to discard GenKIC solutions that can't be crosslinked easily.  True by default." ).def(true);
option.add( basic::options::OptionKeys::cyclic_peptide::TBMB_sidechain_distance_filter_multiplier, "A multiplier for the distance cutoff for TBMB cysteines.  Higher values result in more permissive filtering.  Default 1.0." ).def(1.0);
option.add( basic::options::OptionKeys::cyclic_peptide::TBMB_constraints_energy_filter_multiplier, "A multiplier for the constraints energy for TBMB cysteines.  Higher values result in more permissive filtering.  Default 1.0." ).def(1.0);
option.add( basic::options::OptionKeys::cyclic_peptide::link_all_cys_with_TBMB, "If true, then all cysteine residues in the peptide are linked with 1,3,5-tris(bromomethyl)benzene.  There must be exactly three cysteine residues for this flag to be used, and it cannot be used with the -TBMB_positions flag.  False/unused by default." ).def(false);
option.add( basic::options::OptionKeys::cyclic_peptide::require_symmetry_repeats, "If this option is used, then only backbones that are cN (or cN/m, if mirror symmetry is required) symmetric will be accepted.  For example, if set to 2, then only c2-symmetric backbones will be accepted.  Unused if not specified." ).def(1);
option.add( basic::options::OptionKeys::cyclic_peptide::require_symmetry_mirroring, "If this option is used, then only backbones with mirror symmetry are accepted.  Must be used with the -cyclic_peptide:require_symmetry_repeats flag." ).def(false);
option.add( basic::options::OptionKeys::cyclic_peptide::require_symmetry_angle_threshold, "The cutoff, in degrees, to use when comparing mainchain torsion values to determine whether symmetry repeats are truely symmetric.  Defaults to 10 degrees." ).def(10.0);
option.add( basic::options::OptionKeys::cyclic_peptide::require_symmetry_perturbation, "If provided, this is the magnitude of the perturbation to apply when copying mainchain dihedrals for symmetric sampling.  Allows slightly asymmetric conformations to be sampled.  Default is 0.0 (no perturbation)." ).def(0.0);
option.add( basic::options::OptionKeys::cyclic_peptide::MPI_processes_by_level, "The number of processes at each level of the parallel communications hierarchy, used only by the MPI version.  For example, '1 10 100' would mean that one emperor would talk to 10 masters, which would talk to 100 slaves (implying that each master is assigned 100 slaves).  Similarly, '1 100' would mean that one master would talk directly to 100 slaves.  Required for the MPI version." );
option.add( basic::options::OptionKeys::cyclic_peptide::MPI_batchsize_by_level, "The number of jobs sent at a time by each communication level to its children.  Given N levels, N-1 values must be specified.  For example, given 3 communications levels, '100 10' would mean that the emperor sends 100 jobs at a time to each master, which sends 10 jobs at a time to each slave.  Must be specified for the simple_cycpep_predict application in MPI mode." );
option.add( basic::options::OptionKeys::cyclic_peptide::MPI_sort_by, "The MPI version of the simple_cycpep_predict app has the option of writing out the top N% of solutions.  This determines the sort metric." ).legal("energy").legal("rmsd").legal("hbonds").def("energy");
option.add( basic::options::OptionKeys::cyclic_peptide::MPI_choose_highest, "When outputing the top N% of solutions, should I choose the ones with the higest score for the metric chosen (energy, rmsd, hbonds, etc.) or lowest?  Default false (chose lowest)." ).def(false);
option.add( basic::options::OptionKeys::cyclic_peptide::MPI_output_fraction, "The fraction of total structures that will be written out.  This is used in conjunction with 'MPI_sort_by' to output the top N% of job outputs.  For example, '-MPI_output_fraction 0.05 -MPI_sort_by rmsd' means that the 5% of structures with the lowest RMSD values will be written out." ).def(1.0);
option.add( basic::options::OptionKeys::cyclic_peptide::MPI_stop_after_time, "If this option is used, the emperor node will send a stop signal after an elapsed period of time, given in seconds.  Slaves jobs currently running will continue, but intermediate masters will not assign any more work.  Useful on HPC clusters with time limits, to ensure that jobs completed are collected at the end.  Unused if not specified." );
option.add( basic::options::OptionKeys::cyclic_peptide::MPI_pnear_lambda, "In MPI mode a goodness-of-funnel metric is automatically calculated at the end (PNear).  This value may be thought of as the probability, from 0 to 1, of the peptide being in the target conformation at any given time.  The parameter lambda controls the bredth of the Gaussian (in RMSD units -- Angstroms) that is used to determine whether a state is native-like or not.  Default 0.5 A." ).def(0.5);
option.add( basic::options::OptionKeys::cyclic_peptide::MPI_pnear_kbt, "In MPI mode a goodness-of-funnel metric is automatically calculated at the end (PNear).  This value may be thought of as the probability, from 0 to 1, of the peptide being in the target conformation at any given time.  The parameter kbt is the Boltzmann temperature that determines the extent to which higher energy states are likely to be sampled.  Default 1.0 Rosetta energy units." ).def(1.0);
option.add( basic::options::OptionKeys::dc::dc, "dc option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::dc::useZ, "Use absolute zaxis for scoring dc" );
option.add( basic::options::OptionKeys::ddg::ddg, "ddg option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::ddg::opt_input_structure, "No description" ).def(false);
option.add( basic::options::OptionKeys::ddg::pack_until_converge, "No description" ).def(false);
option.add( basic::options::OptionKeys::ddg::no_constraints, "No description" ).def(false);
option.add( basic::options::OptionKeys::ddg::use_rotamer_constraints_to_native, "No description" ).def(false);
option.add( basic::options::OptionKeys::ddg::suppress_checkpointing, "boinc specific options to suppress checkpointing behavior" ).def(false);
option.add( basic::options::OptionKeys::ddg::wt_only, "option added to minirosetta app in order to produce only refinement in wt structures" );
option.add( basic::options::OptionKeys::ddg::mut_only, "options added to minirosetta app in order to produce refinement in only mutant structure" );
option.add( basic::options::OptionKeys::ddg::output_silent, "No description" );
option.add( basic::options::OptionKeys::ddg::minimization_scorefunction, "No description" );
option.add( basic::options::OptionKeys::ddg::minimization_patch, "No description" );
option.add( basic::options::OptionKeys::ddg::min_cst, "Following sidechain optimization in the packer, should we then proceed to minimize the backbone at all.  Constraints will be used to keep the structure from moving too far." ).def(true);
option.add( basic::options::OptionKeys::ddg::lowest_x_decoys, "No description" );
option.add( basic::options::OptionKeys::ddg::local_opt_only, "No description" ).def(false);
option.add( basic::options::OptionKeys::ddg::print_per_res_diff, "No description" ).def(false);
option.add( basic::options::OptionKeys::ddg::mean, "No description" );
option.add( basic::options::OptionKeys::ddg::min, "No description" );
option.add( basic::options::OptionKeys::ddg::no_bb_movement, "No description" ).def(false);
option.add( basic::options::OptionKeys::ddg::initial_repack, "No description" ).def(false);
option.add( basic::options::OptionKeys::ddg::interface_ddg, "Calculate ddGs across an interface? Uses jump # specified for determining interface." ).def(0);
option.add( basic::options::OptionKeys::ddg::ens_variation, "No description" ).def(0.5);
option.add( basic::options::OptionKeys::ddg::sc_min_only, "No description" ).def(true);
option.add( basic::options::OptionKeys::ddg::min_cst_weights, "No description" ).def("talaris2013");
option.add( basic::options::OptionKeys::ddg::opt_radius, "No description" ).def(8.0);
option.add( basic::options::OptionKeys::ddg::output_dir, "No description" ).def("./");
option.add( basic::options::OptionKeys::ddg::last_accepted_pose_dir, "No description" ).def("./");
option.add( basic::options::OptionKeys::ddg::min_with_cst, "Used in ensemble generation" ).def(false);
option.add( basic::options::OptionKeys::ddg::temperature, "because I really dont know what the monte carlo temperature should be set to" ).def(10);
option.add( basic::options::OptionKeys::ddg::ramp_repulsive, "set fa_rep to 0.1, 0.33 of original value when minimizing in the minimization phase following packing" ).def(false);
option.add( basic::options::OptionKeys::ddg::mut_file, "alternate specification for mutations.  File format described in fix_bb_monomer_ddg.cc above the read_in_mutations function" );
option.add( basic::options::OptionKeys::ddg::out_pdb_prefix, "specifies the prefix assigned to output so that no overwriting happens" );
option.add( basic::options::OptionKeys::ddg::constraint_weight, "because that other option isnt working" ).def(1.0);
option.add( basic::options::OptionKeys::ddg::harmonic_ca_tether, "default CA tether for harmonic constraints" ).def(2.0);
option.add( basic::options::OptionKeys::ddg::iterations, "specifies the number of iterations of refinement" ).def(20);
option.add( basic::options::OptionKeys::ddg::out, "create output file of predicted ddgs" ).def("ddg_predictions.out");
option.add( basic::options::OptionKeys::ddg::debug_output, "specify whether or not to write a whole bunch of debug statements to standard out" ).def(false);
option.add( basic::options::OptionKeys::ddg::dump_pdbs, "specify whether or not to dump repacked wild-type and mutant pdbs" ).def(true);
option.add( basic::options::OptionKeys::ddg::weight_file, "specifies the weight-files to be used in calculations" ).def("ddg.wts");
option.add( basic::options::OptionKeys::DenovoProteinDesign::DenovoProteinDesign, "DenovoProteinDesign option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::DenovoProteinDesign::redesign_core, "redesign core of pdb" ).def(false);
option.add( basic::options::OptionKeys::DenovoProteinDesign::redesign_loops, "redesign loops of pdb" ).def(false);
option.add( basic::options::OptionKeys::DenovoProteinDesign::redesign_surface, "redesign surface of pdb" ).def(false);
option.add( basic::options::OptionKeys::DenovoProteinDesign::redesign_complete, "complete redesign of pdb" ).def(false);
option.add( basic::options::OptionKeys::DenovoProteinDesign::optimize_loops, "do serious loop modeling at the end of designrelax mover" );
option.add( basic::options::OptionKeys::DenovoProteinDesign::secondary_structure_file, "has fasta file format - describes secondary structure of desired target with H/C/E" );
option.add( basic::options::OptionKeys::DenovoProteinDesign::hydrophobic_polar_pattern, "has fasta file format - describes hydrophobic(B) polar(P) pattern" );
option.add( basic::options::OptionKeys::DenovoProteinDesign::use_template_sequence, "use the template pdbs sequence when creating starting structures" ).def(false);
option.add( basic::options::OptionKeys::DenovoProteinDesign::use_template_topology, "use templates phi/psi in loops and begin/end helix/sheet generate only template like starting structures" ).def(false);
option.add( basic::options::OptionKeys::DenovoProteinDesign::create_from_template_pdb, "create starting structure from a template pdb, follow with pdb name" );
option.add( basic::options::OptionKeys::DenovoProteinDesign::create_from_secondary_structure, "create starting structure from a file that contains H/C/E to describe topology or B/P pattern, has fasta file format" ).def(false);
option.add( basic::options::OptionKeys::dna::dna, "dna option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::dna::specificity::specificity, "specificity option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::dna::specificity::exclude_dna_dna, "No description" ).def(true);
option.add( basic::options::OptionKeys::dna::specificity::params, "vector of real-valued params" );
option.add( basic::options::OptionKeys::dna::specificity::frag_files, "files to collect frags from" );
option.add( basic::options::OptionKeys::dna::specificity::only_repack, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::specificity::design_DNA, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::specificity::soft_rep, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::specificity::dump_pdbs, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::specificity::fast, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::specificity::randomize_motif, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::specificity::Wfa_elec, "No description" ).def(0);
option.add( basic::options::OptionKeys::dna::specificity::Wdna_bs, "No description" ).def(0);
option.add( basic::options::OptionKeys::dna::specificity::Wdna_bp, "No description" ).def(0);
option.add( basic::options::OptionKeys::dna::specificity::minimize_tolerance, "No description" ).def(0.001);
option.add( basic::options::OptionKeys::dna::specificity::weights_tag, "No description" );
option.add( basic::options::OptionKeys::dna::specificity::weights_tag_list, "No description" );
option.add( basic::options::OptionKeys::dna::specificity::min_type, "No description" ).legal("linmin").legal("linmin_iterated").legal("linmin_iterated_atol").legal("dfpmin").legal("dfpmin_armijo").legal("dfpmin_armijo_nonmonotone").legal("dfpmin_atol").legal("dfpmin_armijo_atol").legal("dfpmin_armijo_nonmonoton_atol").legal("dfpmin_strong_wolfe").legal("dfpmin_strong_wolfe_atol").legal("lbfgs_armijo").legal("lbfgs_armijo_rescored").legal("lbfgs_armijo_atol").legal("lbfgs_armijo_nonmonotone").legal("lbfgs_armijo_nonmonotone_atol").legal("lbfgs_strong_wolfe").def("lbfgs_armijo_nonmonotone");
option.add( basic::options::OptionKeys::dna::specificity::mode, "No description" );
option.add( basic::options::OptionKeys::dna::specificity::score_function, "No description" );
option.add( basic::options::OptionKeys::dna::specificity::pre_minimize, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::specificity::post_minimize, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::specificity::pre_pack, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::specificity::nloop, "No description" ).def(20);
option.add( basic::options::OptionKeys::dna::specificity::n_inner, "No description" );
option.add( basic::options::OptionKeys::dna::specificity::n_outer, "No description" );
option.add( basic::options::OptionKeys::dna::specificity::nstep_water, "No description" ).def(0);
option.add( basic::options::OptionKeys::dna::specificity::moving_jump, "No description" ).def(0);
option.add( basic::options::OptionKeys::dna::specificity::motif_begin, "No description" ).def(0);
option.add( basic::options::OptionKeys::dna::specificity::motif_size, "No description" ).def(0);
option.add( basic::options::OptionKeys::dna::specificity::pdb_pos, "list of one or more positions in the input pdb, eg: -pdb_pos 125:A 127:A 4:C" ).def("");
option.add( basic::options::OptionKeys::dna::specificity::methylate, "list of one or more positions in the input pdb to be methylated, eg: -methylate 125:A 127:A 4:C" ).def("");
option.add( basic::options::OptionKeys::dna::specificity::dna_backbone_torsion_sdevs, "No description" );
option.add( basic::options::OptionKeys::dna::specificity::dna_sugar_torsion_sdev, "No description" ).def(4.0);
option.add( basic::options::OptionKeys::dna::specificity::dna_chi_torsion_sdev, "No description" ).def(15.0);
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_wtd_tag, "No description" );
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_for_bb, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_ramp_width_A2, "No description" ).def(5.0);
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_overlap_width_A2, "No description" ).def(5.0);
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_water_fade, "No description" ).def(1.0);
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_wtd_prefactors, "6 scale factors that are applied to the lk_ball_wtd per-atom weights; the order is <donor-iso> <donor-ball> <acceptor-iso> <acceptor-ball> <don+acc-iso> <don+acc-ball>; where <don+acc> means atom-types that are both donors and acceptors (SP3 hybridized OH for example)" );
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_waters_sp2, "The geometry of sp2 acceptor waters in lk_ball. Format: ( <length_A> <angle_degrees> <torsion_degrees> )+  Default: 2.65 120 0  2.65 120 180.  No limit on #, but all three params must be specified for each" );
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_waters_sp3, "The geometry of sp3 acceptor waters in lk_ball. Format: ( <length_A> <angle_degrees> <torsion_degrees> )+  Default: 2.65 109 120  2.65 109 240.  No limit on #, but all three params must be specified for each" );
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_waters_ring, "The geometry of ring acceptor waters in lk_ball. Format: ( <length_A> <angle_degrees> <torsion_degrees> )+  Default: 2.65 180 0.  No limit on #, but all three params must be specified for each" );
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_waters_donor, "The geometry of donor waters in lk_ball. Length along N-H vector" );
option.add( basic::options::OptionKeys::dna::specificity::lk_ball_bridge_angle_widthscale, "The width scaling on the angular component of lk_ball_bridge (lower = tighter)" ).def(0.0);
option.add( basic::options::OptionKeys::dna::design::design, "design option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::dna::design::output_unbound_pdb, "write out an unbound pdb if doing binding score calculations" ).def(false);
option.add( basic::options::OptionKeys::dna::design::z_cutoff, "distance along DNA-axis from designing DNA bases to allow amino acids to design" ).lower(0).def(3.5);
option.add( basic::options::OptionKeys::dna::design::protein_scan, "single-residue scanning of protein residue types for binding and specificity scores" ).def("ACDEFGHIKLMNPQRSTVWY");
option.add( basic::options::OptionKeys::dna::design::checkpoint, "write/read checkpoint files for higher-level protocols that proceed linearly for long periods of time.  Provide a checkpoint filename after this option." ).def("");
option.add( basic::options::OptionKeys::dna::design::minimize, "Perform minimization in DNA design mode." ).def(false);
option.add( basic::options::OptionKeys::dna::design::dna_defs, "" ).def("");
option.add( basic::options::OptionKeys::dna::design::dna_defs_file, "" ).def("");
option.add( basic::options::OptionKeys::dna::design::nopdb, "use this flag to disable pdb output" ).def(false);
option.add( basic::options::OptionKeys::dna::design::designable_second_shell, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::design::base_contacts_only, "No description" ).def(false);
option.add( basic::options::OptionKeys::dna::design::probe_specificity, "Rapidly estimate the explicit specificity of DNA designs during fixed-backbone repacking" ).def(1);
option.add( basic::options::OptionKeys::dna::design::reversion_scan, "Try to revert spurious mutations after designing" ).def(false);
option.add( basic::options::OptionKeys::dna::design::binding, "compute a protein-DNA binding energy" ).def(false);
option.add( basic::options::OptionKeys::dna::design::Boltz_temp, "temperature for Boltzmann calculations" ).def(0.6);
option.add( basic::options::OptionKeys::dna::design::repack_only, "Do not allow protein sequences to mutate arbitrarily" ).def(false);
option.add( basic::options::OptionKeys::dna::design::sparse_pdb_output, "Output only coordinates that change relative to the input structure" ).def(false);
option.add( basic::options::OptionKeys::dna::design::specificity::specificity, "specificity option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::dna::design::specificity::output_structures, "output structures for each sequence combination" ).def(false);
option.add( basic::options::OptionKeys::dna::design::specificity::include_dna_potentials, "include DNA potentials in calculations of DNA sequence specificity" ).def(false);
option.add( basic::options::OptionKeys::dna::design::reversion::reversion, "reversion option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::dna::design::reversion::dscore_cutoff, "limit for acceptable loss in energy" ).def(1.5);
option.add( basic::options::OptionKeys::dna::design::reversion::dspec_cutoff, "limit for acceptable loss in specificity" ).def(-0.05);
option.add( basic::options::OptionKeys::docking::kick_relax, "Add relax step at the end of symmetric docking" ).def(false);
option.add( basic::options::OptionKeys::docking::docking, "Docking option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::docking::view, "Decide whether to use the viewer (graphical) or not" ).def(false);
option.add( basic::options::OptionKeys::docking::no_filters, "Toggle the use of filters" ).def(false);
option.add( basic::options::OptionKeys::docking::design_chains, "Pass in the one-letter chain identifiers, separated by space, for each chain to design: -design_chains A B" ).shortd( "Which chains do we want to allow to design?" );
option.add( basic::options::OptionKeys::docking::recover_sidechains, "usually side-chains are taken from the input structure if it is fullatom - this overrides this behavior and takes sidechains from the pdb-file" ).shortd( "take sidechains from this pdb" );
option.add( basic::options::OptionKeys::docking::partners, "defines docking partners by ChainID, example: docking chains L+H with A is -partners LH_A" ).shortd( "defines docking partners by chainID for multichain docking partners" ).def("_");
option.add( basic::options::OptionKeys::docking::docking_local_refine, "Do a local refinement of the docking position (high resolution)" ).shortd( "Skip centroid mode" ).def(false);
option.add( basic::options::OptionKeys::docking::low_res_protocol_only, "Run only low resolution docking, skip high resolution docking" ).shortd( "Only low resolution" ).def(false);
option.add( basic::options::OptionKeys::docking::randomize1, "Randomize the first docking partner." ).shortd( "Randomize the first docking partner." ).def(false);
option.add( basic::options::OptionKeys::docking::randomize2, "Randomize the second docking partner." ).shortd( "Randomize the second docking partner." ).def(false);
option.add( basic::options::OptionKeys::docking::use_ellipsoidal_randomization, "Modify docking randomization to use ellipsoidal rather than spherical method." ).shortd( "Use ellipsoidal docking randomization." ).def(false);
option.add( basic::options::OptionKeys::docking::spin, "Spin a second docking partner around axes from center of mass of partner1 to partner2" ).shortd( "Spin a second docking partner." ).def(false);
option.add( basic::options::OptionKeys::docking::tilt, "tilt the docking partners at a random angle  : -tilt PARTNER1_MAX_DEGREES PARTNER2_MAX_DEGREES." ).shortd( "tilt the docking partners at a random angle around the sliding axis" ).n(2);
option.add( basic::options::OptionKeys::docking::tilt1_center, "resID around which rotation of partner1 is centered (default: center of mass of partner 1" ).shortd( "resID around which rotation of partner1 is centered (CA carbon)" ).def("");
option.add( basic::options::OptionKeys::docking::tilt2_center, "resID around which rotation of partner2 is centered (default: center of mass of partner 2" ).shortd( "resID around which rotation of partner2 is centered (CA carbon)" ).def("");
option.add( basic::options::OptionKeys::docking::dock_pert, "Do a small perturbation with partner two: -dock_pert ANGSTROMS DEGREES.  Good values for protein docking are 3 A and 8 deg." ).shortd( "Do a small perturbation with partner two: -dock_pert ANGSTROMS DEGREES." ).n(2);
option.add( basic::options::OptionKeys::docking::uniform_trans, "No description" ).shortd( "Uniform random repositioning within a sphere of the given radius." );
option.add( basic::options::OptionKeys::docking::center_at_interface, "Perform all initial perturbations with the center of rotation at the interface between partners instead of at the center of mass of the oppposite partner." ).shortd( "Perform all initial perturbations with the center of rotation at the interface between partners" ).def(false);
option.add( basic::options::OptionKeys::docking::dock_mcm_first_cycles, "Perfrom 4 cycles to let the filter decide to continue." ).shortd( "First cycle of DockMCMProtocol." ).def(4);
option.add( basic::options::OptionKeys::docking::dock_mcm_second_cycles, "If the first cycle pass the fliter, continue 45 cycles." ).shortd( "Second cycle of DockMCMProtocol." ).def(45);
option.add( basic::options::OptionKeys::docking::docking_centroid_outer_cycles, "Outer cycles during cking rigid body adaptive moves." ).shortd( "Outer cycles during docking rigid body adaptive moves." ).def(10);
option.add( basic::options::OptionKeys::docking::docking_centroid_inner_cycles, "Inner cycles during docking rigid body adaptive moves." ).shortd( "Inner cycles during docking rigid body adaptive moves." ).def(50);
option.add( basic::options::OptionKeys::docking::dock_min, "Minimize the final fullatom structure." ).shortd( "Minimize the final fullatom structure." ).def(false);
option.add( basic::options::OptionKeys::docking::flexible_bb_docking, "How to do flexible backbone docking, if at all. Choices include fixedbb, ccd, alc, and backrub." ).shortd( "How to do flexible backbone docking, if at all." ).def("fixedbb");
option.add( basic::options::OptionKeys::docking::flexible_bb_docking_interface_dist, "Distance between chains required to define a residue as having flexible backbone (ie. loop)." ).shortd( "Distance between chains required to define a residue as having flexible backbone (ie. loop)." ).def(10.0);
option.add( basic::options::OptionKeys::docking::ensemble1, "turns on ensemble mode for partner 1.  String is multi-model pdb file" ).shortd( "denotes partner1 as an ensemble" ).def("");
option.add( basic::options::OptionKeys::docking::ensemble2, "turns on ensemble mode for partner 2.  String is multi-model pdb file" ).shortd( "denotes partner2 as an ensemble" ).def("");
option.add( basic::options::OptionKeys::docking::dock_mcm_trans_magnitude, "The magnitude of the translational perturbation during mcm in docking." ).shortd( "The magnitude of the translational perturbation during mcm in docking." ).def(0.1);
option.add( basic::options::OptionKeys::docking::dock_mcm_rot_magnitude, "The magnitude of the rotational perturbation during mcm in docking." ).shortd( "The magnitude of the rotational perturbation during mcm in docking." ).def(5.0);
option.add( basic::options::OptionKeys::docking::minimization_threshold, "Threhold for Rosetta to decide whether to minimize jump after a rigid_pert" ).shortd( "Threhold for Rosetta to decide whether to minimize jump after a rigid_pert" ).def(15);
option.add( basic::options::OptionKeys::docking::temperature, "Temperature setting for the mc object during rigid-body docking" ).shortd( "Temperature setting for the mc object during rigid-body docking" ).def(0.8);
option.add( basic::options::OptionKeys::docking::repack_period, "full repack period during dockingMCM" ).shortd( "full repack period during dockingMCM" ).def(8);
option.add( basic::options::OptionKeys::docking::extra_rottrial, "extra rotamer trial after minimization" ).shortd( "extra rotamer trial after minimization" ).def(false);
option.add( basic::options::OptionKeys::docking::dock_rtmin, "does rotamer trials with minimization, RTMIN" ).shortd( "does rotamer trials with minimization, RTMIN" ).def(false);
option.add( basic::options::OptionKeys::docking::sc_min, "does sidechain minimization of interface residues" ).shortd( "does sidechain minimization of interface residues" ).def(false);
option.add( basic::options::OptionKeys::docking::norepack1, "Do not repack the side-chains of partner 1." ).shortd( "Do not repack the side-chains of partner 1." ).def(false);
option.add( basic::options::OptionKeys::docking::norepack2, "Do not repack the side-chains of partner 2." ).shortd( "Do not repack the side-chains of partner 2." ).def(false);
option.add( basic::options::OptionKeys::docking::bb_min_res, "Minimize backbone at these positions." ).shortd( "Minimize backbone at these positions." );
option.add( basic::options::OptionKeys::docking::sc_min_res, "Minimize backbone at these positions." ).shortd( "Minimize backbone at these positions." );
option.add( basic::options::OptionKeys::docking::dock_ppk, "docking prepack mode" ).shortd( "docking prepack mode" ).def(false);
option.add( basic::options::OptionKeys::docking::max_repeats, "If a decoy does not pass the low- and high-resolution filters, how many attempts to make before failur" ).shortd( "how many repeats to use" ).def(1000);
option.add( basic::options::OptionKeys::docking::dock_lowres_filter, "manually sets the lowres docking filter: -dock_lowres_filter <INTERCHAIN_CONTACT CUTOFF> <INTERCHAIN_VDW CUTOFF> <RESTRAINT CUTOFF>. Default values for protein docking are 10.0 and 1.0" ).shortd( "manually sets the lowres docking filter: -dock_lowres_filter <INTERCHAIN_CONTACT CUTOFF> <INTERCHAIN_VDW CUTOFF> <RESTRAINT CUTOFF>" );
option.add( basic::options::OptionKeys::docking::multibody, "List of jumps allowed to move during docking" );
option.add( basic::options::OptionKeys::docking::ignore_default_docking_task, "Allows the user to define another task to give to Docking and will ignore the default DockingTask.  Task will default to designing everything if no other TaskFactory is given to docking." ).shortd( "Ignore the DockingTask" ).def(false);
option.add( basic::options::OptionKeys::docking::low_patch, "Name of weights patch file (without extension .wts) to use during rigid body " );
option.add( basic::options::OptionKeys::docking::high_patch, "Name of weights patch file (without extension .wts) to use during docking" );
option.add( basic::options::OptionKeys::docking::high_min_patch, "Name of weights patch file (without extension .wts) to use during " );
option.add( basic::options::OptionKeys::docking::pack_patch, "Name of weights patch file (without extension .wts) to use during packing" );
option.add( basic::options::OptionKeys::docking::use_legacy_protocol, "Use the legacy high resolution docking algorithm for output compatibility." ).shortd( "Use the legacy high resolution docking algorithm." ).def(false);
option.add( basic::options::OptionKeys::docking::docklowres_trans_magnitude, "The magnitude of the translational perturbation during lowres in docking." ).shortd( "The magnitude of the translational perturbation during lowres in docking." ).def(0.7);
option.add( basic::options::OptionKeys::docking::docklowres_rot_magnitude, "The magnitude of the rotational perturbation during lowres in docking." ).shortd( "The magnitude of the rotational perturbation during lowres in docking." ).def(5.0);
option.add( basic::options::OptionKeys::docking::ligand::ligand, "docking:ligand option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::docking::ligand::protocol, "Which protocol to run?" ).def("abbreviated");
option.add( basic::options::OptionKeys::docking::ligand::soft_rep, "Use soft repulsive potential?" ).def(false);
option.add( basic::options::OptionKeys::docking::ligand::tweak_sxfn, "Apply default modifications to the score function?" ).def(true);
option.add( basic::options::OptionKeys::docking::ligand::old_estat, "Emulate Rosetta++ electrostatics? (higher weight, ignore protein-protein)" ).def(false);
option.add( basic::options::OptionKeys::docking::ligand::random_conformer, "Start from a random ligand rotamer chosen from the library" ).def(false);
option.add( basic::options::OptionKeys::docking::ligand::improve_orientation, "Do N cycles of randomization to minimize clashes with backbone" );
option.add( basic::options::OptionKeys::docking::ligand::mutate_same_name3, "Allow ligand to 'design' to residue types with same name3?  Typically used for protonation states / tautomers." ).def(false);
option.add( basic::options::OptionKeys::docking::ligand::subset_to_keep, "When selecting a subset of ligand poses, what fraction (number if > 1.0) to keep?" ).def(0.05);
option.add( basic::options::OptionKeys::docking::ligand::min_rms, "When selecting a subset of ligand poses, all must differ by at least this amount." ).def(0.8);
option.add( basic::options::OptionKeys::docking::ligand::max_poses, "When selecting a subset of ligand poses, select as most this many." ).def(50);
option.add( basic::options::OptionKeys::docking::ligand::minimize_ligand, "Allow ligand torsions to minimize?" ).def(false);
option.add( basic::options::OptionKeys::docking::ligand::harmonic_torsions, "Minimize with harmonic restraints with specified stddev (in degrees)" ).def(10.0);
option.add( basic::options::OptionKeys::docking::ligand::use_ambig_constraints, "Use ambiguous constraints to restrain torsions instead of adding and removing constraints" ).def(false);
option.add( basic::options::OptionKeys::docking::ligand::shear_moves, "Do N pseudo-shear moves on ligand torsions per MCM cycle" ).def(0);
option.add( basic::options::OptionKeys::docking::ligand::minimize_backbone, "Allow protein backbone to minimize?  Restrained except near ligand." ).def(false);
option.add( basic::options::OptionKeys::docking::ligand::harmonic_Calphas, "Minimize with harmonic restraints with specified stddev (in Angstroms)" ).def(0.2);
option.add( basic::options::OptionKeys::docking::ligand::tether_ligand, "Restrain ligand to starting point with specified stddev (in Angstroms)" );
option.add( basic::options::OptionKeys::docking::ligand::start_from, "One or more XYZ locations to choose for the ligand:  -start_from X1 Y1 Z1  -start_from X2 Y2 Z2  ..." );
option.add( basic::options::OptionKeys::docking::ligand::option_file, "Name of Ligand Option File for use with multi_ligand_dock application" );
option.add( basic::options::OptionKeys::docking::ligand::ligand_ensemble, "Weight for correlation adjustment in ligand ensemble docking, ignores ligand-ligand interactions if value is not zero" ).def(0);
option.add( basic::options::OptionKeys::docking::ligand::grid::grid, "docking:ligand:grid option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::docking::ligand::grid::grid_kin, "Write kinemage version of generated grid to named file" );
option.add( basic::options::OptionKeys::docking::ligand::grid::grid_map, "Write grid to named file as electron density in BRIX (aka `O'-map) format" );
option.add( basic::options::OptionKeys::DomainAssembly::DomainAssembly, "DomainAssembly option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::DomainAssembly::da_setup, "run DomainAssembly setup routine" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::DomainAssembly::da_setup_option_file, "input list of pdbs and linker sequences" ).def("--");
option.add( basic::options::OptionKeys::DomainAssembly::da_setup_output_pdb, "PDB file output by DomainAssemblySetup" ).def("--");
option.add( basic::options::OptionKeys::DomainAssembly::da_linker_file, "input file with linker definitions" ).def("--");
option.add( basic::options::OptionKeys::DomainAssembly::da_require_buried, "Input file containing residues to be buried in the domain interface" ).def("--");
option.add( basic::options::OptionKeys::DomainAssembly::da_start_pdb, "input pdb for linker optimization" ).def("--");
option.add( basic::options::OptionKeys::DomainAssembly::run_fullatom, "Run fullatom stage of the protocol" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::DomainAssembly::run_centroid, "Run centroid stage of the protocol" ).legal(true).legal(false).def(false);
option.add( basic::options::OptionKeys::DomainAssembly::run_centroid_abinitio, "Run centroid abinitio stage of the protocol" ).legal(true).legal(false).def(true);
option.add( basic::options::OptionKeys::DomainAssembly::da_nruns, "number of runs" ).def(1);
option.add( basic::options::OptionKeys::DomainAssembly::da_start_pdb_num, "starting number for output pdb files" ).def(1);
option.add( basic::options::OptionKeys::DomainAssembly::da_linker_file_rna, "input file with moveable RNA definitions" ).def("--");

}
inline void add_rosetta_options_8( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::DomainAssembly::residues_repack_only, "Residues not to be redesigned under any circumstances" );
option.add( basic::options::OptionKeys::DomainAssembly::da_eval_pose_map, "input file that maps pose coordinates to structurally related positions of native pose" );
option.add( basic::options::OptionKeys::edensity::edensity, "edensity option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::edensity::debug, "No description" ).def(false);
option.add( basic::options::OptionKeys::edensity::mapfile, "No description" );
option.add( basic::options::OptionKeys::edensity::mapreso, "No description" ).def(0.0);
option.add( basic::options::OptionKeys::edensity::grid_spacing, "No description" ).def(0.0);
option.add( basic::options::OptionKeys::edensity::centroid_density_mass, "No description" ).def(0.0);
option.add( basic::options::OptionKeys::edensity::sliding_window, "No description" ).def(1);
option.add( basic::options::OptionKeys::edensity::cryoem_scatterers, "No description" ).def(false);
option.add( basic::options::OptionKeys::edensity::force_apix, "force pixel spacing to take a particular value" ).def(0.0);
option.add( basic::options::OptionKeys::edensity::fastdens_wt, "wt of fast edens score" ).def(0.0);
option.add( basic::options::OptionKeys::edensity::fastdens_params, "parameters for fastdens scoring" );
option.add( basic::options::OptionKeys::edensity::legacy_fastdens_score, "use the pre-June 2013 normalization for scoring" ).def(false);
option.add( basic::options::OptionKeys::edensity::sliding_window_wt, "wt of edens sliding-window score" ).def(0.0);
option.add( basic::options::OptionKeys::edensity::score_sliding_window_context, "when using sl. win. density fit, include neighbor atoms (slows trajectory)" ).def(false);
option.add( basic::options::OptionKeys::edensity::whole_structure_ca_wt, "wt of edens centroid (CA-only) scoring" ).def(0.0);
option.add( basic::options::OptionKeys::edensity::whole_structure_allatom_wt, "wt of edens centroid (allatom) scoring" ).def(0.0);
option.add( basic::options::OptionKeys::edensity::debug_derivatives, "calculate numeric derivatives for density terms and compare with analytical" ).def(false);
option.add( basic::options::OptionKeys::edensity::realign, "how to initially align the pose to density" ).legal("no").legal("min").legal("random").legal("membrane").legal("membrane_min").def("no");
option.add( basic::options::OptionKeys::edensity::membrane_axis, "the membrane normal axis" ).def("Z");
option.add( basic::options::OptionKeys::edensity::atom_mask, "override default (=3.2A) atom mask radius to this value (hi-res scoring)" ).def(3.2);
option.add( basic::options::OptionKeys::edensity::atom_mask_min, "override the 3 sigma minimum value which takes precedence over atom_mask value (hi-res scoring)" ).def(2.0);
option.add( basic::options::OptionKeys::edensity::ca_mask, "override default (=6A) CA mask radius to this value (low-res scoring)" ).def(6.0);
option.add( basic::options::OptionKeys::edensity::score_symm_complex, "If set, scores the structure over the entire symmetric complex; otherwise just use controlling monomer" ).def(false);
option.add( basic::options::OptionKeys::edensity::sc_scaling, "Scale sidechain density by this amount (default same as mainchain density)" ).def(1.0);
option.add( basic::options::OptionKeys::edensity::n_kbins, "Number of B-factor bins" ).def(1);
option.add( basic::options::OptionKeys::edensity::unmask_bb, "Only include sidechain atoms in atom mask" ).def(false);
option.add( basic::options::OptionKeys::edensity::render_density, "render electron density in graphics mode build" ).def(false);
option.add( basic::options::OptionKeys::enzdes::enzdes, "enzdes option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::enzdes::checkpoint, "write/read checkpoint files to the desired filename." ).def("");
option.add( basic::options::OptionKeys::enzdes::enz_score, "prevent repacking in enzyme design calculation" ).def(false);
option.add( basic::options::OptionKeys::enzdes::enz_repack, "prevent redesign in enzyme design calculation" ).def(false);
option.add( basic::options::OptionKeys::enzdes::cst_opt, "pre design constraint minimization" ).def(false);
option.add( basic::options::OptionKeys::enzdes::cst_predock, "docks a ligand relative the catalytic residue" ).def(false);
option.add( basic::options::OptionKeys::enzdes::trans_magnitude, "rigid body translation in Angstrom" ).def(0.1);
option.add( basic::options::OptionKeys::enzdes::rot_magnitude, "rigid body rotation in deg" ).def(2);
option.add( basic::options::OptionKeys::enzdes::dock_trials, "number of docking trials" ).def(100);
option.add( basic::options::OptionKeys::enzdes::cst_min, "after design minimization, constraints turned off" ).def(false);
option.add( basic::options::OptionKeys::enzdes::cst_design, "invokes actual design" ).def(false);
option.add( basic::options::OptionKeys::enzdes::design_min_cycles, "determines how many iterations of designing/minimizing are done during a design run" ).def(1);
option.add( basic::options::OptionKeys::enzdes::make_consensus_mutations, "Invokes mutations back to sequence profile consensus throughout whole protein in EnzdesFixBB protocol. sequence profile file must be specified through -in:pssm option." ).def(false);
option.add( basic::options::OptionKeys::enzdes::bb_min, "allows backbone of active site residues to move during cst_opt and cst_min. In the cst_opt stage, residue Cas will be constrained to their original positions." ).def(false);
option.add( basic::options::OptionKeys::enzdes::bb_min_allowed_dev, "distance by which Cas are allowed to move during backbone minimization before a penalty is assigned." ).def(0.5);
option.add( basic::options::OptionKeys::enzdes::loop_bb_min_allowed_dev, "distance by which Cas are allowed to move during backbone minimization before a penalty is assigned. Applied only for loops as determined by DSSP." ).def(0.5);
option.add( basic::options::OptionKeys::enzdes::minimize_ligand_torsions, "degrees by which ligand torsions are allowed to rotate before a penalty is assigned. Only those torsions which have diversity in the conformational ensemble are allowed this std dev. rest are constrained to 0.1" ).def(10.0);
option.add( basic::options::OptionKeys::enzdes::minimize_all_ligand_torsions, "allows constrained minimization of all ligand torsions using stddev." ).def(10.0);
option.add( basic::options::OptionKeys::enzdes::chi_min, "allows chi values of active site residues to move during cst_opt and cst_min." ).def(false);
option.add( basic::options::OptionKeys::enzdes::min_all_jumps, "allows all jumps in the pose to minimize  during cst_opt and cst_min. By default only ligand-associated jumps minimize" ).def(false);
option.add( basic::options::OptionKeys::enzdes::cst_dock, "ligand docking after design. By default, constraints (except covalent connections will be turned off for this stage." ).def(false);
option.add( basic::options::OptionKeys::enzdes::run_ligand_motifs, "run ligand motif search and add motif rotamers to packer" ).def(false);
option.add( basic::options::OptionKeys::enzdes::enz_debug, "invokes various debug routines around the enzdes code" ).def(false);
option.add( basic::options::OptionKeys::enzdes::cstfile, "file that contains all necessary constraints for an enzyme design calculation" ).def("constraints.cst");
option.add( basic::options::OptionKeys::enzdes::enz_loops_file, "file that contains definitions of loop regions" ).def("eloops.els");
option.add( basic::options::OptionKeys::enzdes::flexbb_protocol, "triggers flexible backbone design" ).def(false);
option.add( basic::options::OptionKeys::enzdes::remodel_protocol, "triggers remodel protocol design" ).def(false);
option.add( basic::options::OptionKeys::enzdes::kic_loop_sampling, "Generate alternate loop conformations using KIC loop closure instead of backrub" ).def(false);
option.add( basic::options::OptionKeys::enzdes::dump_loop_samples, "yes/no? Create loop pdb files named loopreg_[regionid]_[whichsample].pdb for the chosen loop samples; if 'quit_afterwards' is given, then the program exits after all loops have been generated" ).legal("no").legal("yes").legal("quit_afterwards").def("no");
option.add( basic::options::OptionKeys::enzdes::fix_catalytic_aa, "preventing catalytic aa from repacking" ).def(false);
option.add( basic::options::OptionKeys::enzdes::additional_packing_ligand_rb_confs, "Ligand Rotamers will be built at additional random rigid body positions during packing" ).def(0);
option.add( basic::options::OptionKeys::enzdes::ex_catalytic_rot, "convenience option to use higher number of rotamers for catalytic residues. The chosen level will be applied to all chis of every catalytic residue." ).legal(0).legal(1).legal(2).legal(3).legal(4).legal(5).legal(6).legal(7).def(1);
option.add( basic::options::OptionKeys::enzdes::single_loop_ensemble_size, "number of conformations generated for each of the independent loops in a flexbb calculation" ).def(100);
option.add( basic::options::OptionKeys::enzdes::loop_generator_trials, "number of trials of that the respective loop generator(backrub/kinematic kic) does in enzdes flexbb" ).def(200);
option.add( basic::options::OptionKeys::enzdes::no_catres_min_in_loopgen, "prevents minimization of catalytic residues when generating loop ensembles" ).def(false);
option.add( basic::options::OptionKeys::enzdes::mc_kt_low, "low monte carlo limit for ensemble generation using backrub" ).def(0.6);
option.add( basic::options::OptionKeys::enzdes::mc_kt_high, "high monte carlo limit for ensemble generation using backrub" ).def(0.9);
option.add( basic::options::OptionKeys::enzdes::min_cacb_deviation, "Fragment uniqueness filter. On by default.  Minimum CA/CB average deviation that at least one residue must have from all other already-included fragments for a new fragment to be included" ).def(0.3);
option.add( basic::options::OptionKeys::enzdes::max_bb_deviation, "Fragment smoothness filter.  Off by default. Upper limit on the backbone average deviation a new fragment may have to its most-similar fragment that has already been included in the fragment set." ).def(0.1);
option.add( basic::options::OptionKeys::enzdes::max_bb_deviation_from_startstruct, "Fragment native-proximity Filter. Always on. Maximum tolerated backbone average deviation from the starting backbone for a fragment that to be included in the fragment set." ).def(1.5);
option.add( basic::options::OptionKeys::enzdes::remodel_trials, "how often each loop is being remodeled in the enzdes_remodel mover" ).def(100);
option.add( basic::options::OptionKeys::enzdes::remodel_secmatch, "if constrained interactions are missing in the pose during remodel, the SecondaryMatcher will be used to try to find them in the remodeled region. very experimental at this point" ).def(false);
option.add( basic::options::OptionKeys::enzdes::dump_inverse_rotamers, "in case of remodel secmatching against inverse rotamers, these rotamers will be dumped before the protocol starts for visual inspection by the user" ).def(false);
option.add( basic::options::OptionKeys::enzdes::remodel_aggressiveness, "determines the aggressiveness with which a given loop is remodeled. legal values between 0 and 1, where 1 is aggressive and 0 conservative." ).def(0.1);
option.add( basic::options::OptionKeys::enzdes::favor_native_res, "a bonus energy assigned to the native res during a design calculation" ).def(0.5);
option.add( basic::options::OptionKeys::enzdes::detect_design_interface, "automatically detect design/repack region around ligand(s)" ).def(false);
option.add( basic::options::OptionKeys::enzdes::include_catres_in_interface_detection, "if option -detect_design_interface is active, invoking this option causes all residues that are within the specified cuts of any catalytic residue are also set to designing/repacking" ).def(false);
option.add( basic::options::OptionKeys::enzdes::arg_sweep_interface, "Use protein-DNA design-like interface detection, involving generation of arginine rotamers at each position, checking to see if argininte can make interaction with ligand." ).def(false);
option.add( basic::options::OptionKeys::enzdes::arg_sweep_cutoff, "Interaction cutoff distance from arginine to ligand when performing arginine sweep interface detection." ).def(3.7);
option.add( basic::options::OptionKeys::enzdes::cut1, "option to specify redesign cutoff 1 in enzdes calculation" ).def(0.0);
option.add( basic::options::OptionKeys::enzdes::cut2, "option to specify redesign cutoff 2 in enzdes calculation" ).def(0.0);
option.add( basic::options::OptionKeys::enzdes::cut3, "option to specify repack cutoff 1 in enzdes calculation" ).def(10.0);
option.add( basic::options::OptionKeys::enzdes::cut4, "option to specify repack cutoff 2 in enzdes calculation" ).def(10.0);
option.add( basic::options::OptionKeys::enzdes::lig_packer_weight, "specifies the weights for protein ligand interaction during packing (and only packing!! )" ).def(1.0);
option.add( basic::options::OptionKeys::enzdes::no_unconstrained_repack, "no unconstrained repacking after the design stage" ).def(false);
option.add( basic::options::OptionKeys::enzdes::secmatch_Ecutoff, "the maximum constraint energy at which a residue is accepted in the secondary matcher" ).def(1.0);
option.add( basic::options::OptionKeys::enzdes::change_lig, "Can be used with the secondary matching protocol if different incarnations of the ligand are used for design and primary matching. The file needs to contain information on what atoms to superimpose." ).def("ligchange_file.txt");
option.add( basic::options::OptionKeys::enzdes::process_ligrot_separately, "In the EnzdesFixBB protocol, causes the protocol to be executed separately for all non_bb clashing ligand rotamers." ).def("default_lig");
option.add( basic::options::OptionKeys::enzdes::start_from_random_rb_conf, "In the EnzdesFixBB protocol, if there are additional ligand rigid body conformations available (from a multimodel pdb), a random one of these will be the starting point for the protocol." ).def(false);
option.add( basic::options::OptionKeys::enzdes::bb_bump_cutoff, "option to specify the maximum allowed backbone energie when replacing a new residue type" ).def(2.0);
option.add( basic::options::OptionKeys::enzdes::sc_sc_bump_cutoff, "option to specify the maximum allowed energy between two newly placed sidechains in the secondary matcher" ).def(2.0);
option.add( basic::options::OptionKeys::enzdes::no_packstat_calculation, "will determine whether the computationally intensive packstat calculation will be done at the end of a run" ).def(false);
option.add( basic::options::OptionKeys::enzdes::compare_native, "triggers comparison of every designed structure to its respective native pdb. the value of the option needs to be a directory path that contains all the native pdb files" ).def("./");
option.add( basic::options::OptionKeys::enzdes::final_repack_without_ligand, "if a scorefile is requested, this option triggers every structure to be repacked without the ligand. the resulting structure will be output in a multimodel pdb, and differences in energy and rmsd are added to the scorefile." ).def(false);
option.add( basic::options::OptionKeys::enzdes::dump_final_repack_without_ligand_pdb, "If option -final_repack_without_ligand is active, this option will cause the repacked structure to be separately dumped." ).def(false);
option.add( basic::options::OptionKeys::enzdes::parser_read_cloud_pdb, "read cloud format PDB for enzdes in rosetta scripts" ).def(false);
option.add( basic::options::OptionKeys::fast_loops::fast_loops, "fast_loops option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::fast_loops::window_accept_ratio, "windows with more than x percent of good loops in fast-loop sampling are used for scored-sampling" ).def(0.01);
option.add( basic::options::OptionKeys::fast_loops::nr_scored_sampling_passes, "good windows go into scored-sampling N times" ).def(4);
option.add( basic::options::OptionKeys::fast_loops::nr_scored_fragments, "scored loops sampled per good window each pass" ).def(20);
option.add( basic::options::OptionKeys::fast_loops::min_breakout_good_loops, "stop doing scored sampling if N or more good loops have been found" ).def(5);
option.add( basic::options::OptionKeys::fast_loops::min_breakout_fast_loops, "stop doing fast sampling if N or more good loops have been found" ).def(80);
option.add( basic::options::OptionKeys::fast_loops::min_good_loops, "treat as failure if less good-loops than" ).def(0);
option.add( basic::options::OptionKeys::fast_loops::min_fast_loops, "treat as failure if less fast-loops than" ).def(3);
option.add( basic::options::OptionKeys::fast_loops::vdw_delta, "accept as good loop if vdw-score < vdw-score-start+vdw-delta" ).def(0.5);
option.add( basic::options::OptionKeys::fast_loops::give_up, "if N scored_frag_attemps didnt give any good loop -- jump out" ).def(1000);
option.add( basic::options::OptionKeys::fast_loops::chainbreak_max, "accept only loops that have a maximum chainbreak score of... (sum of linear_chainbreak / chainbreak and overlap_chainbreak" ).def(0.2);
option.add( basic::options::OptionKeys::fast_loops::fragsample_score, "Scorefunction used durgin scored-frag sampling" ).def("loop_fragsample.wts");
option.add( basic::options::OptionKeys::fast_loops::fragsample_patch, "Patch weights for scorefunction used during scored-frag sampling" );
option.add( basic::options::OptionKeys::fast_loops::overwrite_filter_scorefxn, "force Scorefunction to be used during filter stage (instead last score of sampling protocol)" );
option.add( basic::options::OptionKeys::fast_loops::patch_filter_scorefxn, "apply patch to Scorefunction used during filter stage" );
option.add( basic::options::OptionKeys::fast_loops::filter_cst_file, "use these constraints to filter loops --- additional to whatever is in pose already" );
option.add( basic::options::OptionKeys::fast_loops::filter_cst_weight, "weight for constraints versus normal score (might contain additional constraints)" ).def(1.0);
option.add( basic::options::OptionKeys::fast_loops::fast_relax_sequence_file, "use this FastRelax protocol for loop-selection" );
option.add( basic::options::OptionKeys::flexpack::flexpack, "flexpack option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::flexpack::annealer::annealer, "annealer option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::flexpack::annealer::inner_iteration_scale, "Scale up or down the number of inner iterations in the flexpack annealer" );
option.add( basic::options::OptionKeys::flexpack::annealer::outer_iteration_scale, "Scale up or down the number of outer iterations in the flexpack annealer" );
option.add( basic::options::OptionKeys::flexpack::annealer::fixbb_substitutions_scale, "Scale up or down the number of fixed-backbone rotamer substitutions in the flexpack annealer" );
option.add( basic::options::OptionKeys::flexpack::annealer::pure_movebb_substitutions_scale, "Scale up or down the number of backbone moves" );
option.add( basic::options::OptionKeys::flexpack::annealer::rotsub_movebb_substitutions_scale, "Scale up or down the number of rotamer substitions with backbone moves" );
option.add( basic::options::OptionKeys::flexPepDocking::flexPepDocking, "flexPepDocking option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::flexPepDocking::params_file, "parameters file that describe the complex details, like anchor residues, etc." );
option.add( basic::options::OptionKeys::flexPepDocking::peptide_anchor, "Set the peptide anchor residue mannualy (instead of using the center of mass" ).lower(1).def(1);
option.add( basic::options::OptionKeys::flexPepDocking::receptor_chain, "chain-id of receptor protein" );
option.add( basic::options::OptionKeys::flexPepDocking::peptide_chain, "chain-id of peptide protein" );
option.add( basic::options::OptionKeys::flexPepDocking::pep_fold_only, "Only fold a peptide, without docking (no input receptor is expected in this case)." ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::lowres_abinitio, "Do a preemptive ab-initio low-resolution peptide docking" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::lowres_preoptimize, "Do a preemptive optimization in low resolution" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::flexPepDockingMinimizeOnly, "Just do simple minimization on input structure" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::extend_peptide, "start the protocol with the peptide in extended conformation" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::place_peptide_on_binding_site, "places peptide on the binding using SiteConstraints" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::sample_pcs, "number of principle components to use for initial peptide placement and flipping" ).lower(0).def(0);
option.add( basic::options::OptionKeys::flexPepDocking::SlideIntoContact, "Slides peptide toward or away from receptor to remove clashes" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::recalculate_foldtree, "recalculates foldtree after random RB perturbation" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::pep_refine, "High-resolution peptide refinement over receptor surface, equivalent to the obsolete -rbMCM -torsionsMCM flags" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::rbMCM, "Do rigid body mcm in the main loop of the protocol (obsolete)" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::torsionsMCM, "Do torsions (small/shear mcm in the main loop of the protocol (obsolete)" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::peptide_loop_model, "Do cycles of random loop modeling to peptide backbone" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::backrub_peptide, "Adds a backrub stage to the protocol" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::boost_fa_atr, "while ramping up the fa_rep, start from high atr and lower to normal" ).def(true);
option.add( basic::options::OptionKeys::flexPepDocking::ramp_fa_rep, "Whether to ramp the full-atom repulsive score during the protocol" ).def(true);
option.add( basic::options::OptionKeys::flexPepDocking::ramp_rama, "Whether to ramp the Ramachandran score during the protocol" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::flexpep_score_only, "just reads in the pose and scores it" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::ref_startstruct, "Alternative start structure for scoring statistics, instead of the original start structure (useful as reference for rescoring previous runs)" );
option.add( basic::options::OptionKeys::flexPepDocking::use_cen_score, "when in score_only mode, uses centroid weights to score" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::design_peptide, "Add a desing stage to each cycle of the RB-torsions perturbations" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::rep_ramp_cycles, "Number of cycles for the ramping up of repulsion term" ).lower(0).def(10);
option.add( basic::options::OptionKeys::flexPepDocking::mcm_cycles, "Number of cycles for the mcm procedures (rb/torsions)" ).lower(0).def(8);
option.add( basic::options::OptionKeys::flexPepDocking::random_phi_psi_preturbation, "Size of random perturbation of peptide's phi/psi" ).lower(0.0).def(0.0);
option.add( basic::options::OptionKeys::flexPepDocking::smove_angle_range, "Defines the perturbations size of small/sheer moves" ).lower(0.0).def(6.0);
option.add( basic::options::OptionKeys::flexPepDocking::min_receptor_bb, "Whether to include protein backbone in minimization" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::random_trans_start, "Size of random perturbation of peptide's rigid body translation" ).lower(0.0).def(0.0);
option.add( basic::options::OptionKeys::flexPepDocking::random_rot_start, "Size of random perturbation of peptide's rigid body rotation" ).lower(0.0).def(0.0);
option.add( basic::options::OptionKeys::flexPepDocking::flexpep_prepack, "Prepack an initial structure and exit" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::flexpep_noprepack1, "Do not repack the side-chains of partner 1 ( = globular protein)." ).shortd( "Do not prepack the side-chains of partner 1 ( = globular protein )." ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::flexpep_noprepack2, "Do not repack the side-chains of partner 2 ( = peptide)." ).shortd( "Do not prepack the side-chains of partner 2 ( = peptide)." ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::score_filter, "Only output decoys with scores lower than this filter." ).shortd( "Only output decoys with scores lower than this filter." ).def(10000.0);
option.add( basic::options::OptionKeys::flexPepDocking::hb_filter, "Only output decoys with more h-bonds than this filter." ).shortd( "Only output decoys with more h-bonds than this filter." ).lower(0).def(0);
option.add( basic::options::OptionKeys::flexPepDocking::hotspot_filter, "Only output decoys with more hotspots than this filter." ).shortd( "Only output decoys with more hotspots than this filter." ).lower(0).def(0);
option.add( basic::options::OptionKeys::flexPepDocking::frag5, "5-mer fragments for ab-initio flexPepDock" );
option.add( basic::options::OptionKeys::flexPepDocking::frag9_weight, "Relative weight of 9-mers in ab-initio" ).lower(0).def(0.1);
option.add( basic::options::OptionKeys::flexPepDocking::frag5_weight, "relative weight of 5-mers in ab-initio" ).lower(0).def(0.25);
option.add( basic::options::OptionKeys::flexPepDocking::frag3_weight, "Relative weight of 3-mers in ab-initio" ).lower(0).def(1.0);
option.add( basic::options::OptionKeys::flexPepDocking::pSer2Asp_centroid, "convert pSer to Asp during centroid mode" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::pSer2Glu_centroid, "convert pSer to Glu during centroid mode" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::dumpPDB_abinitio, "dump PDB during Monte-Carlo ab-initio" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::dumpPDB_lowres, "dump PDB during Monte-Carlo low-res" ).def(false);
option.add( basic::options::OptionKeys::flexPepDocking::dumpPDB_hires, "dump PDB during Monte-Carlo hi-res" ).def(false);
option.add( basic::options::OptionKeys::FloppyTail::FloppyTail, "FloppyTail option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::FloppyTail::flexible_start_resnum, "starting residue for the flexible region, using PDB numbering" ).def(180);
option.add( basic::options::OptionKeys::FloppyTail::flexible_stop_resnum, "stop residue for the flexible region, using PDB numbering.  If unspecified, it assumes the end of the pose." ).def(0);
option.add( basic::options::OptionKeys::FloppyTail::flexible_chain, "chain ID for flexible region" ).def("C");
option.add( basic::options::OptionKeys::FloppyTail::shear_on, "fraction of perturb moves when shear turns on (0.5 = halfway through)" ).def(1.0/3.0);
option.add( basic::options::OptionKeys::FloppyTail::pair_off, "turn off Epair electrostatics term.  Used once for a simple side experiment, not meant for general use." ).def(false);
option.add( basic::options::OptionKeys::FloppyTail::publication, "output statistics used in publication.  TURN OFF if not running publication demo." ).def(false);
option.add( basic::options::OptionKeys::FloppyTail::C_root, "Reroot the fold_tree to the C-terminus.  If your flexible region is N-terminal, or closer to the first half of the pose, this will speed computation." ).def(false);
option.add( basic::options::OptionKeys::FloppyTail::COM_root, "Reroot the fold_tree to the center of mass. This allows you to flop the N- & C-termini simultaneously." ).def(false);
option.add( basic::options::OptionKeys::FloppyTail::force_linear_fold_tree, "Force a linear fold tree.  Used in combination with C_root and reordering the chains in your input PDB to ensure you get exactly the right kinematics" ).def(false);
option.add( basic::options::OptionKeys::FloppyTail::debug, "debug mode (extra checks and pdb dumps)" ).def(false);
option.add( basic::options::OptionKeys::FloppyTail::cen_weights, "Use a different/custom scorefunction for centroid step" );
option.add( basic::options::OptionKeys::FloppyTail::perturb_show, "dump perturbed centroid pdbs as well as final results" ).def(false);
option.add( basic::options::OptionKeys::FloppyTail::perturb_cycles, "perturbation phase runs for <input> cycles" ).def(5);
option.add( basic::options::OptionKeys::FloppyTail::perturb_temp, "perturbation phase temperature for monte carlo" ).def(0.8);
option.add( basic::options::OptionKeys::FloppyTail::refine_cycles, "refinement phase runs for <input> cycles" ).def(5);
option.add( basic::options::OptionKeys::FloppyTail::refine_temp, "refinement phase temperature for monte carlo" ).def(0.8);
option.add( basic::options::OptionKeys::FloppyTail::refine_repack_cycles, "refinement phase runs repack every <input> cycles" ).lower(2).def(20);
option.add( basic::options::OptionKeys::FloppyTail::short_tail::short_tail, "short_tail option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::FloppyTail::short_tail::short_tail_fraction, "what fraction of the flexible segment is used in the short-tail section of refinement (not compatible with non-terminal flexible regions)" ).def(1.0);
option.add( basic::options::OptionKeys::FloppyTail::short_tail::short_tail_off, "fraction of refine cycles where movemap reverts to full tail (0.5 = halfway through)" ).def(0.0);
option.add( basic::options::OptionKeys::flxbb::flxbb, "flxbb option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::flxbb::view, "viewing pose during protocol" );
option.add( basic::options::OptionKeys::flxbb::ncycle, "number of cycles of design and relax" );
option.add( basic::options::OptionKeys::flxbb::constraints_sheet, "weight constraints between Ca atoms in beta sheet" );
option.add( basic::options::OptionKeys::flxbb::constraints_sheet_include_cacb_pseudotorsion, "puts an additional constraint on two residues paired in a beta-sheet to ensure their CA-CB vectors are pointing the same way." ).def(false);
option.add( basic::options::OptionKeys::flxbb::constraints_NtoC, "weight constraints between N- and C- terminal CA atoms" );
option.add( basic::options::OptionKeys::flxbb::filter_trial, "number of filtering trial " );
option.add( basic::options::OptionKeys::flxbb::filter_type, "filter type name, currently only packstat is available" );
option.add( basic::options::OptionKeys::flxbb::blueprint, "blueprint file " );
option.add( basic::options::OptionKeys::flxbb::movemap_from_blueprint, "viewing pose during protocol" );
option.add( basic::options::OptionKeys::flxbb::layer::layer, "design core, boundary, and surface with different aa types" ).def("normal").is_group(true);
option.add( basic::options::OptionKeys::fold_and_dock::fold_and_dock, "fold_and_dock option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::fold_and_dock::move_anchor_points, "move the anchor points that define symmetric coordinate system during symmetry fragment insertion" ).def(false);
option.add( basic::options::OptionKeys::fold_and_dock::set_anchor_at_closest_point, "set the anchor points that define symmetric coordinate system to the nearest point between two consecutive chains during fragment insertion" ).def(false);
option.add( basic::options::OptionKeys::fold_and_dock::rotate_anchor_to_x, "rotate the anchor residue to the x-axis before applying rigid body transformations" ).def(true);
option.add( basic::options::OptionKeys::fold_and_dock::trans_mag_smooth, "translation perturbation size for smooth refinement" ).def(0.1);
option.add( basic::options::OptionKeys::fold_and_dock::rot_mag_smooth, "rotational perturbation size for smooth refinement" ).def(1.0);
option.add( basic::options::OptionKeys::fold_and_dock::rb_rot_magnitude, "rotational perturbation size for rigid body pertubations" ).def(8.0);
option.add( basic::options::OptionKeys::fold_and_dock::rb_trans_magnitude, "translational perturbation size rigid body pertubations" ).def(3.0);
option.add( basic::options::OptionKeys::fold_and_dock::rigid_body_cycles, "number of rigid bosy cycles during fold and dock fragment insertion" ).def(50);
option.add( basic::options::OptionKeys::fold_and_dock::move_anchor_frequency, "Frequency of slide-anchor moves" ).def(1.0);
option.add( basic::options::OptionKeys::fold_and_dock::rigid_body_frequency, "The fraction of times rigid body cycles are applied during fragment assembly moves" ).def(0.2);
option.add( basic::options::OptionKeys::fold_and_dock::rigid_body_disable_mc, "Dissallow moves to be accepted locally by MC criteria within the rigid body mover " ).def(false);
option.add( basic::options::OptionKeys::fold_and_dock::slide_contact_frequency, "The fraction of times subunits are slided together during fragment assembly moves" ).def(0.1);
option.add( basic::options::OptionKeys::fold_cst::fold_cst, "fold_cst option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::fold_cst::constraint_skip_rate, "if e.g., 0.95 it will randomly select 5% if the constraints each round -- full-cst score in  extra column" ).def(0);
option.add( basic::options::OptionKeys::fold_cst::violation_skip_basis, "local skip_rate is viol/base" ).def(100);
option.add( basic::options::OptionKeys::fold_cst::violation_skip_ignore, "no skip for numbers below this level" ).def(10);
option.add( basic::options::OptionKeys::fold_cst::keep_skipped_csts, "final score only with active constraints" ).def(false);
option.add( basic::options::OptionKeys::fold_cst::no_minimize, "No minimization moves in fold_constraints protocol. Useful for testing wheather fragment moves alone can recapitulate a given structure." ).def(false);
option.add( basic::options::OptionKeys::fold_cst::force_minimize, "Minimization moves in fold_constraints protocol also if no constraints present" ).def(false);
option.add( basic::options::OptionKeys::fold_cst::seq_sep_stages, "give vector with sequence_separation after stage1, stage3 and stage4" ).def(0);
option.add( basic::options::OptionKeys::fold_cst::reramp_cst_cycles, "in stage2 do xxx cycles where atom_pair_constraint is ramped up" ).def(0);
option.add( basic::options::OptionKeys::fold_cst::reramp_start_cstweight, "drop cst_weight to this value and ramp to 1.0 in stage2 -- needs reramp_cst_cycles > 0" ).def(0.01);
option.add( basic::options::OptionKeys::fold_cst::reramp_iterations, "do X loops of annealing cycles" ).def(1);
option.add( basic::options::OptionKeys::fold_cst::skip_on_noviolation_in_stage1, "if constraints report no violations --- skip cycles" ).def(false);
option.add( basic::options::OptionKeys::fold_cst::stage1_ramp_cst_cycle_factor, "spend x*<standard cycles> on each step of sequence separation" ).def(0.25);
option.add( basic::options::OptionKeys::fold_cst::stage2_constraint_threshold, "stop runs that violate this threshold at end of stage2" ).def(0);
option.add( basic::options::OptionKeys::fold_cst::ignore_sequence_seperation, "usually constraints are switched on according to their separation in the fold-tree" ).def(false);
option.add( basic::options::OptionKeys::fold_cst::no_recover_low_at_constraint_switch, "dont recover low when max_seq_sep is increased" ).def(false);
option.add( basic::options::OptionKeys::fold_cst::ramp_coord_cst, "ramp coord csts just like chainbreak-weights during fold-cst" ).def(false);
option.add( basic::options::OptionKeys::fold_from_loops::fold_from_loops, "fold_from_loops option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::fold_from_loops::native_ca_cst, "derive constraints from the native topology" ).def(false);
option.add( basic::options::OptionKeys::fold_from_loops::swap_loops, "pdb of the target loops " ).def("--");
option.add( basic::options::OptionKeys::fold_from_loops::checkpoint, "write/read checkpoint files for nstruct. Provide a checkpoint filename after this option." ).def("");
option.add( basic::options::OptionKeys::fold_from_loops::ca_csts_dev, "standard deviation allowed to each constraint" ).def(0.5);
option.add( basic::options::OptionKeys::fold_from_loops::add_relax_cycles, "additional relax cycles" ).def(2);
option.add( basic::options::OptionKeys::fold_from_loops::loop_mov_nterm, "Movable region inside the provided loop(nterm)" ).def(0);
option.add( basic::options::OptionKeys::fold_from_loops::loop_mov_cterm, "Moveable region inside the provided loop(cterm)" ).def(0);
option.add( basic::options::OptionKeys::fold_from_loops::ca_rmsd_cutoff, "Filter the decoys to pass the relax-design stage " ).def(5.0);
option.add( basic::options::OptionKeys::fold_from_loops::res_design_bs, "enumerate the residues to be designed within the fixed binding site" );
option.add( basic::options::OptionKeys::fold_from_loops::clear_csts, "input loops file with ranges free of CA csts" ).def("--");
option.add( basic::options::OptionKeys::fold_from_loops::output_centroid, "output centroid structures befor the design stage" ).def(false);
option.add( basic::options::OptionKeys::fold_from_loops::add_cst_loop, "add CA csts of motif to constraint set" ).def(false);
option.add( basic::options::OptionKeys::frags::frags, "frags option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::frags::j, "Number of threads to use" );
option.add( basic::options::OptionKeys::frags::filter_JC, "Filter J-coupling values in the dynamic range " ).def(false);

}
inline void add_rosetta_options_9( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::frags::bounded_protocol, "makes the picker use bounded protocol to select fragments. This is teh default behavior" ).def(true);
option.add( basic::options::OptionKeys::frags::keep_all_protocol, "makes the picker use keep-all protocol to select fragments. The default is bounded protocol" ).def(false);
option.add( basic::options::OptionKeys::frags::quota_protocol, "quota protocol implies the use of a QuotaCollector and a QuotaSelelctor, no matter what user set up by other flags." ).def(false);
option.add( basic::options::OptionKeys::frags::nonlocal_pairs, "identifies and outputs nonlocal fragment pairs." ).def(false);
option.add( basic::options::OptionKeys::frags::fragment_contacts, "identifies and outputs fragment contacts." ).def(false);
option.add( basic::options::OptionKeys::frags::p_value_selection, "the final fragment selection will b based on p-value rather than on a total score for the given fragment" ).def(false);
option.add( basic::options::OptionKeys::frags::n_frags, "number of fragments per position" ).def(200);
option.add( basic::options::OptionKeys::frags::allowed_pdb, "provides a text file with allowed PDB chains (five characters per entry, e.g.'4mbA'). Only these PDB chains from Vall will be used to pick fragments" );
option.add( basic::options::OptionKeys::frags::ss_pred, "provides one or more files with secondary structure prediction (PsiPred SS2 format) , to be used by secondary structure scoring and quota selector. Each file name must be followed by a string ID." );
option.add( basic::options::OptionKeys::frags::spine_x, "provides phi and psi torsion angle predictions and solvent accessibility prediction from Spine-X" );
option.add( basic::options::OptionKeys::frags::depth, "provides residue depth values from DEPTH" );
option.add( basic::options::OptionKeys::frags::denied_pdb, "provides a text file with denied PDB chains (five characters per entry, e.g.'4mbA'). This way close homologs may be excluded from fragment picking." );
option.add( basic::options::OptionKeys::frags::frag_sizes, "sizes of fragments to pick from the vall" ).def(9).def(3).def(1);
option.add( basic::options::OptionKeys::frags::write_ca_coordinates, "Fragment picker will store CA Cartesian coordinates in output fragment files. By default only torsion coordinates are stored." ).def(false);
option.add( basic::options::OptionKeys::frags::write_scores, "Fragment picker will write scores in output fragment files." ).def(false);
option.add( basic::options::OptionKeys::frags::annotate, "read the annotation from the rosetta++ fragment file" ).def(false);
option.add( basic::options::OptionKeys::frags::nr_large_copies, "make N copies for each standard 9mer (or so) fragment" ).def(1);
option.add( basic::options::OptionKeys::frags::n_candidates, "number of fragment candidates per position; the final fragments will be selected from them" ).def(200);
option.add( basic::options::OptionKeys::frags::write_rama_tables, "Fragment picker will spit out sequence specific ramachandran score tables for your viewing pleasure. These ramachandran tables are based on the secondary structure predictions fed into RamaScore, and you may occasionally want to look at what the program has defined." ).def(false);
option.add( basic::options::OptionKeys::frags::rama_C, "Constant in RamaScore equation, command line is for optimization tests" ).def(0.0);
option.add( basic::options::OptionKeys::frags::rama_B, "Constant in RamaScore equation, command line is for optimization tests" ).def(1.0);
option.add( basic::options::OptionKeys::frags::sigmoid_cs_A, "Constant in CSScore equation, command line is for optimization tests" ).def(2.0);
option.add( basic::options::OptionKeys::frags::sigmoid_cs_B, "Constant in CSScore equation, command line is for optimization tests" ).def(4.0);
option.add( basic::options::OptionKeys::frags::seqsim_H, "Secondary structure type prediction multiplier, for use in fragment picking" ).def(1.0);
option.add( basic::options::OptionKeys::frags::seqsim_E, "Secondary structure type prediction multiplier, for use in fragment picking" ).def(1.0);
option.add( basic::options::OptionKeys::frags::seqsim_L, "Secondary structure type prediction multiplier, for use in fragment picking" ).def(1.0);
option.add( basic::options::OptionKeys::frags::rama_norm, "Used to multiply rama table values after normalization, default (0.0) means use raw counts (unnormalized)" ).def(0.0);
option.add( basic::options::OptionKeys::frags::describe_fragments, "Writes scores for all fragments into a file" ).def("");
option.add( basic::options::OptionKeys::frags::picking_old_max_score, "maximal score allowed for fragments picked by the old vall (used by RosettaRemodel)." ).def(1000000.0);
option.add( basic::options::OptionKeys::frags::write_sequence_only, "Fragment picker will output fragment sequences only. This option is for creating structure based sequence profiles using the FragmentCrmsdResDepth score." ).def(false);
option.add( basic::options::OptionKeys::frags::output_silent, "Fragment picker will output fragments into a silent file." ).def(false);
option.add( basic::options::OptionKeys::frags::output_index, "Fragment picker will output fragments into an index file." ).def(false);
option.add( basic::options::OptionKeys::frags::score_output_silent, "Fragment picker will output fragments into a silent file. Scores of relaxed fragments are added to the silent file." ).def(false);
option.add( basic::options::OptionKeys::frags::scoring::scoring, "scoring option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::frags::scoring::config, "scoring scheme used for picking fragments" ).def("");
option.add( basic::options::OptionKeys::frags::scoring::profile_score, "scoring scheme used for profile-profile comparison" ).def("L1");
option.add( basic::options::OptionKeys::frags::picking::picking, "picking option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::frags::picking::selecting_rule, "the way how fragments are selected from candidates, e.g. QuotaSelector of BestTotalScoreSelector" ).legal("QuotaSelector").legal("BestTotalScoreSelector").def("BestTotalScoreSelector");
option.add( basic::options::OptionKeys::frags::picking::selecting_scorefxn, "in the case user chose BestTotalScoreSelector to be used, this option provides a custom scoring function to be used at the selection step" );
option.add( basic::options::OptionKeys::frags::picking::quota_config_file, "provides a configuration file for quota selector" );
option.add( basic::options::OptionKeys::frags::picking::query_pos, "provide sequence position for which fragments will be picked. By default fragments are picked for the whole query sequence" );
option.add( basic::options::OptionKeys::frags::nonlocal::nonlocal, "nonlocal option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::frags::nonlocal::relax_input, "relax input before running protocol" );
option.add( basic::options::OptionKeys::frags::nonlocal::relax_input_with_coordinate_constraints, "relax input with coordinate constraints before running protocol" );
option.add( basic::options::OptionKeys::frags::nonlocal::relax_frags_repeats, "relax repeats for relaxing fragment pair" );
option.add( basic::options::OptionKeys::frags::nonlocal::single_chain, "non-local fragment pairs will be restricted to the same chain" );
option.add( basic::options::OptionKeys::frags::nonlocal::min_contacts_per_res, "minimum contacts per residue in fragment to be considered a fragment pair" ).def(1.0);
option.add( basic::options::OptionKeys::frags::nonlocal::max_ddg_score, "maximum DDG score of fragment pair" );
option.add( basic::options::OptionKeys::frags::nonlocal::max_rmsd_after_relax, "maximum rmsd of fragment pair after relax" );
option.add( basic::options::OptionKeys::frags::nonlocal::output_frags_pdbs, "output non-local fragment pair PDBs" );
option.add( basic::options::OptionKeys::frags::nonlocal::output_idealized, "output an idealized pose which can be used for generating a new VALL" );
option.add( basic::options::OptionKeys::frags::nonlocal::output_silent, "output non-local fragment pairs silent file" ).def(true);
option.add( basic::options::OptionKeys::frags::contacts::contacts, "contacts option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::frags::contacts::min_seq_sep, "minimum sequence separation between contacts" ).def(12);
option.add( basic::options::OptionKeys::frags::contacts::dist_cutoffs, "distance cutoffs to be considered a contact. contact counts will only be saved." ).def(9.0);
option.add( basic::options::OptionKeys::frags::contacts::centroid_distance_scale_factor, "Scaling factor for centroid distance cutoffs." ).def(1.0);
option.add( basic::options::OptionKeys::frags::contacts::type, "Atom considered for contacts" ).legal("ca").legal("cb").legal("cen").def(utility::vector1<std::string>(1,"ca"));
option.add( basic::options::OptionKeys::frags::contacts::neighbors, "number of adjacent residues to a contact for finding neighboring contacts" ).def(0);
option.add( basic::options::OptionKeys::frags::contacts::output_all, "output all contacts" ).def(false);
option.add( basic::options::OptionKeys::frags::ABEGO::ABEGO, "ABEGO option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::frags::ABEGO::phi_psi_range_A, "Further filter phi&psi during frag picking process in design" ).def(999.0);
option.add( basic::options::OptionKeys::holes::holes, "holes option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::holes::dalphaball, "The DAlaphaBall_surf program" );
option.add( basic::options::OptionKeys::holes::params, "File containing score parameters" ).def("holes_params.dat");
option.add( basic::options::OptionKeys::holes::h_mode, "include H's or no... see PoseBalls.cc" ).def(0);
option.add( basic::options::OptionKeys::holes::water, "include water or no" ).def(false);
option.add( basic::options::OptionKeys::holes::make_pdb, "make pdb with scores" ).def(false);
option.add( basic::options::OptionKeys::holes::make_voids, "do separate SLOW void calculation" ).def(false);
option.add( basic::options::OptionKeys::holes::atom_scores, "output scores for all atoms" ).def(false);
option.add( basic::options::OptionKeys::holes::residue_scores, "output scores for all residues (avg over atoms)" ).def(false);
option.add( basic::options::OptionKeys::holes::minimize, "RosettaHoles params to use: decoy15, decoy25 or resl" ).def("decoy15");
option.add( basic::options::OptionKeys::holes::debug, "dump debug output" ).def(false);
option.add( basic::options::OptionKeys::hotspot::hotspot, "hotspot option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::hotspot::allow_gly, "Allow glycines in hotspot hashing constraints?" ).def(false);
option.add( basic::options::OptionKeys::hotspot::allow_proline, "Allow prolines in hotspot hashing constraints?" ).def(false);
option.add( basic::options::OptionKeys::hotspot::benchmark, "Score existing interface?" ).def(false);
option.add( basic::options::OptionKeys::hotspot::residue, "mini residue name3 to use for hotspot hashing" ).def(utility::vector1<std::string>(1,"ALL"));
option.add( basic::options::OptionKeys::hotspot::hashfile, "Existing hotspot hash file." );
option.add( basic::options::OptionKeys::hotspot::target, "Target PDB of the hotspot hash. Used for both de novo hashing and making hash density maps." );
option.add( basic::options::OptionKeys::hotspot::target_res, "Rosetta residue number of interest on the target PDB. Used for targeted hashing" );
option.add( basic::options::OptionKeys::hotspot::target_dist, "Tolerated distance from the target residue. Used for targeted hashing" ).def(20);
option.add( basic::options::OptionKeys::hotspot::density, "Filename to write *unweighted* hotspot density (compared to -target PDB)." );
option.add( basic::options::OptionKeys::hotspot::weighted_density, "Filename to write *score weighted* hotspot density (compared to -target PDB)." );
option.add( basic::options::OptionKeys::hotspot::rms_target, "Filename to write best rms of hotspot to target complex. Suitable for pymol data2b_res" );
option.add( basic::options::OptionKeys::hotspot::rms_hotspot, "Filename to write best rms of hotspot to target complex. Suitable for rms vs E scatter plots." );
option.add( basic::options::OptionKeys::hotspot::rms_hotspot_res, "Rosetta residue # to use for calculating rms_hotspot." );
option.add( basic::options::OptionKeys::hotspot::rescore, "Rescore hotspots from -hashfile based on the supplied -target PDB." ).def(false);
option.add( basic::options::OptionKeys::hotspot::threshold, "Score threshold for hotspot accepts. Found hotspots must be better than or equal to threshold" ).def(-1.0);
option.add( basic::options::OptionKeys::hotspot::sc_only, "Make backbone atoms virtual to find sidechain-only hotspots?" ).def(true);
option.add( basic::options::OptionKeys::hotspot::fxnal_group, "Only use a stubs functional group for rmsd calculations." ).def(true);
option.add( basic::options::OptionKeys::hotspot::cluster, "Cluster stubset. Will take place before colonyE." ).def(false);
option.add( basic::options::OptionKeys::hotspot::colonyE, "Rescore hotspots from -hashfile based on colony energy." ).def(false);
option.add( basic::options::OptionKeys::hotspot::length, "Length of hotspot peptide to use for hashing. Sidechain-containing group will be in the center." ).def(1);
option.add( basic::options::OptionKeys::hotspot::envhb, "Use environment dependent Hbonds when scoring hotspots." ).def(false);
option.add( basic::options::OptionKeys::hotspot::angle, "Maximum allowed angle between stubCA, target CoM, and stubCB. Used to determine if stub is pointing towards target. Negative numbers deactivates this check (default)" ).def(-1);
option.add( basic::options::OptionKeys::hotspot::angle_res, "Residue to use for angle calculation from stubCA, <this option>, and stubCB. Used to determine if stub is pointing towards target. 0 uses the default, which is the targets center of mass" ).def(0);
option.add( basic::options::OptionKeys::indexed_structure_store::indexed_structure_store, "indexed_structure_store option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::indexed_structure_store::fragment_store, "Fragment store. [.h5] file" );
option.add( basic::options::OptionKeys::indexed_structure_store::fragment_threshold_distance, "sets the fragment threshold distance when being read in by the VallLookback score function" ).def(0.4);
option.add( basic::options::OptionKeys::indexed_structure_store::store_name, "name of store in hdf5" ).def("9_mer");
option.add( basic::options::OptionKeys::indexed_structure_store::exclude_homo, "turns on delete homologs from hdf5 database and gives files" );
option.add( basic::options::OptionKeys::lh::lh, "lh option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::lh::loopsizes, "Which loopsizes to use" ).def(10).def(15).def(20);
option.add( basic::options::OptionKeys::lh::num_partitions, "Number of partitions to split the database into" ).def(1);
option.add( basic::options::OptionKeys::lh::db_path, "Path to database" ).def("");
option.add( basic::options::OptionKeys::lh::exclude_homo, "Use a homolog exclusion filter" ).def(false);
option.add( basic::options::OptionKeys::lh::bss, "Use BinaryProteinSilentStruct instead of ProteinSilentStruct (needed for nonideal)" ).def(false);
option.add( basic::options::OptionKeys::lh::refstruct, "File with a target reference structure" ).def("");
option.add( basic::options::OptionKeys::lh::homo_file, "File containing homologs to exclude" ).def("");
option.add( basic::options::OptionKeys::lh::createdb_rms_cutoff, "RMS cutoff used for throwing out similar fragments." ).def(0).def(0).def(0);
option.add( basic::options::OptionKeys::lh::min_bbrms, "No description" ).def(20.0);
option.add( basic::options::OptionKeys::lh::max_bbrms, "No description" ).def(1400.0);
option.add( basic::options::OptionKeys::lh::min_rms, "No description" ).def(0.5);
option.add( basic::options::OptionKeys::lh::max_rms, "No description" ).def(4.0);
option.add( basic::options::OptionKeys::lh::filter_by_phipsi, "No description" ).def(true);
option.add( basic::options::OptionKeys::lh::max_radius, "No description" ).def(4);
option.add( basic::options::OptionKeys::lh::max_struct, "No description" ).def(10);
option.add( basic::options::OptionKeys::lh::max_struct_per_radius, "No description" ).def(10);
option.add( basic::options::OptionKeys::lh::grid_space_multiplier, "No description" ).def(1);
option.add( basic::options::OptionKeys::lh::grid_angle_multiplier, "No description" ).def(2.5);
option.add( basic::options::OptionKeys::lh::skim_size, "No description" ).def(100);
option.add( basic::options::OptionKeys::lh::rounds, "No description" ).def(100);
option.add( basic::options::OptionKeys::lh::jobname, "Prefix (Ident string) !" ).def("default");
option.add( basic::options::OptionKeys::lh::max_lib_size, "No description" ).def(2);
option.add( basic::options::OptionKeys::lh::max_emperor_lib_size, "No description" ).def(25);
option.add( basic::options::OptionKeys::lh::max_emperor_lib_round, "No description" ).def(0);
option.add( basic::options::OptionKeys::lh::library_expiry_time, "No description" ).def(2400);
option.add( basic::options::OptionKeys::lh::objective_function, "What to use as the objective function" ).def("score");
option.add( basic::options::OptionKeys::lh::expire_after_rounds, "If set to > 0 this causes the Master to expire a structure after it has gone through this many cycles" ).def(0);
option.add( basic::options::OptionKeys::lh::mpi_resume, "Prefix (Ident string) for resuming a previous job!" );
option.add( basic::options::OptionKeys::lh::mpi_feedback, "No description" ).legal("no").legal("add_n_limit").legal("add_n_replace").legal("single_replace").legal("single_replace_rounds").def("no");
option.add( basic::options::OptionKeys::lh::mpi_batch_relax_chunks, "No description" ).def(100);
option.add( basic::options::OptionKeys::lh::mpi_batch_relax_absolute_max, "No description" ).def(300);
option.add( basic::options::OptionKeys::lh::mpi_outbound_wu_buffer_size, "No description" ).def(60);
option.add( basic::options::OptionKeys::lh::mpi_loophash_split_size    , "No description" ).def(50);
option.add( basic::options::OptionKeys::lh::mpi_metropolis_temp, "No description" ).def(1000000.0);
option.add( basic::options::OptionKeys::lh::mpi_save_state_interval, "No description" ).def(1200);
option.add( basic::options::OptionKeys::lh::mpi_master_save_score_only, "No description" ).def(true);
option.add( basic::options::OptionKeys::lh::max_loophash_per_structure, "No description" ).def(1);
option.add( basic::options::OptionKeys::lh::prob_terminus_ramapert, "Prob. to run ramapert instead of fraginsert on terminus" ).def(0.0);
option.add( basic::options::OptionKeys::lh::rms_limit, "How to deal with returned relaxed structures" ).def(2.0);
option.add( basic::options::OptionKeys::lh::similarity_reference, "How to deal with returned relaxed structures" ).def(2.0);
option.add( basic::options::OptionKeys::lh::centroid_only, "false" ).def(false);
option.add( basic::options::OptionKeys::lh::write_centroid_structs, "Output raw loophashed decoys as well as relaxed ones" ).def(false);
option.add( basic::options::OptionKeys::lh::write_all_fa_structs, "Write out all structures returned from batch relax" ).def(false);
option.add( basic::options::OptionKeys::lh::sandbox, "Sand box mode" ).def(false);
option.add( basic::options::OptionKeys::lh::create_db, "Make database with this loopsize" ).def(false);
option.add( basic::options::OptionKeys::lh::sample_weight_file, "Holds the initial per residue sample weights" );
option.add( basic::options::OptionKeys::lh::radius_size, "tune the radius for hypershell" ).def(2);
option.add( basic::options::OptionKeys::lh::max_ref_lib_size, "No description" ).def(2);
option.add( basic::options::OptionKeys::lh::multi_objective_functions, "What to use as the objective function" ).def(utility::vector1<std::string>(1,"score"));
option.add( basic::options::OptionKeys::lh::additional_objective_functions, "What to add for the multi-objective function" );
option.add( basic::options::OptionKeys::lh::edensity_weight_for_sampling, "weight for elec_dens_fast in WorkUnit_Samplers" ).def(0.0);
option.add( basic::options::OptionKeys::lh::mpi_master_schfile, "schedule file" ).def("");
option.add( basic::options::OptionKeys::lh::mpi_master_cpu_weight, "weight on number of slaves" ).def(0.0);
option.add( basic::options::OptionKeys::lh::mpi_loophash_scan_type, "No description" ).def("random");
option.add( basic::options::OptionKeys::lh::mpi_read_structure_for_emperor, "No description" ).def(true);
option.add( basic::options::OptionKeys::lh::mpi_packmin_init, "No description" ).def(false);
option.add( basic::options::OptionKeys::lh::max_sample_per_structure, "No description" ).def(1);
option.add( basic::options::OptionKeys::lh::loop_string, "string to be parsed for loop region, e.g. 1-10,15-20,32-38" ).def("");
option.add( basic::options::OptionKeys::lh::seg_string, "string to be parsed for segment region, e.g. 1-10,15-20,32-38" ).def("");
option.add( basic::options::OptionKeys::lh::loopresdef, "String vector that tells connectivity, e.g. peptide:1,2,3,4,5-6 SSbond:3,2,1-9,8,7,6" ).def();
option.add( basic::options::OptionKeys::lh::pert_init_loop, "Try perturbing loops from starting structure at the beginning" ).def(false);
option.add( basic::options::OptionKeys::lh::NMdist, "normalmodemover distance cut" ).def(10.0);
option.add( basic::options::OptionKeys::lh::objective_dominate_cut, "cut for objective function domination" ).def(0.0).def(0.0).def(3.0);
option.add( basic::options::OptionKeys::lh::objective_cut_increment, "objective_dominate_cut increment for every call" ).def(0.0).def(0.0).def(0.0);
option.add( basic::options::OptionKeys::lh::similarity_method, "No description" ).def("sum");
option.add( basic::options::OptionKeys::lh::similarity_measure, "No description" ).def("Sscore");
option.add( basic::options::OptionKeys::lh::similarity_tolerance, "No description" ).def(0.5);
option.add( basic::options::OptionKeys::lh::parent_selection_kT, "No description" ).def(0.2);
option.add( basic::options::OptionKeys::lh::sim_replace_obj, "No description" ).def("goap");
option.add( basic::options::OptionKeys::lh::ulr_mulfactor, "No description" ).def(1.8);
option.add( basic::options::OptionKeys::lh::filter_up_to_maxlib, "No description" ).def(false);
option.add( basic::options::OptionKeys::lh::minimize_after_nmsearch, "No description" ).def(false);
option.add( basic::options::OptionKeys::lh::fragpdb::fragpdb, "fragpdb option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::lh::fragpdb::out_path, "Path where pdbs are saved" ).def("");
option.add( basic::options::OptionKeys::lh::fragpdb::indexoffset, "list of index offset pairs" ).def(-1);
option.add( basic::options::OptionKeys::lh::fragpdb::bin, "list of bin keys" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::lh::symfragrm::symfragrm, "symfragrm option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::lh::symfragrm::pdblist, "list of pdbs to be processed" );
option.add( basic::options::OptionKeys::loopfcst::loopfcst, "loopfcst option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::loopfcst::coord_cst_weight, "use coord constraints for template" ).def(0.0);
option.add( basic::options::OptionKeys::loopfcst::coord_cst_all_atom, "use coord constraints on all atoms and not just CA" ).def(false);
option.add( basic::options::OptionKeys::loopfcst::use_general_protocol, "use the new machinery around classes KinematicXXX" ).def(false);
option.add( basic::options::OptionKeys::loopfcst::coord_cst_weight_array, "use these weights (per seqpos) for coord cst in rigid regions" ).def("");
option.add( basic::options::OptionKeys::loopfcst::dump_coord_cst_weight_array, "dump these weights (per seqpos) for coord cst in rigid regions" ).def("");
option.add( basic::options::OptionKeys::LoopModel::LoopModel, "LoopModel option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::LoopModel::input_pdb, "input pdb file" ).def("LoopModel::input_pdb");
option.add( basic::options::OptionKeys::make_rot_lib::make_rot_lib, "make_rot_lib option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::make_rot_lib::options_file, "path to make rot lib options file" );
option.add( basic::options::OptionKeys::make_rot_lib::two_fold_symmetry_135_315, "the chi number at which to apply two fold symmetry across the 135/315 axis" );
option.add( basic::options::OptionKeys::make_rot_lib::two_fold_symmetry_0_180, "the chi number at which to apply two fold symmetry across the 0/180 axis" );
option.add( basic::options::OptionKeys::make_rot_lib::three_fold_symmetry_90_210_330, "the chi number at which to apply two fold symmetry across the 0/180 axis" );
option.add( basic::options::OptionKeys::make_rot_lib::use_terminal_residues, "Use separate ACE and NME residues as terminal capping groups, rather than patches" ).def(false);
option.add( basic::options::OptionKeys::make_rot_lib::k_medoids, "Use k-medoids instead of k-means clustering" ).def(false);
option.add( basic::options::OptionKeys::match::match, "match option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::match::lig_name, "Name of the ligand to be matched.  This should be the same as the NAME field of the ligand's parameter file (the .params file)" );
option.add( basic::options::OptionKeys::match::bump_tolerance, "The permitted level of spherical overlap betweeen any two atoms.  Used to detect collisions between the upstream atoms and the background, the upstream atoms and the downstream atoms, and the downstream atoms and the background" ).def(0.0);
option.add( basic::options::OptionKeys::match::active_site_definition_by_residue, "File describing the active site of the scaffold as a set of resid/radius pairs" );
option.add( basic::options::OptionKeys::match::active_site_definition_by_gridlig, "File containing 1s and Os describing the volume of space for the active site.  .gridlig file format from Rosetta++" );
option.add( basic::options::OptionKeys::match::required_active_site_atom_names, "File listing the downstream-residue-atom names which must reside in the defined active site.  Requires either the flag active_site_definition_by_residue or the flag active_site_definition_by_gridlig to be specified." );
option.add( basic::options::OptionKeys::match::grid_boundary, "File describing the volume in space in which the third orientation atom must lie" ).def("");
option.add( basic::options::OptionKeys::match::geometric_constraint_file, "File describing the geometry of the downstream object relative to the upstream object" );
option.add( basic::options::OptionKeys::match::scaffold_active_site_residues, "File with the residue indices on the scaffold that should be 			considered as potential launch points for the scaffold's active site.  File format described in MatcherTask.cc 			in the details section of the initialize_scaffold_active_site_residue_list_from_command_line() method." ).def("");
option.add( basic::options::OptionKeys::match::scaffold_active_site_residues_for_geomcsts, "File which lists the residue indices on the 			scaffold to consider as potential launch points for the scaffold's active site for each geometric constraint; 			each constraint may have a separate set of residue ids. File format described in MatcherTask.cc in the details 			section of the initialize_scaffold_active_site_residue_list_from_command_line() method." ).def("");
option.add( basic::options::OptionKeys::match::euclid_bin_size, "The bin width for the 3-dimensional coordinate hasher, in Angstroms" ).def(1.0);
option.add( basic::options::OptionKeys::match::euler_bin_size, "The bin width for the euler angle hasher, in degrees" ).def(10.0);
option.add( basic::options::OptionKeys::match::consolidate_matches, "Instead of outputting all matches, group matches and then write only the top -match::output_matches_per_group from each group." ).def(false);
option.add( basic::options::OptionKeys::match::output_matches_per_group, "The number of matches to output per group. Requires the -match::consolidate_matches flag is active." ).def(10);
option.add( basic::options::OptionKeys::match::orientation_atoms, "The three atoms, by name, on the downstream partner 			to use to describe its 6 dimensional coordinate; its position and orientation. 			Only usable when the downstream partner is a single residue. Exactly 3 atom names must be given. 			If these atoms are unspecified, the matcher will use the residues neighbor atom and two atoms 			bonded to the neighbor atom to define the orientation.  The euclidean coordinate of the third 			orientation atom is used as the first the dimensions of the downstream residues 6D coordinate; the 			other three dimensions are the three euler angles described by creating a coordinate frame at orientation 			atom 3, with the z axis along the vector from orientation atom 2 to orientation atom 3, and the y axis 			lying in the plane with orientation atoms 1,2&3." );
option.add( basic::options::OptionKeys::match::output_format, "The format in which the matches are output" ).legal("PDB").legal("KinWriter").legal("CloudPDB").def("CloudPDB");
option.add( basic::options::OptionKeys::match::match_grouper, "The parameters that matches are grouped according to by the MatchConsolidator or the CloudPDBWriter" ).legal("SameChiBinComboGrouper").legal("SameSequenceGrouper").legal("SameSequenceAndDSPositionGrouper").legal("SameRotamerComboGrouper").def("SameSequenceAndDSPositionGrouper");
option.add( basic::options::OptionKeys::match::grouper_downstream_rmsd, "Maximum allowed rmsd between two orientations of the downstream pose to be considered part of the same group " ).def(1.5);
option.add( basic::options::OptionKeys::match::output_matchres_only, "Whether to output the matched residues only or the whole pose for every match" ).def(false);
option.add( basic::options::OptionKeys::match::geom_csts_downstream_output, "For which of the geometric constraints the downstream residue/ligand will be output" ).def(1);
option.add( basic::options::OptionKeys::match::filter_colliding_upstream_residues, "Filter the output matches if the hits induce a collision between the upstream residues" ).def(true);
option.add( basic::options::OptionKeys::match::upstream_residue_collision_tolerance, "The amount of atom overlap allowed between upstream residues in a match.  If this is unspecified on the command line, then the value in the bump_tolerance option is used" ).def(0.0);
option.add( basic::options::OptionKeys::match::upstream_residue_collision_score_cutoff, "The score cutoff for upstream residue pairs to use in the collision filter.  Activating this cutoff uses the etable atr/rep/sol terms to evaluate residue-pair interactions instead of hard-sphere overlap detection" ).def(10.0);
option.add( basic::options::OptionKeys::match::upstream_residue_collision_Wfa_atr, "The fa_atr weight to use in the upstream-collision filter; use in tandem with upstream_residue_collision_score_cutoff" ).def(0.8);
option.add( basic::options::OptionKeys::match::upstream_residue_collision_Wfa_rep, "The fa_rep weight to use in the upstream-collision filter; use in tandem with upstream_residue_collision_score_cutoff" ).def(0.44);
option.add( basic::options::OptionKeys::match::upstream_residue_collision_Wfa_sol, "The fa_sol weight to use in the upstream-collision filter; use in tandem with upstream_residue_collision_score_cutoff" ).def(0.0);
option.add( basic::options::OptionKeys::match::filter_upstream_downstream_collisions, "Filter the output matches if the hits induce a collision between the upstream residues and the downstream pose" ).def(true);
option.add( basic::options::OptionKeys::match::updown_collision_tolerance, "The amount of atom overlap allowed between upstream and downstream atoms in a match.  If this is unspecified on the command line, then the value in the bump_tolerance option is used" ).def(0.0);
option.add( basic::options::OptionKeys::match::updown_residue_collision_score_cutoff, "The score cutoff for upstream/downstream residue pairs to use in the collision filter.  Activating this cutoff uses the etable atr/rep/sol terms to evaluate residue-pair interactions instead of hard-sphere overlap detection" ).def(10.0);
option.add( basic::options::OptionKeys::match::updown_residue_collision_Wfa_atr, "The fa_atr weight to use in the upstream-downstream-collision filter; use in tandem with updown_residue_collision_score_cutoff" ).def(0.8);
option.add( basic::options::OptionKeys::match::updown_residue_collision_Wfa_rep, "The fa_rep weight to use in the upstream-downstream-collision filter; use in tandem with updown_residue_collision_score_cutoff" ).def(0.44);
option.add( basic::options::OptionKeys::match::updown_residue_collision_Wfa_sol, "The fa_sol weight to use in the upstream-downstream-collision filter; use in tandem with updown_residue_collision_score_cutoff" ).def(0.0);
option.add( basic::options::OptionKeys::match::define_match_by_single_downstream_positioning, "Enumerate combinations of matches where a 			single positioning of the downstream partner as well as the conformations of the upstream residues defines the 			match; it is significantly faster to enumerate unique matches when they are defined this way instead of enumerating the 			(combinatorially many) matches when a match is defined by n-geometric-constraint locations of the downstream partner. 			This faster technique for outputting matches is automatically chosen when the flag -match::output_format is PDB." );
option.add( basic::options::OptionKeys::match::ligand_rotamer_index, "Match with a particular conformation of the ligand; the index 			represents which conformation in the multi-model .pdb file specified in the ligand's .params file by the 			PDB_ROTAMERS field.  The index of the first conformation in that file is 1; valid indices range from 1 to 			the number of entries in the multi-model .pdb file.  If this command-line flag is not used, then the conformation 			of the ligand described by the ICOOR_INTERNAL lines of the ligand's .params file is used instead." );
option.add( basic::options::OptionKeys::match::enumerate_ligand_rotamers, "Match with all ligand rotamers specified in the multi-model 			.pdb file specified in the ligand's .params file by the PDB_ROTAMERS field.  This flag may not be used in 			combination with the match::ligand_rotamer_index flag.  Geometry of the ligand rotamers in the .pdb file will 			be idealized to the .params file bond angles and lengths." ).def(true);
option.add( basic::options::OptionKeys::match::only_enumerate_non_match_redundant_ligand_rotamers, "Only defined if enumerate_ligand_rotamers is true 			this option causes the matcher to determine which rotamers in the ligand rotamer library are redundant in terms of matching, 			meaning the atoms they're matched through are superimposable. after having subdivided the ligand rotamer library into match-redundant 			subgroups, the matcher will then only place the first nonclashing rotamer from each subgroup. " ).def(true);
option.add( basic::options::OptionKeys::match::dynamic_grid_refinement, "When too many hits land in the same 'connected component', requiring the 			enumeration of twoo many matches, refine the grid size to be smaller so that fewer matches have to be enumerated. 			This process works on individual connected components and is not applied to all regions of 6D.  This is significantly 			more efficient than enumerating all matches, while allowing the grid size to remain large and the rotamer and external 			geometry to remain dense. (*A connected component refers to " );
option.add( basic::options::OptionKeys::match::build_round1_hits_twice, "Memory saving strategy that avoids paying for the storage of all the round-1 hits 			and instead records only what 6D voxels those hits fall in to.  Then the second round of matching proceeds storing only the hits that 			fall into the same voxels that the hits from the first round fell into.  Then the matcher goes back and generates the first-round hits 			again, but only keeps the ones that land into the same voxels that hits from round 2 fell into.  To be used, round 2 must also use the 			classic match algorithm (and must not use secondary matching)." ).def(false);
option.add( basic::options::OptionKeys::matdes::matdes, "matdes option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::matdes::num_subs_building_block, "The number of subunits in the oligomeric building block" ).def(1);
option.add( basic::options::OptionKeys::matdes::num_subs_total, "The number of subunits in the target assembly" ).def(1);
option.add( basic::options::OptionKeys::matdes::pdbID, "The PDB ID" ).def("0xxx");
option.add( basic::options::OptionKeys::matdes::prefix, "Prefix appended to output PDB files. Perhaps useful to describe the architecture, e.g., 532_3_..." ).def("pre_");
option.add( basic::options::OptionKeys::matdes::radial_disp, "Specify the radial displacement from the center of a closed point group assembly. Use with -in::olig_search::dump_pdb" );
option.add( basic::options::OptionKeys::matdes::angle, "Specify the angle by which a building block is rotated in a symmetrical assembly. Use with -in::olig_search::dump_pdb" );
option.add( basic::options::OptionKeys::matdes::tag, "Four digit ID tag attached to a design model during design" );
option.add( basic::options::OptionKeys::matdes::dock::dock, "dock option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::matdes::dock::neg_r, "Specify whether radial displacement is positive or negative. 1 for negative, 0 for positive." ).def(0);
option.add( basic::options::OptionKeys::matdes::dock::dump_pdb, "Dump a pdb of a particular docked configuration" ).def(false);
option.add( basic::options::OptionKeys::matdes::dock::dump_chainA_only, "Only output chain A (the asymmetric unit) of the symmetrical assembly. Use with -in::olig_search::dump_pdb" ).def(false);
option.add( basic::options::OptionKeys::matdes::design::design, "design option group" ).legal(true).def(true).is_group(true);

}
inline void add_rosetta_options_10( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::matdes::design::contact_dist, "CA-CA distance for defining interface residues" ).def(10.0);
option.add( basic::options::OptionKeys::matdes::design::grid_size_angle, "The width of angle space to start design/minimize runs from, centered on the starting angle" ).def(1.0);
option.add( basic::options::OptionKeys::matdes::design::grid_size_radius, "The width of radius space to start design/minimize runs from, centered on the starting radius" ).def(1.0);
option.add( basic::options::OptionKeys::matdes::design::grid_nsamp_angle, "The number of samples the rigid body grid is divided into in angle space" ).def(9);
option.add( basic::options::OptionKeys::matdes::design::grid_nsamp_radius, "The number of samples the rigid body grid is divided into in radius space" ).def(9);
option.add( basic::options::OptionKeys::matdes::design::fav_nat_bonus, "Bonus to be awarded to native residues" ).def(0.0);
option.add( basic::options::OptionKeys::matdes::mutalyze::mutalyze, "mutalyze option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::matdes::mutalyze::calc_rot_boltz, "Specify whether to calculate RotamerBoltzmann probabilities or not" ).def(0);
option.add( basic::options::OptionKeys::matdes::mutalyze::ala_scan, "Specify whether to calculate ddGs for alanine-scanning mutants at the designed interface" ).def(1);
option.add( basic::options::OptionKeys::matdes::mutalyze::revert_scan, "Specify whether to calculate ddGs for reversion mutants at the designed interface" ).def(1);
option.add( basic::options::OptionKeys::matdes::mutalyze::min_rb, "Specify whether to minimize the rigid body DOFs" ).def(1);
option.add( basic::options::OptionKeys::mc::mc, "mc option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mc::log_scores_in_MC, "Score each decoy during a simulation and output it to log; slows down run!" ).def(false);
option.add( basic::options::OptionKeys::mc::hierarchical_pool, "specify prefix in order to look for hierarchical pool" );
option.add( basic::options::OptionKeys::mc::read_structures_into_pool, "specify the silent-structs to create a hierarchy for lazy users" );
option.add( basic::options::OptionKeys::mc::convergence_check_frequency, "how often check for convergences in MC object?" ).def(100);
option.add( basic::options::OptionKeys::mc::known_structures, "specify a filename of a silent-file containing known structures" ).def("known_structs.in");
option.add( basic::options::OptionKeys::mc::max_rmsd_against_known_structures, "stop sampling if rmsd to a known-structure is lower than X" ).def(1.5);
option.add( basic::options::OptionKeys::mc::excluded_residues_from_rmsd, "residues that are not used for RMSD computation in pool" );
option.add( basic::options::OptionKeys::mc::heat_convergence_check, "jump out of current abinitio run if X unsuccesful mc-trials reached" ).def(0);
option.add( basic::options::OptionKeys::mh::mh, "mh option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mh::motif_out_file, "file to dump ResPairMotifs to" ).def("motifs");
option.add( basic::options::OptionKeys::mh::harvest_motifs, "files to harvest ResPairMotifs from" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::print_motifs, "files to print ResPairMotifs from" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::remove_duplicates, "files to remove dup ResPairMotifs from" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::dump_motif_pdbs, "files to extract ResPairMotifs clusters from" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::merge_motifs, "files to merge ResPairMotifs from" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::merge_scores, "files to merge scores from" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::merge_motifs_one_per_bin, "keep only one motif per hash bin (for sepcified grid)" ).def(false);
option.add( basic::options::OptionKeys::mh::gen_reverse_motifs_on_load, "" ).def(false);
option.add( basic::options::OptionKeys::mh::dump_input_pdb, "files to dump biount interpretation from" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::score_pdbs, "files to score with input counts file" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::sequence_recovery, "pdb files to score" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::explicit_motif_score, "pdb files to score" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::harvest_scores, "get counts from ResPairMotif files and dump to binary counts file" ).def("");
option.add( basic::options::OptionKeys::mh::print_scores, "print a binary counts file" ).def("");
option.add( basic::options::OptionKeys::mh::dump_matching_motifs, "pdb files to score" ).def("SPECIFY_ME_DUMMY");
option.add( basic::options::OptionKeys::mh::score_across_chains_only, "ignore intra-chain motifs" ).def(false);
option.add( basic::options::OptionKeys::mh::normalize_score_ncontact, "normalize by total num contacts" ).def(true);
option.add( basic::options::OptionKeys::mh::harvest_motifs_min_hh_ends, "restrict to middle of hilix contacts " ).def(0);
option.add( basic::options::OptionKeys::mh::ignore_io_errors, " " ).def(false);
option.add( basic::options::OptionKeys::mh::motif_match_radius, "width of euler angle bin" ).def(9e9);
option.add( basic::options::OptionKeys::mh::merge_similar_motifs, "give 3 hash params" );
option.add( basic::options::OptionKeys::mh::score::score, "score option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mh::score::background_weight, "weight on cb contacts, kinda" ).def(0.0);
option.add( basic::options::OptionKeys::mh::score::ca_cb_clash_weight, "weight on cb clashes, kinda" ).def(1.0);
option.add( basic::options::OptionKeys::mh::score::noloops, "ignore loop ss in scored structs" ).def(false);
option.add( basic::options::OptionKeys::mh::score::nosheets, "ignore strand ss in scored structs" ).def(false);
option.add( basic::options::OptionKeys::mh::score::nohelix, "ignore helix ss in scored structs" ).def(false);
option.add( basic::options::OptionKeys::mh::score::spread_ss_element, "" ).def(false);
option.add( basic::options::OptionKeys::mh::score::min_cover_fraction, "" ).def(0.0);
option.add( basic::options::OptionKeys::mh::score::strand_pair_weight, "" ).def(1.0);
option.add( basic::options::OptionKeys::mh::score::anti_polar_weight, "" ).def(1.0);
option.add( basic::options::OptionKeys::mh::score::min_contact_pairs, "" ).def(1.0);
option.add( basic::options::OptionKeys::mh::score::max_contact_pairs, "" ).def(9e9);
option.add( basic::options::OptionKeys::mh::score::max_cb_dis, "" ).def(9.0);
option.add( basic::options::OptionKeys::mh::score::coverage_pow, "" ).def(0.0);
option.add( basic::options::OptionKeys::mh::score::use_ss1, "" ).def(true);
option.add( basic::options::OptionKeys::mh::score::use_ss2, "" ).def(true);
option.add( basic::options::OptionKeys::mh::score::use_aa1, "" ).def(false);
option.add( basic::options::OptionKeys::mh::score::use_aa2, "" ).def(false);
option.add( basic::options::OptionKeys::mh::score::use_log, "" ).def(true);
option.add( basic::options::OptionKeys::mh::path::path, "path option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mh::path::biounit, "path to search for biounits in the ab/1abc.pdb1.gz format" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::mh::path::biounit_ideal, "idealized biounit coords, missing PDBInfo metadatab" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::mh::path::pdb, "path to search for pdbs in the ab/1abc.pdb.gz format" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::mh::path::motifs, "concrete motifs in .rpm.bin.gz format" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::mh::path::motifs_SC_SC, "concrete SC_SC motifs, try to replace with path::motifs" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::mh::path::motifs_SC_BB, "concrete SC_BB motifs, try to replace with path::motifs" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::mh::path::motifs_BB_BB, "concrete BB_BB motifs, try to replace with path::motifs" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::mh::path::motifs_BB_PH, "concrete BB_PH motifs, try to replace with path::motifs" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::mh::path::motifs_BB_PO, "concrete BB_PO motifs, try to replace with path::motifs" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::mh::path::motifs_PH_PO, "concrete PH_PO motifs, try to replace with path::motifs" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::mh::path::scores, "motif hash data for scoring, mixed, may not use" );
option.add( basic::options::OptionKeys::mh::path::scores_SC_SC, "motif hash data for scoring SC_SC" );
option.add( basic::options::OptionKeys::mh::path::scores_SC_BB, "motif hash data for scoring SC_BB" );
option.add( basic::options::OptionKeys::mh::path::scores_BB_BB, "motif hash data for scoring" );
option.add( basic::options::OptionKeys::mh::path::scores_BB_PH, "motif hash data for scoring BB_PH" );
option.add( basic::options::OptionKeys::mh::path::scores_BB_PO, "motif hash data for scoring BB_PO" );
option.add( basic::options::OptionKeys::mh::path::scores_PH_PO, "motif hash data for scoring strand pairings" );
option.add( basic::options::OptionKeys::mh::path::scores_frags, "motif hash data for scoring strand pairings" );
option.add( basic::options::OptionKeys::mh::harvest::harvest, "harvest option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mh::harvest::hash_cart_resl, "width of cartesian bin" ).def(0.8);
option.add( basic::options::OptionKeys::mh::harvest::hash_angle_resl, "width of euler angle bin" ).def(15.0);
option.add( basic::options::OptionKeys::mh::harvest::smoothing_factor, "smoothing radius exp(-d/resl**2 * factor)" ).def(1.0);
option.add( basic::options::OptionKeys::mh::harvest::idealize, "" ).def(false);
option.add( basic::options::OptionKeys::mh::harvest::dump, "" ).def(false);
option.add( basic::options::OptionKeys::mh::harvest::min_bin_val, "" ).def(0.0);
option.add( basic::options::OptionKeys::mh::harvest::sep_aa, "" ).def(false);
option.add( basic::options::OptionKeys::mh::harvest::sep_aa1, "" ).def(false);
option.add( basic::options::OptionKeys::mh::harvest::sep_aa2, "" ).def(false);
option.add( basic::options::OptionKeys::mh::harvest::sep_ss, "" ).def(false);
option.add( basic::options::OptionKeys::mh::harvest::sep_dssp, "" ).def(false);
option.add( basic::options::OptionKeys::mh::harvest::sep_lj, "" ).def(utility::vector1<double>());
option.add( basic::options::OptionKeys::mh::harvest::sep_hb, "" ).def(utility::vector1<double>());
option.add( basic::options::OptionKeys::mh::harvest::sep_nbrs, "" ).def(utility::vector1<double>());
option.add( basic::options::OptionKeys::mh::harvest::sep_bfac, "" ).def(utility::vector1<double>());
option.add( basic::options::OptionKeys::mh::harvest::sep_dist, "" ).def(utility::vector1<double>());
option.add( basic::options::OptionKeys::mh::harvest::weight_by_energy, "" ).def(true);
option.add( basic::options::OptionKeys::mh::harvest::max_rmsd, "skip structure if refined rms to input is higher than this" ).def(0.5);
option.add( basic::options::OptionKeys::mh::harvest::max_res, "max res in biounit (or whatever) for harvest" ).def(1000);
option.add( basic::options::OptionKeys::mh::harvest::agg_with_max, "" ).def(false);
option.add( basic::options::OptionKeys::mh::harvest::multiplier, "" ).def(1.0);
option.add( basic::options::OptionKeys::mh::match::match, "match option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mh::match::interface_only, "" ).def(true);
option.add( basic::options::OptionKeys::mh::match::ss, "" ).def(true);
option.add( basic::options::OptionKeys::mh::match::ss1, "" ).def(true);
option.add( basic::options::OptionKeys::mh::match::ss2, "" ).def(true);
option.add( basic::options::OptionKeys::mh::match::aa, "" ).def(false);
option.add( basic::options::OptionKeys::mh::match::aa1, "" ).def(false);
option.add( basic::options::OptionKeys::mh::match::aa2, "" ).def(false);
option.add( basic::options::OptionKeys::mh::dump::dump, "dump option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mh::dump::limit_per_pair, "" ).def(999999);
option.add( basic::options::OptionKeys::mh::dump::max_per_res, "" ).def(30);
option.add( basic::options::OptionKeys::mh::dump::max_ca_dis, "" ).def(12.0);
option.add( basic::options::OptionKeys::mh::dump::max_rms, "" ).def(0.5);
option.add( basic::options::OptionKeys::mh::dump::resfile_min_pair_score, "" ).def(0.00);
option.add( basic::options::OptionKeys::mh::dump::resfile_min_tot_score, "" ).def(0.00);
option.add( basic::options::OptionKeys::mh::dump::resfile_dump, "" ).def(false);
option.add( basic::options::OptionKeys::mh::dump::symmetric_motifs, "" ).def(false);
option.add( basic::options::OptionKeys::mh::filter::filter, "filter option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::mh::filter::filter_harvest, "filter while harvesting" ).def(false);
option.add( basic::options::OptionKeys::mh::filter::filter_io, "filter while reading filter" ).def(true);
option.add( basic::options::OptionKeys::mh::filter::pdb, "4/5 letter pdb code" );
option.add( basic::options::OptionKeys::mh::filter::lig, "3 letter lig code" );
option.add( basic::options::OptionKeys::mh::filter::motif_type, "bb pb sc pp" );
option.add( basic::options::OptionKeys::mh::filter::restype1, "allowed res types for res1" ).def("ACDEFGHIKLMNPQRSTVWY");
option.add( basic::options::OptionKeys::mh::filter::restype2, "allowed res types for res2" ).def("ACDEFGHIKLMNPQRSTVWY");
option.add( basic::options::OptionKeys::mh::filter::restype, "allowed res types" ).def("ACDEFGHIKLMNPQRSTVWY");
option.add( basic::options::OptionKeys::mh::filter::restype_one, "allowed res types need at least one" ).def("ACDEFGHIKLMNPQRSTVWY");
option.add( basic::options::OptionKeys::mh::filter::not_restype, "disallowed res types" ).def("ACGP");
option.add( basic::options::OptionKeys::mh::filter::not_restype_one, "disallowed res types at least one not" ).def("ACGP");
option.add( basic::options::OptionKeys::mh::filter::seqsep, "min filter seqsep" ).def(0);
option.add( basic::options::OptionKeys::mh::filter::max_seqsep, "min filter seqsep" ).def(99999);
option.add( basic::options::OptionKeys::mh::filter::no_hb_bb, "no bb hbonded" ).def(false);
option.add( basic::options::OptionKeys::mh::filter::mindist2, "min CA-CA dist sq" ).def(0.0);
option.add( basic::options::OptionKeys::mh::filter::maxdist2, "max CA-CA dist sq" ).def(999999.0);
option.add( basic::options::OptionKeys::mh::filter::ss1, "filter ss1" ).def("");
option.add( basic::options::OptionKeys::mh::filter::ss2, "filter ss2" ).def("");
option.add( basic::options::OptionKeys::mh::filter::dssp1, "filter dssp1" ).def("");
option.add( basic::options::OptionKeys::mh::filter::dssp2, "filter dssp2" ).def("");
option.add( basic::options::OptionKeys::mh::filter::aa1, "filter aa1" ).def("");
option.add( basic::options::OptionKeys::mh::filter::aa2, "filter aa2" ).def("");
option.add( basic::options::OptionKeys::mh::filter::sasa, "filter max sasa" ).def(999.0);
option.add( basic::options::OptionKeys::mh::filter::faatr, "filter max faatr (default 999.0 = no filtering" ).def(999.0);
option.add( basic::options::OptionKeys::mh::filter::hb_sc, "filter max hb_sc (default 999.0 = no filtering" ).def(999.0);
option.add( basic::options::OptionKeys::mh::filter::hb_bb_sc, "filter max hb_bb_sc (default 999.0 = no filtering" ).def(999.0);
option.add( basic::options::OptionKeys::mh::filter::hb_bb, "filter max hb_bb (default 999.0 = no filtering" ).def(999.0);
option.add( basic::options::OptionKeys::mh::filter::occupancy, "filter min occupancy (default 0.0 = no filtering" ).def(0.0);
option.add( basic::options::OptionKeys::mh::filter::coorderr, "filter max bfac coorderr = sqrt(B/8*pi**2)) (default 999.0 = no filtering" ).def(999.0);
option.add( basic::options::OptionKeys::mh::filter::uniformfrag, "is frag and all same ss in frag" ).def(false);
option.add( basic::options::OptionKeys::mh::filter::faatr_or_hbbb, "filter require atr or hb (bb allowed) below thresh" ).def(999.0);
option.add( basic::options::OptionKeys::mh::filter::faatr_or_hb, "filter require atr or hb below thresh" ).def(999.0);
option.add( basic::options::OptionKeys::mh::filter::noloops, "" ).def(false);
option.add( basic::options::OptionKeys::mh::filter::oneloop, "" ).def(false);
option.add( basic::options::OptionKeys::mh::filter::nodisulf, "" ).def(false);
option.add( basic::options::OptionKeys::mh::filter::score, "filter on ResPairMotir::score()" ).def(999.0);
option.add( basic::options::OptionKeys::magnesium::magnesium, "magnesium option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::magnesium::scan, "default mode: scan Mg(2+) through PDB" ).def(true);
option.add( basic::options::OptionKeys::magnesium::mg_res, "supply PDB residue numbers of Mg(2+) to look at [leave blank to scan a new Mg(2+)]" ).def();
option.add( basic::options::OptionKeys::magnesium::minimize_during_scoring, "minimize mg(2+) during scoring/hydration of each position" ).def(true);
option.add( basic::options::OptionKeys::magnesium::ligand_res, "in scan, look at positions near these residues (PDB numbering/chains)" ).def();
option.add( basic::options::OptionKeys::magnesium::pose_ligand_res, "in scan, look at positions near these residues, pose numbering (1,2,..)" ).def();
option.add( basic::options::OptionKeys::magnesium::lores_scan, "do not try hydration or minimization during scan" ).def(false);
option.add( basic::options::OptionKeys::magnesium::xyz_step, "increment in Angstroms for xyz scan" ).def(0.50);
option.add( basic::options::OptionKeys::magnesium::score_cut, "score cut for silent output (5.0 for hires; -8.0 for lores)" ).def(5.0);
option.add( basic::options::OptionKeys::magnesium::score_cut_PDB, "score cut for PDB output from scanning (deprecated)" ).def(0.0);
option.add( basic::options::OptionKeys::magnesium::integration_test, "Stop after first mg position found -- for testing" ).def(false);
option.add( basic::options::OptionKeys::magnesium::tether_to_closest_res, "stay near closest ligand res; helps force unique grid sampling in different cluster jobs." ).def(false);
option.add( basic::options::OptionKeys::magnesium::fixup, "test mode: align the 6 octahedral virtual 'orbitals' for specified mg_res" ).def(false);
option.add( basic::options::OptionKeys::magnesium::pack_water_hydrogens, "test mode: strip out non-mg waters, align mg frames, pack mg waters for specified mg_res" ).def(false);
option.add( basic::options::OptionKeys::magnesium::hydrate, "test mode: strip out waters and hydrate mg(2+) for specified mg_res" ).def(false);
option.add( basic::options::OptionKeys::magnesium::monte_carlo, "test mode: monte carlo sampling of Mg(2+) and surrounding waters" ).def(false);
option.add( basic::options::OptionKeys::magnesium::scored_hydrogen_sampling, "in -pack_water_hydrogens test mode, when packing water hydrogens, use a complete scorefunction to rank (slow)" ).def(false);
option.add( basic::options::OptionKeys::magnesium::all_hydration_frames, "in -hydration test mode, Sample all hydration frames (slow)" ).def(false);
option.add( basic::options::OptionKeys::magnesium::leave_other_waters, "in -hydration test mode, do not remove all waters" ).def(false);
option.add( basic::options::OptionKeys::magnesium::minimize, "minimize Mg(2+) after hydration or hydrogen-packing" ).def(false);
option.add( basic::options::OptionKeys::magnesium::minimize_mg_coord_constraint_distance, "harmonic tether to Mg(2+) during minimize" ).def(0.2);
option.add( basic::options::OptionKeys::magnesium::montecarlo::montecarlo, "montecarlo option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::magnesium::montecarlo::temperature, "temperature for Monte Carlo" ).def(1.0);
option.add( basic::options::OptionKeys::magnesium::montecarlo::cycles, "Monte Carlo cycles" ).def(100000);
option.add( basic::options::OptionKeys::magnesium::montecarlo::dump, "dump PDBs from Mg monte carlo" ).def(false);
option.add( basic::options::OptionKeys::magnesium::montecarlo::add_delete_frequency, "add_delete_frequency for Monte Carlo" ).def(0.1);
option.add( basic::options::OptionKeys::motifs::motifs, "motifs option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::motifs::close_enough, "4-atom rmsd cutoff beyond which you don't bother trying an inverse rotamer" ).def(1.0);
option.add( basic::options::OptionKeys::motifs::max_depth, "Maximum recursion depth - i.e., maximum number of motifs to incorporate" ).def(1);
option.add( basic::options::OptionKeys::motifs::keep_motif_xtal_location, "used to dna_motif_collector - controls whether motifs are moved away from original PDB location (comparison is easier if they are moved, so that's default)" ).def(false);
option.add( basic::options::OptionKeys::motifs::pack_score_cutoff, "used in dna_motif_collector - fa_atr + fa_rep energy threshold for a two-residue interaction to determine if it is a motif" ).def(-0.5);
option.add( basic::options::OptionKeys::motifs::hb_score_cutoff, "used in dna_motif_collector - hbond_sc energy threshold for a two-residue interaction to determine if it is a motif" ).def(-0.3);
option.add( basic::options::OptionKeys::motifs::water_score_cutoff, "used in dna_motif_collector - h2o_hbond energy threshold for a two-residue interaction to determine if it is a motif" ).def(-0.3);
option.add( basic::options::OptionKeys::motifs::pack_min_threshold, "Used for motif extraction - packing scores below this value will cause a motif to be discarded" ).def(-9999.0);
option.add( basic::options::OptionKeys::motifs::pack_max_threshold, "Used for motif extraction - packing scores above this value will cause a motif to be discarded" ).def(9999.0);
option.add( basic::options::OptionKeys::motifs::hbond_min_threshold, "Used for motif extraction - hbond scores below this value will cause a motif to be discarded" ).def(-9999.0);
option.add( basic::options::OptionKeys::motifs::hbond_max_threshold, "Used for motif extraction - hbond scores above this value will cause a motif to be discarded" ).def(9999.0);
option.add( basic::options::OptionKeys::motifs::elec_min_threshold, "Used for motif extraction - fa_elec scores below this value will cause a motif to be discarded" ).def(-9999.0);
option.add( basic::options::OptionKeys::motifs::elec_max_threshold, "Used for motif extraction - fa_elec scores above this value will cause a motif to be discarded" ).def(9999.0);
option.add( basic::options::OptionKeys::motifs::duplicate_dist_cutoff, "Value for determining whether a motif is different from others already in a library" ).def(1.0);
option.add( basic::options::OptionKeys::motifs::duplicate_angle_cutoff, "Value for determining whether a motif is different from others already in a library" ).def(0.4);
option.add( basic::options::OptionKeys::motifs::motif_output_directory, "used in dna_motif_collector - path for the directory where all the collected motifs are dumped as 2-residue pdbs" );
option.add( basic::options::OptionKeys::motifs::eliminate_weak_motifs, "used to dna_motif_collector - controls whether only the top 1-2 motifs are counted for every protein position in a protein-DNA interface" ).def(true);
option.add( basic::options::OptionKeys::motifs::duplicate_motif_cutoff, "used in dna_motif_collector - RMSD cutoff for an identical base placed via a motif to see if that motif already exists in a motif library" ).def(0.2);
option.add( basic::options::OptionKeys::motifs::preminimize_motif_pdbs, "used to dna_motif_collector - controls whether the input PDB structure sidechains and bb are minimized before motifs are collected" ).def(false);
option.add( basic::options::OptionKeys::motifs::preminimize_motif_pdbs_sconly, "used to dna_motif_collector - controls whether the input PDB structure sidechains are minimized before motifs are collected" ).def(false);
option.add( basic::options::OptionKeys::motifs::place_adduct_waters, "used to dna_motif_collector - whether or not adduct waters are placed before motifs are collected, there will be no water interaction calculated if this is false" ).def(true);
option.add( basic::options::OptionKeys::motifs::list_motifs, "File(s) containing list(s) of PDB files to process" );
option.add( basic::options::OptionKeys::motifs::motif_filename, "File containing motifs" );
option.add( basic::options::OptionKeys::motifs::file_prefix, "File containing motifs" ).def("motif");
option.add( basic::options::OptionKeys::motifs::build_residue_file, "File containing the target positions for building and incorporating motifs" );
option.add( basic::options::OptionKeys::motifs::motif_flexible_loop_file, "File containing the flexible loop definition" );
option.add( basic::options::OptionKeys::motifs::residue_trim_file, "File a list of residues to trim to Ala before motif incorporation." );
option.add( basic::options::OptionKeys::motifs::BPData, "File containing BuildPosition specific motifs and/or rotamers" );
option.add( basic::options::OptionKeys::motifs::list_dnaconformers, "File(s) containing list(s) of PDB files to process" );
option.add( basic::options::OptionKeys::motifs::target_dna_defs, "" ).def("");
option.add( basic::options::OptionKeys::motifs::motif_build_defs, "" ).def("");
option.add( basic::options::OptionKeys::motifs::motif_build_positions, "" );
option.add( basic::options::OptionKeys::motifs::r1, "RMSD cutoff between motif anchor position and motif target position for allowing a particular motif rotamer to continue on to expand with DNA conformers" ).lower(0).def(4.5);
option.add( basic::options::OptionKeys::motifs::r2, "RMSD cutoff between motif anchor position and motif target position for accepting the motif" ).lower(0).def(1.1);
option.add( basic::options::OptionKeys::motifs::z1, "DNA motif specific: cutoff between motif target DNA position and standardized base for allowing a particular motif to continue on to expand with DNA conformers" ).lower(0).def(0.75);
option.add( basic::options::OptionKeys::motifs::z2, "DNA motif specific: cutoff between motif target DNA position and DNA conformer placed according to motif for accepting the pair of residues" ).lower(0).def(0.95);
option.add( basic::options::OptionKeys::motifs::dtest, "DNA motif specific: cutoff between motif target DNA position and DNA conformer placed according to motif for accepting the pair of residues" ).lower(0).def(5.5);
option.add( basic::options::OptionKeys::motifs::rotlevel, "level of rotamer sampling for motif search" ).lower(1).def(5);
option.add( basic::options::OptionKeys::motifs::num_repacks, "number of cycles of dropping special_rot weight and design" ).lower(0).def(5);
option.add( basic::options::OptionKeys::motifs::minimize, "whether or not to minimize the motifs toward the xtal structure DNA" ).def(true);
option.add( basic::options::OptionKeys::motifs::minimize_dna, "whether or not to minimize DNA after every round of design with special_rot weight dropping" ).def(true);
option.add( basic::options::OptionKeys::motifs::run_motifs, "whether or not to use motifs in DnaPackerMotif" ).def(true);
option.add( basic::options::OptionKeys::motifs::expand_motifs, "whether or not to use expand (use all types) motifs in DnaPackerMotif" ).def(true);
option.add( basic::options::OptionKeys::motifs::aromatic_motifs, "whether or not to use expand (use aromatic only types) motifs in DnaPackerMotif" ).def(true);
option.add( basic::options::OptionKeys::motifs::dump_motifs, "whether or not to output pdbs with the best rotamer/conformer for each motifs" ).def(true);
option.add( basic::options::OptionKeys::motifs::quick_and_dirty, "quick motif run to get a list of all possible motifs before doing a real run" ).def(true);
option.add( basic::options::OptionKeys::motifs::special_rotweight, "starting weight for the weight on motif rotamers" ).def(-40.0);
option.add( basic::options::OptionKeys::motifs::output_file, "name of output file for all the best motifs and rotamers or for the dna_motif_collector it is the file where all the motifs are dumped" );
option.add( basic::options::OptionKeys::motifs::data_file, "name of output file for any data about how many rotamers and motifs pass what tests, etc" );
option.add( basic::options::OptionKeys::motifs::target_aa, "three letter code for the target amino acid for finding motifs" ).def("LEU");
option.add( basic::options::OptionKeys::motifs::flex_sugar, "whether or not to add the flexible sugar, not using PB way of adding options" ).def(true);
option.add( basic::options::OptionKeys::motifs::clear_bprots, "whether or not to clear the rotamers that were read in from a previous run and restart with only the motifs that were read in and the specified rotlevel" ).def(true);
option.add( basic::options::OptionKeys::motifs::rots2add, "number of rotamers to add to design from the MotifSearch for each amino acid type" ).lower(1).def(100);
option.add( basic::options::OptionKeys::motifs::restrict_to_wt, "restrict the motif search to finding motifs of the same amino acid as the starting pose, for homology modeling" ).def(true);
option.add( basic::options::OptionKeys::motifs::rerun_motifsearch, "setting the MotifSearch to run again, using the rotamers in the build position, most likely to change stringency or amino acid type on a second run" ).def(true);
option.add( basic::options::OptionKeys::motifs::no_rotamer_bump, "skip the bump check when making the rotamers that will be tested for motif interactions, makes code much slower, but it is advised to increase the max_rotbump_energy to at least 10.0 instead of the default of 5.0 if bump_check is being used" ).def(false);
option.add( basic::options::OptionKeys::motifs::ligand_motif_sphere, "option to specify radius of motif search around ligand" ).def(6.0);
option.add( basic::options::OptionKeys::ms::ms, "ms option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::ms::pop_from_ss, "generate starting sequence population based on single-state design results" ).def(0);
option.add( basic::options::OptionKeys::ms::pop_size, "genetic algorithm population size" ).def(100);
option.add( basic::options::OptionKeys::ms::generations, "number of genetic algorithm generations" ).def(20);
option.add( basic::options::OptionKeys::ms::num_packs, "number of repack trials per sequence/state combination" ).def(1);
option.add( basic::options::OptionKeys::ms::numresults, "number of top-fitness results to save for explicit reference at the end of multistate design" ).def(1);

}
inline void add_rosetta_options_11( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::ms::anchor_offset, "energy offset from the energy of single-state design toward the target state -- used to generate an affinity anchor for fitness calculations" ).def(5.0);
option.add( basic::options::OptionKeys::ms::Boltz_temp, "thermodynamic temperature to use for specificity calculations" ).def(0.6);
option.add( basic::options::OptionKeys::ms::mutate_rate, "rate of mutation per position" ).def(0.5);
option.add( basic::options::OptionKeys::ms::fraction_by_recombination, "fraction of the population that should be generated by recombination during the evolution stage" ).def(0.5);
option.add( basic::options::OptionKeys::ms::checkpoint::checkpoint, "checkpoint option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::ms::checkpoint::prefix, "prefix to add to the beginning of checkpoint file names" ).def("");
option.add( basic::options::OptionKeys::ms::checkpoint::interval, "frequency with which the entity checkpoint is written" ).def(0);
option.add( basic::options::OptionKeys::ms::checkpoint::gz, "compress checkpoing files with gzip" ).def(false);
option.add( basic::options::OptionKeys::ms::checkpoint::rename, "rename checkpoint files after genetic algorithm completes" ).def(false);
option.add( basic::options::OptionKeys::nonlocal::nonlocal, "nonlocal option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::nonlocal::chunks, "Decsribes how the structure is partitioned into chunks. Each residue must be present in 1 and only 1 chunk. Loop file format." );
option.add( basic::options::OptionKeys::nonlocal::randomize_missing, "Randomize the coordinates of missing loops. This occurs often in broken-chain folding from a sequence alignment and template pdb. Default value is false to preserve existing behavior in ThreadingJobInputter" ).def(false);
option.add( basic::options::OptionKeys::optE::optE, "optE option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::optE::load_from_silent, "load from silent instead of pdb - uses path of requested pdb to find silent file, each PDB needs to have all of its structures in its own folder (ie: 1agy/pdb_set.silent) - only works in optimize_decoy_discrimination" ).def("pdb_set.silent");
option.add( basic::options::OptionKeys::optE::data_in, "file from which to read in optE data" ).def("optE.data");
option.add( basic::options::OptionKeys::optE::data_out, "file to which to write optE data" ).def("optE.data.out");
option.add( basic::options::OptionKeys::optE::weights, "a conventional weightfile that optE will use to determine which weights will be counted.  All non-zero weights in the file will contribute to rotamer energies and be fit; use the -optE::fix option to fix any of these weights.  Weight values will also be used as starting values for optimization." );
option.add( basic::options::OptionKeys::optE::fix, "weights to be fixed (must also appear in the weightfile given by the -optE::weights option)" );
option.add( basic::options::OptionKeys::optE::free, "IterativeOptEDriver flag: specify a file to read score types that are free -- optionally include a starting weight for each score type" );
option.add( basic::options::OptionKeys::optE::fixed, "IterativeOptEDriver flag: specify a file to read score types and weights for score types that are on but fixed" );
option.add( basic::options::OptionKeys::optE::parse_tagfile, "a file in utility::tag format that optE may parse to customize its operation" );
option.add( basic::options::OptionKeys::optE::constant_logic_taskops_file, "a file in utility::tag format that optE uses to build a task that will not change with the context of the pose after design" );
option.add( basic::options::OptionKeys::optE::optE_soft_rep, "Instruct the IterativeOptEDriver to use the soft-repulsion etable" );
option.add( basic::options::OptionKeys::optE::no_hb_env_dependence, "Disable environmental dependent weighting of hydrogen bond terms" );
option.add( basic::options::OptionKeys::optE::no_hb_env_dependence_DNA, "Disable environmental dependent weighting of hydrogen bonds involving DNA" );
option.add( basic::options::OptionKeys::optE::optE_no_protein_fa_elec, "Instruct the IterativeOptEDriver to use the soft-repulsion etable" ).def(false);
option.add( basic::options::OptionKeys::optE::centroid_rot, "Use CENTROID_ROT vdw radii" ).def(false);
option.add( basic::options::OptionKeys::optE::centroid_rot_min, "Use CENTROID_ROT_MIN vdw radii" ).def(false);
option.add( basic::options::OptionKeys::optE::design_first, "Do not optimize the weights in the context of the native structure, but rather, start by designing the protein with the input weight set.  Requires that all score types listed in -optE::free have specificed weights." );
option.add( basic::options::OptionKeys::optE::n_design_cycles, "The number of outer-loop design cycles to complete; default of 10 after which convergence has usually occurred" ).def(10);
option.add( basic::options::OptionKeys::optE::recover_nat_rot, "With the iterative optE driver, repack to recover the native rotamers" );
option.add( basic::options::OptionKeys::optE::component_weights, "With the iterative optE driver, weight the individual components according to the input file -- default weight of 1 for all components.  Weight file consists of component-name/weight pairs on separate lines: e.g. prob_native_structure 100.0" );
option.add( basic::options::OptionKeys::optE::optimize_nat_aa, "With the iterative optE driver, optimize weights to maximize the probability of the native rotamer" );
option.add( basic::options::OptionKeys::optE::optimize_nat_rot, "With the iterative optE driver, optimize weights to maximize the probability of the native rotamer in the native context" );
option.add( basic::options::OptionKeys::optE::optimize_ligand_rot, "With the iterative optE driver, optimize weights to maximize the probability of the native rotamer around the ligand" );
option.add( basic::options::OptionKeys::optE::optimize_pssm, "With the iterative optE driver, optimize weights to maximize the match between a BLAST generated pssm probabillity distribution" );
option.add( basic::options::OptionKeys::optE::optimize_dGbinding, "With the iterative optE driver, optimize weights to minimize squared error between the predicted dG of binding and the experimental dG; provide a file listing 1. bound PDB structure, 2. unbound PDB structure, and 3. measured dG" );
option.add( basic::options::OptionKeys::optE::optimize_ddG_bind_correlation, "With the iterative optE driver, optimize weights to minimize squared error between the predicted ddG of binding for a mutation to the experimental ddG; provide a file listing 1. list file containing wt complexes, 2. list file containing mut complexes, 3. list file containing wt unbounds structures, 4. list file containing mut unbounds structures, and 5. measured ddG of binding" );
option.add( basic::options::OptionKeys::optE::optimize_ddGmutation, "With the iterative optE driver, optimize weights to minimize the predicted ddG of mutation and the measured ddG; provide a file listing 1. repacked wt pdb list, 2. repacked mut pdb list, and 3. measured ddG triples" );
option.add( basic::options::OptionKeys::optE::optimize_ddGmutation_straight_mean, "With the iterative optE driver, predict the the ddGmut to be the difference between the straight mean (1/n Sum(E_i)) of the WT and MUT structures provided.  Requires the -optimize_ddGmutation flag be set." );
option.add( basic::options::OptionKeys::optE::optimize_ddGmutation_boltzman_average, "With the iterative optE driver, predict the the ddGmut to be the difference between the boltzman average energies ( Sum( E_i * e**-E_i/kT)/Sum( e**-E_i/kT) ) of the WT and MUT structures provided.  Requires the -optimize_ddGmutation flag be set." );
option.add( basic::options::OptionKeys::optE::exclude_badrep_ddGs, "With the iterative optE driver, consider only ddG data where the unweighted repulsive energy delta mut-wt < given value" );
option.add( basic::options::OptionKeys::optE::pretend_no_ddG_repulsion, "With the iterative optE driver, set all repulsive scores to zero when looking for ddG correlations" );
option.add( basic::options::OptionKeys::optE::optimize_decoy_discrimination, "With the iterative optE driver, optimize weights to maximize the partition between relaxed natives and low-scoring decoys.  File is a list of file-list pairs and a single pdb file < native_pdb_list, decoy_pdb_list, crystal_native_pdb >." );
option.add( basic::options::OptionKeys::optE::normalize_decoy_score_spread, "In decoy discrimination optimization, normalize both the native and decoy energies generated by a set of weights by sigma_curr /sigma_start where sigma_start is computed as the standard deviation of the decoy energies given an input weight set" );
option.add( basic::options::OptionKeys::optE::ramp_nativeness, "In decoy discrimination optimization, give structures in the range between max_rms_from_native and min_decoy_rms_to_native a nativeness score (which ramps linearly from 1 to 0 in that range) and include scores from structures in the numerator of the partition." );
option.add( basic::options::OptionKeys::optE::n_top_natives_to_optimize, "For use with the -optimize_decoy_discrimination flag.  Objective function considers top N natives in partition function" ).def(1);
option.add( basic::options::OptionKeys::optE::approximate_decoy_entropy, "Alpha expansion of conformation space size as a function of nres: size ~ alpha ^ nres; entropy ~ nres ln alpha." );
option.add( basic::options::OptionKeys::optE::repack_and_minimize_decoys, "Generate new structures in each round of iterative optE by repacking and minimizing the input decoys & natives using the weights obtained in the last round" );
option.add( basic::options::OptionKeys::optE::repack_and_minimize_input_structures, "Minimizing the input decoys & natives using the starting weights -- allows structures a chance to see the energy function before decoy discrimination begins without the memory overhead of the repack_and_minimize_decoys flag" );
option.add( basic::options::OptionKeys::optE::output_top_n_new_decoys, "For use with repack_and_minimize_decoys flag: Write out the top N decoys generated each round in this iterative refinement" ).def(0);
option.add( basic::options::OptionKeys::optE::optimize_ligand_discrimination, "With the iterative optE driver, optimize weights to maximize the partition between relaxed natives and low-scoring decoys.  File is a list of file-list pairs and a single pdb file < native_pdb_list, decoy_pdb_list, crystal_native_pdb >." );
option.add( basic::options::OptionKeys::optE::no_design, "Don't bother loading pdbs and doing design; just optimize weights for decoy-discrim and or native rotamer recovery" );
option.add( basic::options::OptionKeys::optE::sqrt_pssm, "Turn the pssm probability vectors into unit vectors so that dot product is a true similarity measure" );
option.add( basic::options::OptionKeys::optE::min_decoy_rms_to_native, "For use with the optimize_decoy_discrimination flag: exclude decoys that are within a certain RMS of the native structure" );
option.add( basic::options::OptionKeys::optE::max_rms_from_native, "For use with the optimize_decoy_discrimination flag: exclude natives that are more than a certain RMS of the crystal structure.  max_rms_from_native of 1.5, min_decoy_rms_from_native 2.0 would throw out structures in the range of 1.5 and 2.0 RMS from consideration" );
option.add( basic::options::OptionKeys::optE::optimize_starting_free_weights, "With the iterative optE driver, try many different starting points for the minimization" ).def(false);
option.add( basic::options::OptionKeys::optE::wrap_dof_optimization, "Create new dofs and setup arithmetic dependencies for free dofs." );
option.add( basic::options::OptionKeys::optE::randomly_perturb_starting_free_weights, "With the iterative optE driver, perturb the weights by +/- <input value> for those weights listed as free" );
option.add( basic::options::OptionKeys::optE::inv_kT_natrot, "1 / kT for the pNativeRotamer fitness function" ).def(1);
option.add( basic::options::OptionKeys::optE::inv_kT_nataa, "1 / kT for the pNatAA and PSSM fitness function" ).def(1);
option.add( basic::options::OptionKeys::optE::inv_kT_natstruct, "1 / kT for the pNativeStructure fitness function" ).def(1);
option.add( basic::options::OptionKeys::optE::mpi_weight_minimization, "Distribute OptEMultifunc func/dfunc evaluations across nodes" );
option.add( basic::options::OptionKeys::optE::dont_use_reference_energies, "Do not use reference energies anywhere during the protocol." ).def(false);
option.add( basic::options::OptionKeys::optE::number_of_swarm_particles, "The number of particles to use during particle swarm weight optimization." ).def(100);
option.add( basic::options::OptionKeys::optE::number_of_swarm_cycles, "The number of cycles to run the swarm minimizer for." ).def(20);
option.add( basic::options::OptionKeys::optE::constrain_weights, "When minimizing the fitness objective function, also include weight constraints in the objective function" );
option.add( basic::options::OptionKeys::optE::fit_reference_energies_to_aa_profile_recovery, "In the inner-loop sequence recovery/weight tweaking stage, accept/reject weight sets based on both the sequence recovery rate, and the mutual information between the expected and observed amino acid frequency distributions" );
option.add( basic::options::OptionKeys::optE::starting_refEs, "IterativeOptEDriver flag: specify a weights file to read reference energies from; do not optimize reference energies in the first round of weight fitting" );
option.add( basic::options::OptionKeys::optE::repeat_swarm_optimization_until_fitness_improves, "After the first time though the particle swarm optimization phase, if the end fitness is not better than the start fitness, recreate the swarm around the start dofs and repeat the swarm optimization." ).def(false);
option.add( basic::options::OptionKeys::optE::design_with_minpack, "Use the min-packer to design in the sequence recovery stages." ).def(false);
option.add( basic::options::OptionKeys::optE::limit_bad_scores, "Quit after 100,000 inf or NaN errors in optE objective function" );
option.add( basic::options::OptionKeys::optE::no_design_pdb_output, "Do not write out the designed pdbs to the workdir_ directories over the course of the optE run" );
option.add( basic::options::OptionKeys::optE::rescore::rescore, "rescore option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::optE::rescore::weights, "Weight set to use when rescoring optE partition functions" );
option.add( basic::options::OptionKeys::optE::rescore::context_round, "Integer of the context PDBs generated during design to use to measure the pNatAA" );
option.add( basic::options::OptionKeys::optE::rescore::outlog, "File to which the OptEPosition data should be written" );
option.add( basic::options::OptionKeys::optE::rescore::measure_sequence_recovery, "When rescoring a weight set, run design with that weight set and measure the sequence recovery." ).def(false);
option.add( basic::options::OptionKeys::packstat::packstat, "packstat option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::packstat::include_water, "Revert to old style etables" ).def(false);
option.add( basic::options::OptionKeys::packstat::oversample, "Precision of SASA measurements" ).def(0);
option.add( basic::options::OptionKeys::packstat::packstat_pdb, "Output a pdb with packing visualizations" ).def(false);
option.add( basic::options::OptionKeys::packstat::surface_accessibility, "Compute extra cavity burial information" ).def(false);
option.add( basic::options::OptionKeys::packstat::residue_scores, "Output the score for each resdiue" ).def(false);
option.add( basic::options::OptionKeys::packstat::cavity_burial_probe_radius, "Radius probe to consider a cavity buried" ).def(1.4);
option.add( basic::options::OptionKeys::packstat::raw_stats, "Output the raw stats per-residue (for training, etc...)" ).def(false);
option.add( basic::options::OptionKeys::packstat::threads, "Number of threads to use (0 for no threading)" ).def(0);
option.add( basic::options::OptionKeys::packstat::cluster_min_volume, "voids smaller than this will not be shown." ).def(30);
option.add( basic::options::OptionKeys::packstat::min_surface_accessibility, "voids must be at least this exposed" ).def(-1.0);
option.add( basic::options::OptionKeys::packstat::min_cluster_overlap, "void-balls must overlap by this much to be clustered" ).def(0.1);
option.add( basic::options::OptionKeys::packstat::min_cav_ball_radius, "radius of smallest void-ball to consider" ).def(0.7);
option.add( basic::options::OptionKeys::parser::parser, "parser option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::parser::info, "Have the rosetta_scripts application print out the available XML-accessible options for a given mover, filter, task operation, or residue selector, and then exit." );
option.add( basic::options::OptionKeys::parser::output_schema, "Have the rosetta_scripts application write out its XML Schema to the given file and then exit." );
option.add( basic::options::OptionKeys::parser::patchdock, "Patchdock output file name." );
option.add( basic::options::OptionKeys::parser::patchdock_random_entry, "Pick a random patchdock entry between two entry numbers. inclusive" ).n(2);
option.add( basic::options::OptionKeys::parser::protocol, "File name for the xml parser protocol" );
option.add( basic::options::OptionKeys::parser::script_vars, "Variable substitutions for xml parser, in the form of name=value" );
option.add( basic::options::OptionKeys::parser::validate_and_exit, "After XML Schema validation completes, exit" );
option.add( basic::options::OptionKeys::parser::view, "Use the viewer?" );
option.add( basic::options::OptionKeys::patterson::patterson, "patterson option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::patterson::weight, "wt of patterson correlation" ).def(0.0);
option.add( basic::options::OptionKeys::patterson::sc_scaling, "Scale sidechain density by this amount (default = same as mainchain density)" ).def(1.0);
option.add( basic::options::OptionKeys::patterson::radius_cutoffs, "patterson-space radius cuttoffs" );
option.add( basic::options::OptionKeys::patterson::resolution_cutoffs, "reciprocal space F^2 cuttoffs" );
option.add( basic::options::OptionKeys::patterson::Bsol, "solvent B" ).def(300.0);
option.add( basic::options::OptionKeys::patterson::Fsol, "solvent fraction" ).def(0.95);
option.add( basic::options::OptionKeys::patterson::model_B, "B factor computing patterson CC" ).def(0.0);
option.add( basic::options::OptionKeys::patterson::rmsd, "Expected RMS error for sigma-A calculation" ).def(2.0);
option.add( basic::options::OptionKeys::patterson::no_ecalc, "Do not normalize p_o with ecalc" ).def(false);
option.add( basic::options::OptionKeys::patterson::nshells, "Number of resolution shells for patterson normalization" ).def(50);
option.add( basic::options::OptionKeys::patterson::use_spline_interpolation, "use spline interpolation for derivative evaluation? (default trilinear)" ).def(false);
option.add( basic::options::OptionKeys::patterson::use_on_repack, "SLOW - use patterson correlation on repacks (default no)" ).def(false);
option.add( basic::options::OptionKeys::patterson::dont_use_symm_in_pcalc, "perform Pcalc in P1 (default no)" ).def(false);
option.add( basic::options::OptionKeys::pb_potential::pb_potential, "pb_potential option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::pb_potential::charged_chains, "Chain numbers that carries charge in the PB calculation" ).def(1);
option.add( basic::options::OptionKeys::pb_potential::sidechain_only, "Only calculate interactions to sidechain." ).def(true);
option.add( basic::options::OptionKeys::pb_potential::revamp_near_chain, "Scale down PB interactions if near the given chain. Use chain numbers as input." );
option.add( basic::options::OptionKeys::pb_potential::apbs_path, "Path to the APBS (Adaptive Poisson-Boltzmann Solver) executable" );
option.add( basic::options::OptionKeys::pb_potential::potential_cap, "Cap for PB potential input" ).def(20.0);
option.add( basic::options::OptionKeys::pb_potential::tolerance, "Tolerance in A.  When a charged atom moves byond this tolerance, the PDE is resolved." ).def(1.0);
option.add( basic::options::OptionKeys::pb_potential::apbs_debug, "APBS debug level [0-6]" ).def(2);
option.add( basic::options::OptionKeys::pb_potential::calcenergy, "Calculate energy?" ).def(false);
option.add( basic::options::OptionKeys::PCS::PCS, "PCS option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::PCS::write_extra, "Write into the File PCS calc, PCS exp, PCS dev, tensor informations, AT EACH ENERGY EVALUATION. More suited for rescoring" );
option.add( basic::options::OptionKeys::PCS::normalization_id, "Normalize individual data set. The integer identify the normalization method to be used" );
option.add( basic::options::OptionKeys::PCSTS1::PCSTS1, "PCSTS1 option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::PCSTS1::write_extra, "Write into the File PCS calc, PCS exp, PCS dev, tensor imformation, AT EACH ENERGY EVALUATION. More suited for rescoring" );
option.add( basic::options::OptionKeys::PCSTS1::normalization_id, "Normalize individual data set. The integer identify the normalization method to be used" );
option.add( basic::options::OptionKeys::PCSTS2::PCSTS2, "PCSTS2 option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::PCSTS2::write_extra, "Write into the File PCS calc, PCS exp, PCS dev, tensor imformation, AT EACH ENERGY EVALUATION. More suited for rescoring" );
option.add( basic::options::OptionKeys::PCSTS2::normalization_id, "Normalize individual data set. The integer identify the normalization method to be used" );
option.add( basic::options::OptionKeys::PCSTS3::PCSTS3, "PCSTS3 option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::PCSTS3::write_extra, "Write into the File PCS calc, PCS exp, PCS dev, tensor imformation, AT EACH ENERGY EVALUATION. More suited for rescoring" );
option.add( basic::options::OptionKeys::PCSTS3::normalization_id, "Normalize individual data set. The integer identify the normalization method to be used" );
option.add( basic::options::OptionKeys::PCSTS4::PCSTS4, "PCSTS4 option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::PCSTS4::write_extra, "Write into the File PCS calc, PCS exp, PCS dev, tensor imformation, AT EACH ENERGY EVALUATION. More suited for rescoring" );
option.add( basic::options::OptionKeys::PCSTS4::normalization_id, "Normalize individual data set. The integer identify the normalization method to be used" );
option.add( basic::options::OptionKeys::pepspec::pepspec, "pepspec option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::pepspec::soft_wts, "No description" ).def("soft_rep.wts");
option.add( basic::options::OptionKeys::pepspec::cen_wts, "No description" ).def("cen_ghost.wts");
option.add( basic::options::OptionKeys::pepspec::binding_score, "No description" ).def(true);
option.add( basic::options::OptionKeys::pepspec::no_cen, "No description" ).def(true);
option.add( basic::options::OptionKeys::pepspec::no_cen_rottrials, "No description" ).def(true);
option.add( basic::options::OptionKeys::pepspec::run_sequential, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::pep_anchor, "No description" );
option.add( basic::options::OptionKeys::pepspec::pep_chain, "No description" ).def(" ");
option.add( basic::options::OptionKeys::pepspec::n_peptides, "No description" ).def(8);
option.add( basic::options::OptionKeys::pepspec::n_build_loop, "No description" ).def(1000);
option.add( basic::options::OptionKeys::pepspec::n_cgrelax_loop, "No description" ).def(1);
option.add( basic::options::OptionKeys::pepspec::n_dock_loop, "No description" ).def(4);
option.add( basic::options::OptionKeys::pepspec::interface_cutoff, "No description" ).def(5.0);
option.add( basic::options::OptionKeys::pepspec::use_input_bb, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::remove_input_bb, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::homol_csts, "No description" ).def("prep.csts");
option.add( basic::options::OptionKeys::pepspec::p_homol_csts, "No description" ).def(1.0);
option.add( basic::options::OptionKeys::pepspec::gen_pep_bb_sequential, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::input_seq, "No description" );
option.add( basic::options::OptionKeys::pepspec::ss_type, "No description" );
option.add( basic::options::OptionKeys::pepspec::upweight_interface, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::calc_sasa, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::diversify_pep_seqs, "No description" ).def(true);
option.add( basic::options::OptionKeys::pepspec::diversify_lvl, "No description" ).def(10);
option.add( basic::options::OptionKeys::pepspec::dump_cg_bb, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::save_low_pdbs, "No description" ).def(true);
option.add( basic::options::OptionKeys::pepspec::save_all_pdbs, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::no_design, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::pdb_list, "No description" );
option.add( basic::options::OptionKeys::pepspec::ref_pdb_list, "No description" );
option.add( basic::options::OptionKeys::pepspec::add_buffer_res, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::cg_res_type, "No description" ).def("ALA");
option.add( basic::options::OptionKeys::pepspec::native_pep_anchor, "No description" );
option.add( basic::options::OptionKeys::pepspec::native_pep_chain, "No description" ).def("");
option.add( basic::options::OptionKeys::pepspec::native_align, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::rmsd_analysis, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::anchor_type, "No description" ).def("ALA");
option.add( basic::options::OptionKeys::pepspec::no_prepack_prot, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::prep_use_ref_rotamers, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::n_prepend, "No description" ).def(0);
option.add( basic::options::OptionKeys::pepspec::n_append, "No description" ).def(0);
option.add( basic::options::OptionKeys::pepspec::clash_cutoff, "No description" ).def(5);
option.add( basic::options::OptionKeys::pepspec::n_anchor_dock_std_devs, "No description" ).def(1.0);
option.add( basic::options::OptionKeys::pepspec::prep_trans_std_dev, "No description" ).def(0.5);
option.add( basic::options::OptionKeys::pepspec::prep_rot_std_dev, "No description" ).def(10.0);
option.add( basic::options::OptionKeys::pepspec::seq_align, "No description" ).def(false);
option.add( basic::options::OptionKeys::pepspec::prep_align_prot_to, "No description" );
option.add( basic::options::OptionKeys::pH::pH, "pH option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::pH::pH_mode, "Allow protonated/deprotonated versions of the residues based on pH" ).def(false);
option.add( basic::options::OptionKeys::pH::keep_input_protonation_state, "Read in residue protonation states from input pdb?" ).def(false);
option.add( basic::options::OptionKeys::pH::value_pH, "pH value input for the pHEnergy score" ).def(7.0);
option.add( basic::options::OptionKeys::pH::calc_pka::calc_pka, "calc_pka option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::pH::calc_pka::pka_all, "Calculate pKa values for all protonatable protein residues in the PDB?" ).def(false);
option.add( basic::options::OptionKeys::pH::calc_pka::pka_for_resnos, "Residue no whose pKa value is to be determined" ).def(0);
option.add( basic::options::OptionKeys::pH::calc_pka::pka_for_chainno, "Chain no of the residue whose pKa is to be determined" ).def("A");
option.add( basic::options::OptionKeys::pH::calc_pka::pH_neighbor_pack, "Pack the neighbors while calculating pKa?" ).def(false);
option.add( basic::options::OptionKeys::pH::calc_pka::pka_rad, "Radius of repack" ).def(5.0);
option.add( basic::options::OptionKeys::pH::calc_pka::pH_prepack, "Prepack structure before calculating pKa values?" ).def(false);
option.add( basic::options::OptionKeys::pH::calc_pka::pH_relax, "Relax structure before calculating pKa values?" ).def(false);
option.add( basic::options::OptionKeys::pH::calc_pka::rotamer_prot_stats, "Get rotamer protonation statistics when titrating?" ).def(false);
option.add( basic::options::OptionKeys::pH::pH_unbound, "Name(s) of unbound receptor and ligand PDB file(s)" );
option.add( basic::options::OptionKeys::pH::output_raw_scores, "Return raw scores contributing to interface score?" );
option.add( basic::options::OptionKeys::pH::pre_process, "Refine rigid body orientation?" );
option.add( basic::options::OptionKeys::pH::cognate_partners, "Chain IDs for the cognate complex" ).def("_");
option.add( basic::options::OptionKeys::pH::cognate_pdb, "File containing the cognate Antigen-Antibody complex" );
option.add( basic::options::OptionKeys::pocket_grid::pocket_grid, "pocket_grid option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::pocket_grid::pocket_grid_size, "grid spacing in Angstroms" ).def(0);
option.add( basic::options::OptionKeys::pocket_grid::pocket_grid_size_x, "grid spacing in Angstroms" ).def(10);
option.add( basic::options::OptionKeys::pocket_grid::pocket_grid_size_y, "grid spacing in Angstroms" ).def(10);
option.add( basic::options::OptionKeys::pocket_grid::pocket_grid_size_z, "grid spacing in Angstroms" ).def(10);
option.add( basic::options::OptionKeys::pocket_grid::pocket_grid_spacing, "grid spacing in Angstroms" ).def(0.5);
option.add( basic::options::OptionKeys::pocket_grid::pocket_max_spacing, "Maximum residue-residue distance to be considered a pocket" ).def(8);
option.add( basic::options::OptionKeys::pocket_grid::pocket_min_size, "Minimum pocket size to score, in cubic Angstroms" ).def(10);
option.add( basic::options::OptionKeys::pocket_grid::pocket_max_size, "Maximum pocket size to report, in cubic Angstroms, 0 for no limit" ).def(0);
option.add( basic::options::OptionKeys::pocket_grid::pocket_probe_radius, "radius of surface probe molecule" ).def(1.0);
option.add( basic::options::OptionKeys::pocket_grid::central_relax_pdb_num, "Residue number:(optional)Chain around which to do Pocket Constraint" ).def("-1");
option.add( basic::options::OptionKeys::pocket_grid::pocket_ntrials, "Number of trials to use for backrub" ).def(100000);
option.add( basic::options::OptionKeys::pocket_grid::pocket_num_angles, "Number of different pose angles to measure pocket score at" ).def(1);
option.add( basic::options::OptionKeys::pocket_grid::pocket_side, "Include only side chain residues for target surface" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::pocket_dump_pdbs, "Generate PDB files" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::pocket_dump_exemplars, "Generate exemplar PDB files" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::pocket_filter_by_exemplar, "Restrict the pocket to the exemplars" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::pocket_limit_exemplar_color, "Include surface donors/acceptors only when they are within range of the main pocket" ).def(true);
option.add( basic::options::OptionKeys::pocket_grid::pocket_limit_small_exemplars, "Require exemplar to have at least 5 hydrophobic elements to output to exemplar file" ).def(true);
option.add( basic::options::OptionKeys::pocket_grid::pocket_dump_rama, "Generate Ramachandran maps for each pocket cluster" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::pocket_restrict_size, "Pockets that are too large return score of 0" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::pocket_ignore_buried, "Ignore pockets that are not solvent exposed" ).def(true);
option.add( basic::options::OptionKeys::pocket_grid::pocket_only_buried, "Identify only pockets buried in the protein core (automatically sets -pocket_ignored_buried false)" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::pocket_psp, "Mark Pocket-Solvent-Pocket events as well" ).def(true);
option.add( basic::options::OptionKeys::pocket_grid::pocket_sps, "Unmark Solvent-Pocket-Solvent events" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::pocket_search13, "Search in 13 directions (all faces and edges of a cube) versus faces and diagonal" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::pocket_surface_score, "Score given to pocket surface" ).def(0);
option.add( basic::options::OptionKeys::pocket_grid::pocket_surface_dist, "Distance to consider pocket surface" ).def(2.5);
option.add( basic::options::OptionKeys::pocket_grid::pocket_buried_score, "Score given to deeply buried pocket points" ).def(5.0);
option.add( basic::options::OptionKeys::pocket_grid::pocket_buried_dist, "Distance to consider pocket buried" ).def(2.0);
option.add( basic::options::OptionKeys::pocket_grid::pocket_exemplar_vdw_pen, "Temporary max penalty for vdW class in exemplar discovery" ).def(300.0);
option.add( basic::options::OptionKeys::pocket_grid::pocket_debug_output, "Print any and all debuggind output related to pockets" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::dump_pocketGrid, "print the pocket grid points into a PDB file" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::dump_Grid, "print the grid points into a PDB file" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::extend_eggshell, "Extend the eggshell points" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::extend_eggshell_dist, "Distance to extend eggshell" ).def(1);
option.add( basic::options::OptionKeys::pocket_grid::extra_eggshell_dist, "Distance to extend extra eggshell points" ).def(4);
option.add( basic::options::OptionKeys::pocket_grid::eggshell_dist, "Distance to extend eggshell points from ligand atoms" ).def(4);
option.add( basic::options::OptionKeys::pocket_grid::reduce_rays, "reduce no. of rays by rounding and removing duplicate xyz coordinates" ).def(true);
option.add( basic::options::OptionKeys::pocket_grid::pocket_static_grid, "No autoexpanding grid" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::dump_espGrid, "print the electrostaticpotential grid into a PDB file" ).def(false);
option.add( basic::options::OptionKeys::pocket_grid::dump_connollySurface, "print the connolly surface points into a PDB file" ).def(false);

}
inline void add_rosetta_options_12( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::pocket_grid::esp_buffer_dist, "buffer dist added to Vdw radius atom while assigining electrostatic potential values" ).def(0.5);
option.add( basic::options::OptionKeys::pocket_grid::round_pocketGrid_center, "round_pocketGrid_center" ).def(true);
option.add( basic::options::OptionKeys::gen_pharmacophore::gen_pharmacophore, "gen_pharmacophore option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::gen_pharmacophore::clash_distance_cutoff, "clash distance cutoff to include ideal hydrogen bonding atoms" ).def(1.0);
option.add( basic::options::OptionKeys::gen_pharmacophore::ring_sasa_cutoff, "ring_sasa_cutoff to include in pharmacophore" ).def(25);
option.add( basic::options::OptionKeys::gen_pharmacophore::min_num_ring, "minimimum number of rings to be in a cluster" ).def(1);
option.add( basic::options::OptionKeys::gen_pharmacophore::ring_ring_dist_cutoff, "ring - ringatom distance to include in the pharmacophore clusters" ).def(5.0);
option.add( basic::options::OptionKeys::gen_pharmacophore::ring_atm_dist_cutoff, "ring - hbond atom distance to include in the pharmacophore clusters" ).def(5.0);
option.add( basic::options::OptionKeys::fingerprint::fingerprint, "fingerprint option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::fingerprint::print_eggshell, "print the eggshell points into a PDB file" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::atom_radius_scale, "Scale to shrink the radius of atom" ).def(0.9);
option.add( basic::options::OptionKeys::fingerprint::atom_radius_buffer, "Value to subtract from all atomic radii, to match PocketGrid buffer thickness" ).def(1.0);
option.add( basic::options::OptionKeys::fingerprint::packing_weight, "Add weight to rho large deviation" ).def(1);
option.add( basic::options::OptionKeys::fingerprint::dist_cut_off, "set cut_off distance to add packing weight" ).def(5);
option.add( basic::options::OptionKeys::fingerprint::include_extrashell_to_set_origin, "include extrashell points to set origin" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::include_hydrogens, "include hydrogen atoms for fingerprint" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::multiple_origin, "set multiple origin points for ray casting" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::use_DARC_gpu, "use GPU when computing DARC score" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::square_score, "square the terms in DARC scoring function" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::darc_components, "get the score for individual components in DARC scoring function" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::set_origin, "option to set orgin: 0 to choose origin based on R(rugedness) value, 1 for protein_center, 2 for eggshell_bottom, 3 for vector from eggshell_plane closest to protein_center, 4 for vector from eggshell_plane distant to protein_center, 5 for choosing a residue center as origin(use the flag -origin_res_num for choosing the residue number)" ).def(0);
option.add( basic::options::OptionKeys::fingerprint::origin_res_num, "Residue number:(optional)Chain to be used as origin for ray-casting" ).def("1");
option.add( basic::options::OptionKeys::fingerprint::add_esp, "add electrostatic calculations" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::darc_shape_only, "darc with shape only" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::darc_elsts_only, "darc with electrostatics only" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::esp_weight, "add weight for electrostatic energy" ).def(0.117);
option.add( basic::options::OptionKeys::fingerprint::esp_protein_wt, "add weight for electrostatic energy inside protein" ).def(0);
option.add( basic::options::OptionKeys::fingerprint::esp_surface_wt, "add weight for electrostatic energy on protein surface" ).def(0);
option.add( basic::options::OptionKeys::fingerprint::delphi_grid, "input electrostatic potential grid if from DELPHI, default is ZAP grid" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::cap_e_potential, "max/min value to cap electrostatic potential" ).def(10.0);
option.add( basic::options::OptionKeys::fingerprint::return_zero_darc_score, "return 0 as darc score" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::set_surface_esp_to_zero, "set surface electrostatic potential to zero" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::set_protein_esp_to_zero, "set protein electrostatic potential to zero" ).def(false);
option.add( basic::options::OptionKeys::fingerprint::inp_lig, "inp_lig" ).def("inp_lig.pdb");
option.add( basic::options::OptionKeys::fingerprint::ref_lig, "ref_lig" ).def("ref_lig.pdb");
option.add( basic::options::OptionKeys::ProQ::ProQ, "ProQ option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::ProQ::svmmodel, "SVM model to use (in cross-validation, default is to use all [1-5])" ).def(1);
option.add( basic::options::OptionKeys::ProQ::basename, "basename location for sequence specific inputfile)" ).def("");
option.add( basic::options::OptionKeys::ProQ::membrane, "use membrane version (ProQM)" ).def(false);
option.add( basic::options::OptionKeys::ProQ::prof_bug, "reproduce the profile bug in ProQres" ).def(false);
option.add( basic::options::OptionKeys::ProQ::output_feature_vector, "outputs the feature vector" ).def(false);
option.add( basic::options::OptionKeys::ProQ::output_local_prediction, "outputs the local predicted values" ).def(false);
option.add( basic::options::OptionKeys::ProQ::prefix, "prefix for outputfiles)" ).def("");
option.add( basic::options::OptionKeys::ProQ::use_gzip, "gzip output files" ).def(false);
option.add( basic::options::OptionKeys::ProQ::normalize, "Normalizing factor (usually target sequence length)" ).def(1.0);
option.add( basic::options::OptionKeys::qsar::qsar, "qsar option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::qsar::weights, "select qsar weight set to use" ).def("talaris2013");
option.add( basic::options::OptionKeys::qsar::grid_dir, "Directory to store grids in" );
option.add( basic::options::OptionKeys::qsar::max_grid_cache_size, "delete old grids if grid cache exceeds specified size" );
option.add( basic::options::OptionKeys::rbe::rbe, "rbe option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rbe::server_url, "serverurl for rosetta backend" );
option.add( basic::options::OptionKeys::rbe::server_port, "port for rosetta backend" ).def("80");
option.add( basic::options::OptionKeys::rbe::poll_frequency, "No description" ).def(1.0);
option.add( basic::options::OptionKeys::RBSegmentRelax::RBSegmentRelax, "RBSegmentRelax option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::RBSegmentRelax::input_pdb, "input pdb file" ).def("--");
option.add( basic::options::OptionKeys::RBSegmentRelax::rb_file, "input rb segment file" ).def("--");
option.add( basic::options::OptionKeys::RBSegmentRelax::nrbmoves, "number of rigid-body moves" ).def(100);
option.add( basic::options::OptionKeys::RBSegmentRelax::nrboutercycles, "number of rigid-body moves" ).def(5);
option.add( basic::options::OptionKeys::RBSegmentRelax::rb_scorefxn, "number of rigid-body moves" ).def("score5");
option.add( basic::options::OptionKeys::RBSegmentRelax::skip_fragment_moves, "omit fragment insertions (in SS elements)" ).def(false);
option.add( basic::options::OptionKeys::RBSegmentRelax::skip_seqshift_moves, "omit sequence shifting moves" ).def(false);
option.add( basic::options::OptionKeys::RBSegmentRelax::skip_rb_moves, "omit rigid-body moves" ).def(false);
option.add( basic::options::OptionKeys::RBSegmentRelax::helical_movement_params, "helical-axis-rotation, helical-axis-translation, off-axis-rotation, off-axis-translation" ).def(utility::vector1<float>(4,0.0));
option.add( basic::options::OptionKeys::RBSegmentRelax::strand_movement_params, "strand-in-plane-rotation, strand-in-plane-translation, out-of-plane-rotation, out-of-plane-translationn" ).def(utility::vector1<float>(4,0.0));
option.add( basic::options::OptionKeys::RBSegmentRelax::default_movement_params, "default-rotation, default-translation" ).def(utility::vector1<float>(2,0.0));
option.add( basic::options::OptionKeys::RBSegmentRelax::cst_seqwidth, "sequence width on constraints" ).def(0);
option.add( basic::options::OptionKeys::rdc::rdc, "rdc option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rdc::correct_NH_length, "fix N-H bond-vector to 1.04 as measured in ottiger&bax 98" ).def(true);
option.add( basic::options::OptionKeys::rdc::reduced_couplings, "gives more equal weights to different bond-vectors" ).def(false);
option.add( basic::options::OptionKeys::rdc::weights, "specify weights for individual residues ( works for all couplings at this reside)" );
option.add( basic::options::OptionKeys::rdc::iterate_weights, "do a wRDC computation, i.e., iterate tensor calculation until weights are ~exp ( -dev2/sigma )" ).def(1);
option.add( basic::options::OptionKeys::rdc::segment_file, "Definition of rigid segments for alignment tensor optimization" );
option.add( basic::options::OptionKeys::rdc::segment_scoring_mode, "Type of treatment of alignment tensor-based scoring : pairwise or fixed_axis_z (e.g. for homo-dimers) " ).legal("pairwise").legal("fixed_axis_z").legal("fixed_sum");
option.add( basic::options::OptionKeys::rdc::total_weight, "Weight for RDC scores of individual al. tensors" ).def(1.0);
option.add( basic::options::OptionKeys::rdc::tensor_weight, "Weight for pairwise scoring of al. tensors" ).def(1.0);
option.add( basic::options::OptionKeys::rdc::print_rdc_values, "print computed vs experimental RDC values" );
option.add( basic::options::OptionKeys::rdc::iterate_tol, "tolerance for tensor iterations" ).def(0.01);
option.add( basic::options::OptionKeys::rdc::iterate_reset, "reset weights to 1.0 when optimizing for new structure" ).def(false);
option.add( basic::options::OptionKeys::rdc::dump_weight_trajectory, "if yes, write weights to file for each scoring event" );
option.add( basic::options::OptionKeys::rdc::fix_normAzz, "divide by this axial tensor component" );
option.add( basic::options::OptionKeys::rdc::fit_method, "No description" ).legal("svd").legal("nls").def("nls");
option.add( basic::options::OptionKeys::rdc::fixDa, "No description" );
option.add( basic::options::OptionKeys::rdc::fixR, "No description" );
option.add( basic::options::OptionKeys::rdc::nlsrepeat, "No description" ).def(5);
option.add( basic::options::OptionKeys::relax::relax, "relax option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::relax::fast, "Do a preset, small cycle number FastRelax" );
option.add( basic::options::OptionKeys::relax::thorough, "Do a preset, large cycle number FastRelax" );
option.add( basic::options::OptionKeys::relax::centroid_mode, "Use centroid relax protocol" ).def(false);
option.add( basic::options::OptionKeys::relax::default_repeats, "Default number of repeats done by FastRelax. Has no effect if a custom script is used!" ).def(5);
option.add( basic::options::OptionKeys::relax::dualspace, "Do 3 FastRelax cycles of internal coordinate relax followed by two cycles of Cartesian relax - cart_bonded energy term is required, pro_close energy term should be turned off, and use of -relax::minimize_bond_angles is recommended.  Use of the -nonideal flag switches all these and sets up correct min cycles, minimizer type, etc." );
option.add( basic::options::OptionKeys::relax::cyclic_peptide, "Set up N-to-C constraints in a cyclic peptide" );
option.add( basic::options::OptionKeys::relax::range::range, "range option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::relax::range::set_tm_helical, "Set helical secondary structure in TM region" ).def(false);
option.add( basic::options::OptionKeys::relax::range::kT, "Advanced option: kT" ).def(1.0);
option.add( basic::options::OptionKeys::relax::range::angle_max, "Maximum dihedral angle deviation for Small and ShearMover inside RangeRelax" ).def(0.1);
option.add( basic::options::OptionKeys::relax::range::nmoves, "Number of Small and Shear moves inside RangeRelax, can be 'nres' for all residues or an integer" ).def("nres");
option.add( basic::options::OptionKeys::relax::range::spherical_wave, "Relax in a spherical wave pattern starting at the center residue outwards." ).def(false);
option.add( basic::options::OptionKeys::relax::range::repack_again, "Do an additional round of repacking all residues after the RangeRelax" ).def(false);
option.add( basic::options::OptionKeys::relax::range::cycles, "Maximum number of cycles for repacking and minimization. Default 3" ).def(3);
option.add( basic::options::OptionKeys::relax::range::min_cycles, "Maximum number of cycles within the Minimizer. Default 2000" ).def(2000);
option.add( basic::options::OptionKeys::relax::range::idealize, "Idealize decoy after run. Default: true" ).def(true);
option.add( basic::options::OptionKeys::relax::range::skip_relax, "Skip relax step. Default: false" ).def(false);
option.add( basic::options::OptionKeys::relax::ramady, "Run ramady code which aleviates stuck bad ramachandran energies" ).def(false);
option.add( basic::options::OptionKeys::relax::ramady_rms_limit, "(ramady-only) Reject rama changes which perturb structure by more than this" ).def(0.5);
option.add( basic::options::OptionKeys::relax::ramady_cutoff, "(ramady-only) Cutoff at which a rama is considered bad" ).def(2.0);
option.add( basic::options::OptionKeys::relax::ramady_max_rebuild, "(ramady-only) The maximum number of bad ramas to fix per repack-min cycle" ).def(1);
option.add( basic::options::OptionKeys::relax::ramady_force, "(ramady-only) Force rebuilding of bad ramas (normal skip-rate = 10%)" ).def(false);
option.add( basic::options::OptionKeys::relax::script, "Relax script file" ).def("");
option.add( basic::options::OptionKeys::relax::script_max_accept, "Limit number of best accepts" ).def(10000000);
option.add( basic::options::OptionKeys::relax::superimpose_to_native, "Superimpose input structure to native" ).def(false);
option.add( basic::options::OptionKeys::relax::superimpose_to_file, "Superimpose input structure to file" ).def("false");
option.add( basic::options::OptionKeys::relax::constrain_relax_to_native_coords, "For relax and fastrelax, tether backbone coordinates of the pdbs being relaxed to the coordinates in the xtal native" ).def(false);
option.add( basic::options::OptionKeys::relax::constrain_relax_to_start_coords, "For relax and fastrelax, tether backbone coordinates of the pdbs being relaxed to the coordinates in the xtal native" ).def(false);
option.add( basic::options::OptionKeys::relax::coord_constrain_sidechains, "For relax and fastrelax, also tether sidechain heavy atom coordinates (requires either -constrain_relax_to_native_coords or -constrain_relax_to_start_coords)" ).def(false);
option.add( basic::options::OptionKeys::relax::sc_cst_maxdist, "Use distance constraints between pairs of input side-chains atoms which are closer than the given upper distance cutoff (0 => no sc-sc restraints)" ).def(0.0);
option.add( basic::options::OptionKeys::relax::limit_aroma_chi2, "limit chi2 rotamer of PHE,TYR, and HIS around 90 " ).def(false);
option.add( basic::options::OptionKeys::relax::respect_resfile, "Tell FastRelax to respect the input resfile.  Used mainly for doing design within FastRelax." ).def(false);
option.add( basic::options::OptionKeys::relax::bb_move, "allow backbone to move during relax" ).def(true);
option.add( basic::options::OptionKeys::relax::chi_move, "allow sidechain to move during relax" ).def(true);
option.add( basic::options::OptionKeys::relax::jump_move, "allow jump to move during relax" ).def(false);
option.add( basic::options::OptionKeys::relax::dna_move, "allow dna to move during relax + allow DNA-DNA interactions. Best if used with orbitals scorefunction. DNA stays together with great molprobity results.  Not recommended for general use at this time." ).def(false);
option.add( basic::options::OptionKeys::relax::fix_omega, "Fix omega angles during relax" ).def(false);
option.add( basic::options::OptionKeys::relax::minimize_bond_lengths, "Free bond length DOFs during relax for all atoms" ).def(false);
option.add( basic::options::OptionKeys::relax::minimize_bond_angles, "Free bond angle DOFs during relax for all atoms" ).def(false);
option.add( basic::options::OptionKeys::relax::minimize_bondlength_subset, "Minimize only a subset of bondlengths 0 Default  all bondlengths 1          backbone only 2          sidechain only 3          CA only (Ca-C,Ca-N and Ca-Cb)" ).legal(0).legal(1).legal(2).legal(3).def(0);
option.add( basic::options::OptionKeys::relax::minimize_bondangle_subset, "Minimize only a subset of bondlengths 0 Default  all bondangles 1          backbone only 2          sidechain only 3          tau only 4          Ca-Cb only" ).legal(0).legal(1).legal(2).legal(3).legal(4).def(0);
option.add( basic::options::OptionKeys::relax::min_type, "minimizer to use during relax." ).legal("linmin").legal("linmin_iterated").legal("linmin_iterated_atol").legal("dfpmin").legal("dfpmin_armijo").legal("dfpmin_armijo_nonmonotone").legal("dfpmin_atol").legal("dfpmin_armijo_atol").legal("dfpmin_armijo_nonmonoton_atol").legal("dfpmin_strong_wolfe").legal("dfpmin_strong_wolfe_atol").legal("lbfgs_armijo").legal("lbfgs_armijo_rescored").legal("lbfgs_armijo_atol").legal("lbfgs_armijo_nonmonotone").legal("lbfgs_armijo_nonmonotone_atol").legal("lbfgs_strong_wolfe").def("lbfgs_armijo_nonmonotone");
option.add( basic::options::OptionKeys::relax::cartesian, "Use Cartesian minimizer" ).def(false);
option.add( basic::options::OptionKeys::relax::chainbreak_weight, "chainbreak weight" ).def(0.0);
option.add( basic::options::OptionKeys::relax::linear_chainbreak_weight, "linear chainbreak weight" ).def(0.0);
option.add( basic::options::OptionKeys::relax::overlap_chainbreak_weight, "overlap chainbreak weight" ).def(0.0);
option.add( basic::options::OptionKeys::relax::classic, "Do very old classic relax ! This is a poor protocol - don't use it !" );
option.add( basic::options::OptionKeys::relax::sequence_file, "Relax script file" ).def("");
option.add( basic::options::OptionKeys::relax::quick, "Do a preset, small cycle number FastRelax" );
option.add( basic::options::OptionKeys::relax::sequence, "Do a preset, small cycle number FastRelax" );
option.add( basic::options::OptionKeys::relax::minirelax_repeats, "" ).def(2);
option.add( basic::options::OptionKeys::relax::minirelax_sdev, "tether on coordinate constraints for minirelax" ).def(0.5);
option.add( basic::options::OptionKeys::relax::wobblemoves, "Do Wobble moves ?" ).def(false);
option.add( basic::options::OptionKeys::relax::constrain_relax_segments, "loop definition file" ).def("");
option.add( basic::options::OptionKeys::relax::coord_cst_width, "Width on coordinate constraints from constrain_relax_* options" ).def(0.0);
option.add( basic::options::OptionKeys::relax::coord_cst_stdev, "Stdev on coordinate constraints from constrain_relax_* options" ).def(0.5);
option.add( basic::options::OptionKeys::relax::ramp_constraints, "Ramp constraints during phase1 of relax from full to zero" ).def(false);
option.add( basic::options::OptionKeys::relax::energycut, "Rottrial energycut (per residue!)" ).def(0.01);
option.add( basic::options::OptionKeys::relax::mini, "perform a relax that is only a minimization and repack." ).def(false);
option.add( basic::options::OptionKeys::relax::stage1_ramp_cycles, "Ramp cyclesin stage 1 " ).def(8);
option.add( basic::options::OptionKeys::relax::stage1_ramp_inner_cycles, "Inner cycles means how many small shear moves + rottrials" ).def(1);
option.add( basic::options::OptionKeys::relax::stage2_repack_period, "Full repack after how many cycles in stage 2" ).def(100);
option.add( basic::options::OptionKeys::relax::stage2_cycles, "How many stage 2 cycles ? (by default its -1 means Nresidues*4 )" ).def(-1);
option.add( basic::options::OptionKeys::relax::min_tolerance, "Minimizer tolerance" ).def(0.00025);
option.add( basic::options::OptionKeys::relax::stage3_cycles, "How many stage 3 cycles ? (by default its -1 means Nresidues )" ).def(-1);
option.add( basic::options::OptionKeys::relax::cycle_ratio, "Post-multiplier for cycle numbers" ).def(1.0);
option.add( basic::options::OptionKeys::relax::filter_stage2_beginning, "FArelax score filter" ).def(99999999.00);
option.add( basic::options::OptionKeys::relax::filter_stage2_quarter, "FArelax score filter" ).def(99999999.00);
option.add( basic::options::OptionKeys::relax::filter_stage2_half, "FArelax score filter" ).def(99999999.00);
option.add( basic::options::OptionKeys::relax::filter_stage2_end, "FArelax score filter" ).def(99999999.00);
option.add( basic::options::OptionKeys::relax::centroid::centroid, "centroid option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::relax::centroid::weights, "Weights to use for centroid minimization" ).def("score4_smooth_cen_relax");
option.add( basic::options::OptionKeys::relax::centroid::ramp_vdw, "Ramp up the VDW weight" ).def(true);
option.add( basic::options::OptionKeys::relax::centroid::ramp_rama, "Ramp up the rama/rama2b weight" ).def(false);
option.add( basic::options::OptionKeys::relax::centroid::parameters, "Database file for ramp/min parameter" ).def("sampling/cen_relax/default_relax_parameters.txt");
option.add( basic::options::OptionKeys::relax::centroid::do_final_repack, "Repack sidechains in movemap after protocol if given a fullatom structure" ).def(false);
option.add( basic::options::OptionKeys::relax::centroid::increase_vdw_radii, "Increase BB vdw radii" ).def(false);
option.add( basic::options::OptionKeys::remodel::remodel, "remodel option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::remodel::blueprint, "blueprint file name" );
option.add( basic::options::OptionKeys::remodel::cstfile, "description" );
option.add( basic::options::OptionKeys::remodel::cst_fa_only, "false" );
option.add( basic::options::OptionKeys::remodel::cstfilter, "filter cst energy" ).def(10);
option.add( basic::options::OptionKeys::remodel::cen_sfxn, "centroid score function to be used for building" ).def("remodel_cen");
option.add( basic::options::OptionKeys::remodel::check_scored_centroid, "dump centroid structures after build" ).def(false);
option.add( basic::options::OptionKeys::remodel::num_trajectory, "Number of remodel trajectories." ).def(10);
option.add( basic::options::OptionKeys::remodel::save_top, "the number of final low scoring pdbs to keep." ).def(5);
option.add( basic::options::OptionKeys::remodel::swap_refine_confirm_protocols, "swapping the protocols used refinement and confirmation" ).def(false);
option.add( basic::options::OptionKeys::remodel::bypass_fragments, "only works on input PDB, so no extensions or deletions are honored in the blueprint.  Blueprint (H,L,E,D) becomes allow_move definitionsi." );
option.add( basic::options::OptionKeys::remodel::use_same_length_fragments, "harvest fragments that matches the length to rebuild" ).def(true);
option.add( basic::options::OptionKeys::remodel::no_jumps, "will setup simple foldtree and fold through it during centroid build." ).def(false);
option.add( basic::options::OptionKeys::remodel::reroot_tree, "rerooting the tree for the build." ).def(1);
option.add( basic::options::OptionKeys::remodel::use_blueprint_sequence , " picks fragments based on both secondary structure and the second column (sequence) in blueprint file" );
option.add( basic::options::OptionKeys::remodel::quick_and_dirty , " only do fragment insertion" );
option.add( basic::options::OptionKeys::remodel::checkpoint , " this writes out the best pdbs collected so far after each design step." );
option.add( basic::options::OptionKeys::remodel::use_pose_relax , " an alternative to the default minimization step, but use constraints in a similar way." );
option.add( basic::options::OptionKeys::remodel::use_cart_relax , " an alternative to the default minimization step, but use constraints in a similar way." );
option.add( basic::options::OptionKeys::remodel::free_relax , " running pose_relax with no constraints." ).def(false);
option.add( basic::options::OptionKeys::remodel::generic_aa, "the type of AA for centroid building" ).def("V");
option.add( basic::options::OptionKeys::remodel::cluster_radius, "cluster radius for accumulator, default to auto set value" ).def(-1.0);
option.add( basic::options::OptionKeys::remodel::use_clusters, "use clustering in accumulator" ).def(false);
option.add( basic::options::OptionKeys::remodel::run_confirmation, "use KIC rms confirmation" ).def(false);
option.add( basic::options::OptionKeys::remodel::cluster_on_entire_pose, "cluster use all pose, not just loops" ).def(false);
option.add( basic::options::OptionKeys::remodel::dr_cycles, "number of design-refine cycles to use" ).def(3);
option.add( basic::options::OptionKeys::remodel::two_chain_tree, "label the start of the second chain" );
option.add( basic::options::OptionKeys::remodel::repeat_structure, "build identical repeats this many times" ).def(1);
option.add( basic::options::OptionKeys::remodel::lh_ex_limit, "loophasing neighboring bin expansion limit" ).def(5);
option.add( basic::options::OptionKeys::remodel::lh_filter_string, "loophash ABEGO filter target fragment type. list sequentially for each loop" );
option.add( basic::options::OptionKeys::remodel::lh_cbreak_selection, "loophash with cbreak dominant weight" ).def(10);
option.add( basic::options::OptionKeys::remodel::lh_closure_filter, "filter for close rms when bypass_closure is used" ).def(false);
option.add( basic::options::OptionKeys::remodel::cen_minimize, "centroid minimization after fragment building" ).def(false);
option.add( basic::options::OptionKeys::remodel::core_cutoff, "number of neighbors required to consider core in auto design" ).def(18);
option.add( basic::options::OptionKeys::remodel::boundary_cutoff, "number of neighbors required to consider boundary in auto design" ).def(15);
option.add( basic::options::OptionKeys::remodel::coreAA, "amino acid set for core" ).def("");
option.add( basic::options::OptionKeys::remodel::boundaryAA, "amino acid set for boundary" ).def("");
option.add( basic::options::OptionKeys::remodel::surfaceAA, "amino acid set for surface" ).def("");
option.add( basic::options::OptionKeys::remodel::design_around_ligand, "apply manual design mode around the ligand" ).def(false);
option.add( basic::options::OptionKeys::remodel::move_ligand, "apply ligand handler to move ligand" ).def(false);
option.add( basic::options::OptionKeys::remodel::resclass_by_sasa, "switch to use sasa for residue classification" ).def(false);
option.add( basic::options::OptionKeys::remodel::helical_rise, "helical parameter: rise" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::helical_radius, "helical parameter: radius" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::helical_omega, "helical parameter: omega" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::filter_rise, "filter value range for helical params rise" ).n(2);
option.add( basic::options::OptionKeys::remodel::filter_radius, "filter value range for helical params radius" ).n(2);
option.add( basic::options::OptionKeys::remodel::filter_omega, "filter value range for helical params omega" ).n(2);
option.add( basic::options::OptionKeys::remodel::COM_sd, "center of mass coordinate constraint sd value" ).def(1.0);
option.add( basic::options::OptionKeys::remodel::COM_tolerance, "center of mass coordinate constraint tolerance value" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::vdw, "set vdw weight" ).def(1.0);
option.add( basic::options::OptionKeys::remodel::rama, "set rama weight" ).def(0.1);
option.add( basic::options::OptionKeys::remodel::cbeta, "set cbeta weight" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::cenpack, "set cenpack weight" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::rg_local, "set rg_local weight" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::hb_lrbb, "set hbond_lrbb weight" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::hb_srbb, "set hbond_srbb weight" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::rg, "set rg weight" );
option.add( basic::options::OptionKeys::remodel::rsigma, "set rsigma weight" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::ss_pair, "set sspair weight" ).def(0.0);
option.add( basic::options::OptionKeys::remodel::build_disulf, "build disulfides" ).def(false);
option.add( basic::options::OptionKeys::remodel::match_rt_limit, "match RT score cutoff" ).def(0.4);
option.add( basic::options::OptionKeys::remodel::disulf_landing_range, "residue range for disulf landing sites" ).n(2);
option.add( basic::options::OptionKeys::remodel::rank_by_bsasa, "rank results by bsasa." );
option.add( basic::options::OptionKeys::remodel::staged_sampling::staged_sampling, "sampling first with 9mers then 3mers. Staged energies. For rebuilding entire structure not loop closure" ).def(false).is_group(true);
option.add( basic::options::OptionKeys::remodel::staged_sampling::residues_to_sample, "residues to allow sampling (format:1,3,5)" ).def("");
option.add( basic::options::OptionKeys::remodel::staged_sampling::starting_sequence, "AA sequence to start" ).def("");
option.add( basic::options::OptionKeys::remodel::staged_sampling::starting_pdb, "pdb to start" ).def("");
option.add( basic::options::OptionKeys::remodel::staged_sampling::starting_non_canonical, "position,non canonical to be added" ).def("");
option.add( basic::options::OptionKeys::remodel::staged_sampling::require_frags_match_blueprint, "makes sure the frags match the definition in the blueprint" ).def(true);
option.add( basic::options::OptionKeys::remodel::staged_sampling::start_w_ideal_helices, "begins with all helices set to -63.8 phi and -41.1 for psi." ).def(false);
option.add( basic::options::OptionKeys::remodel::staged_sampling::sample_over_loops, "sample residues defined as loops in the blueprint" ).def(false);
option.add( basic::options::OptionKeys::remodel::staged_sampling::small_moves, "add a stage of small moves" ).def(false);
option.add( basic::options::OptionKeys::remodel::staged_sampling::fa_mode, "does the fragment assembly stage in fa" ).def(false);
option.add( basic::options::OptionKeys::remodel::staged_sampling::fa_relax_moves, "Adds a stage of fa relax" ).def(false);
option.add( basic::options::OptionKeys::remodel::staged_sampling::sym_move, "Adds a symmetry move to the abinitio stage" ).def(false);
option.add( basic::options::OptionKeys::remodel::staged_sampling::loop_btw_parametric_components, "Sets up a mode where a loop can be inserted into a parametric repeat" ).def(false);
option.add( basic::options::OptionKeys::remodel::staged_sampling::pre_centroid, "initialize fa mode with 200 cycles of centroid" ).def(false);
option.add( basic::options::OptionKeys::remodel::domainFusion::domainFusion, "domainFusion option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::remodel::domainFusion::insert_segment_from_pdb, "segment pdb file to be inserted [insert pdb file name]." ).def("");
option.add( basic::options::OptionKeys::remodel::domainFusion::insert_segment2_from_pdb, "segment2 pdb file to be inserted [insert pdb file name]." ).def("");
option.add( basic::options::OptionKeys::remodel::design::design, "design option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::remodel::design::no_design , " skips all design steps. WARNING: will only output centroid level structures and dump all fragment tries." );
option.add( basic::options::OptionKeys::remodel::design::design_all, " force AUTO design procedure (layered) to perform design on all positions. " );
option.add( basic::options::OptionKeys::remodel::design::allow_rare_aro_chi, "allow all aromatic rotamers, not issuing AroChi2 filter" ).def(false);

}
inline void add_rosetta_options_13( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::remodel::design::skip_partial, " skip design stage that operate only on burial positions" ).def(false);
option.add( basic::options::OptionKeys::remodel::design::design_neighbors, "design neighbors." ).def(false);
option.add( basic::options::OptionKeys::remodel::design::find_neighbors, "find neighbors for design/repack" ).def(false);
option.add( basic::options::OptionKeys::remodel::design::include_current, "include current rotamers" ).def(true);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::RemodelLoopMover, "RemodelLoopMover option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::max_linear_chainbreak, "linear chainbreak is <= this value, loop is considered closed (default 0.07) " ).def(0.07);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::randomize_loops, "randomize loops prior to running main protocol (default true)" ).def(true);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::use_loop_hash, "centroid build with loop hash (default false)" ).def(false);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::set_segment, "directly set segment phi-psi-omega from file" ).def("");
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::allowed_closure_attempts, "the allowed number of overall closure attempts (default 1)" ).def(1);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::loophash_cycles, "the number of loophash closure cycles to perform (default 8)" ).def(8);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::simultaneous_cycles, "the number of simultaneous closure cycles to perform (default 2)" ).def(2);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::independent_cycles, "the number of independent closure cycles to perform (default 8)" ).def(8);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::boost_closure_cycles, "the maximum number of possible lockdown closure cycles to perform (default 30)" ).def(30);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::threshold_for_boost_closure, "numerical chainbreak threshold for entering boost_closure_stage" ).def(1.0);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::force_cutting_index, "force a cutpoint shift index of blueprint assignment" ).def(1);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::force_cutting_N, "force a cutpoint at N-term side of blueprint assignment" ).def(false);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::bypass_closure, "turning off CCD closure in the mover for tethered docking purpose" ).def(false);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::cyclic_peptide, "circularize structure joining N and C-term." ).def(false);
option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::temperature, "temperature for monte carlo ( default 2.0)" ).def(2.0);
option.add( basic::options::OptionKeys::resample::resample, "resample option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::resample::silent, "a silent file for decoys to restart sampling from " ).def("");
option.add( basic::options::OptionKeys::resample::tag, "which decoy to select from silent file " ).def("");
option.add( basic::options::OptionKeys::resample::stage1, "if true restart after stage1, otherwise after stage2 " ).def(false);
option.add( basic::options::OptionKeys::resample::stage2, "if true restart after stage1, otherwise after stage2 " ).def(false);
option.add( basic::options::OptionKeys::resample::jumps, "if true restart after stage1, otherwise after stage2 " ).def(false);
option.add( basic::options::OptionKeys::resample::min_max_start_seq_sep, "range of (random) start values for seq-separation" ).def(0);
option.add( basic::options::OptionKeys::rescore::rescore, "rescore option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rescore::assign_ss, "Invoke DSSP to assign secondary structure." ).def(false);
option.add( basic::options::OptionKeys::rescore::skip, "Dont actually call scoring function (i.e. get evaluators only)" );
option.add( basic::options::OptionKeys::rescore::verbose, "Full break down of weights, raw scores and weighted scores ?" );
option.add( basic::options::OptionKeys::rna::rna, "rna option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rna::corrected_geo, "Use PHENIX-based RNA sugar close energy and params files" ).def(true);
option.add( basic::options::OptionKeys::rna::rna_prot_erraser, "Allows rna_prot_erraser residue type set, featuring both RNA and protein (for ERRASER purposes).  You must also use -rna:corrected_geo." ).def(false);
option.add( basic::options::OptionKeys::rna::vary_geometry, "Let bond lengths and angles vary from ideal in minimizer" ).def(false);
option.add( basic::options::OptionKeys::rna::data_file, "RDAT or legacy-format file with RNA chemical mapping data" ).def("");
option.add( basic::options::OptionKeys::rna::cut_at_rna_chainbreak, "If O3' to P distance is > 2.5 Angstroms, assume cutpoint." ).def(false);
option.add( basic::options::OptionKeys::rna::evaluate_base_pairs, "In final scoring, compute number of Watson-Crick, non-Watson-Crick pairs; compare to native if available." );
option.add( basic::options::OptionKeys::rna::farna::farna, "farna option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rna::farna::cycles, "Default number of Monte Carlo cycles" ).def(0);
option.add( basic::options::OptionKeys::rna::farna::rna_protein_docking_freq, "RNA/protein docking frequency" ).def(10);
option.add( basic::options::OptionKeys::rna::farna::rounds, "Number of rounds to split cycles into during fragment assembly" ).def(10);
option.add( basic::options::OptionKeys::rna::farna::temperature, "temperature" ).def(2.0);
option.add( basic::options::OptionKeys::rna::farna::minimize_rna, "Minimize RNA after fragment assembly" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::sequence, "RNA sequence to model (better to supply in -fasta)" ).def();
option.add( basic::options::OptionKeys::rna::farna::secstruct, "RNA sec struct to model (better to supply in -secstruct_file)" ).def("");
option.add( basic::options::OptionKeys::rna::farna::secstruct_general, "RNA sec struct to model with possible noncanonical pairs" ).def("");
option.add( basic::options::OptionKeys::rna::farna::secstruct_file, "RNA sec struct to model in dot-parens notation" ).def("");
option.add( basic::options::OptionKeys::rna::farna::secstruct_general_file, "RNA sec struct (+non-canonical pairs) to model in dot-parens notation" ).def("");
option.add( basic::options::OptionKeys::rna::farna::secstruct_legacy, "RNA sec struct in old 1D notation: H,helix; L,loop; X,unknown; N,bulge" ).def("");
option.add( basic::options::OptionKeys::rna::farna::lores_scorefxn, "Low resolution scorefunction weights file" ).def("farna/rna_lores.wts");
option.add( basic::options::OptionKeys::rna::farna::params_file, "Input file for pairings [deprecated!]" ).def("default.prm");
option.add( basic::options::OptionKeys::rna::farna::filter_lores_base_pairs, "Filter for models that satisfy structure parameters" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::filter_lores_base_pairs_early, "Filter for models that satisfy structure parameters at round 2 of 10" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::filter_chain_closure, "Filter for models that have closed chains after lores before minimize" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::filter_chain_closure_halfway, "Filter for models that have closed chains after lores before minimize at round 5 of 10" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::filter_chain_closure_distance, "Mean distance across 3 chainbreak atoms to filter models that have closed chains after lores" ).def(6.0);
option.add( basic::options::OptionKeys::rna::farna::relax_rna, "Relax RNA after fragment assembly" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::simple_relax, "Relax by minimizing after any fragment insertion" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::ignore_secstruct, "Ignore sec struct in input file" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::jump_change_frequency, "jump change frequency" ).def(0.1);
option.add( basic::options::OptionKeys::rna::farna::close_loops, "close loops after de novo protocol and again after minimization" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::close_loops_after_each_move, "close loops during frag insertion and jump mover -- can be expensive" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::heat, "Heat (random frag insertions)" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::staged_constraints, "Apply constraints in stages depending on sequence separation" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::jump_library_file, "Input file for jumps" ).def("sampling/rna/1jj2_RNA_jump_library.dat");
option.add( basic::options::OptionKeys::rna::farna::vall_torsions, "Torsions file containing information on fragments from RNA models" ).def("rna.torsions");
option.add( basic::options::OptionKeys::rna::farna::use_1jj2_torsions, "Use original (ribosome) fragments, 1JJ2" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::rna_lores_chainbreak_weight, "chainbreak weight for lo res sampling" ).def(0.0);
option.add( basic::options::OptionKeys::rna::farna::rna_lores_linear_chainbreak_weight, "linear chainbreak weight for lo res sampling" ).def(0.0);
option.add( basic::options::OptionKeys::rna::farna::fixed_stems, "Seed each stem with a Watson-Crick base pair instead of having the strands find each other" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::allow_bulge, "Automatically virtualize residues that are not energetically stable" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::allowed_bulge_res, "Use with allow_bulge, allowable pos for virtualization" ).def();
option.add( basic::options::OptionKeys::rna::farna::allow_consecutive_bulges, "allow_consecutive_bulges" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::move_first_rigid_body, "first_rigid_body is usually kept frozen, but might be useful to sample it." ).def(false);
option.add( basic::options::OptionKeys::rna::farna::root_at_first_rigid_body, "places coordinate system away from the usual last virtual residue and puts it on the first rigid body. useful if this rigidbody needs to be fixed, but other bodies need to move as if this one is moving. Use with -move_first_rigid_body. " ).def(false);
option.add( basic::options::OptionKeys::rna::farna::suppress_bp_constraint, "Factor by which to lower base pair constraint weight. " ).def(1.0);
option.add( basic::options::OptionKeys::rna::farna::output_filters, "output lores scores at early stage (round  2 of 10) and at end -- could be useable for early termination of unpromising early starts" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::autofilter, "Automatically skip output/minimize if lores score is worse than 20th percentile, updated on the fly." ).def(true);
option.add( basic::options::OptionKeys::rna::farna::no_filters, "Turn off filters in FARFAR. (umbrella flag) -autofilter false -filter_lores_base_pairs false -filter_lores_base_pairs_early false -filter_chain_closure false -filter_chain_closure_halfway false -filter_chain_closure_distance false" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::output_res_num, "Numbering (and chain) of residues in output PDB or silent file" ).def();
option.add( basic::options::OptionKeys::rna::farna::offset, "Numbering offset for output PDB or silent file (better to use -output_res_num))" ).def(0);
option.add( basic::options::OptionKeys::rna::farna::input_silent_res, "Input residues for silent files" ).def();
option.add( basic::options::OptionKeys::rna::farna::virtual_anchor, "In rigid body movements, which residues in each body are rotation centers" ).def();
option.add( basic::options::OptionKeys::rna::farna::obligate_pair, "Residue pairs that must form a base pair (possibly non canonical)" ).def();
option.add( basic::options::OptionKeys::rna::farna::obligate_pair_explicit, "Residue pairs that must form a base pair, with specification of base edges (W/H/S/X) and orientation (A/P/X or C/T/X)" ).def();
option.add( basic::options::OptionKeys::rna::farna::chain_connection, "Give SET1 ... and SET2 ... to define segments forming at least one base pair" ).def();
option.add( basic::options::OptionKeys::rna::farna::remove_pair, "Residue pairs to remove from secondary structure" ).def();
option.add( basic::options::OptionKeys::rna::farna::remove_obligate_pair, "Residue pairs to remove from obligate pair list" ).def();
option.add( basic::options::OptionKeys::rna::farna::refine_silent_file, "Name of the silent file to be refined." ).def("");
option.add( basic::options::OptionKeys::rna::farna::refine_native, "Refine starting from the native pose" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::bps_moves, "Base pair step moves" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::disallow_bps_at_extra_min_res, "Disallow base pair step moves inside input domains, even extra_min_res" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::allow_fragment_moves_in_bps, "Allow fragment/jump moves in regions claimed by base pair steps" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::frag_size, "Force specific fragment size rather than staged from 3 to 2 to 1" ).def(0);
option.add( basic::options::OptionKeys::rna::farna::VDW_rep_screen_include_sidechains, "Include side chains in the VDW rep screen, use with -VDW_rep_screen_info" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::gradual_constraints, "Gradually turn on the atom_pair_constraints and coordinate_constraints?" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::grid_vdw_weight, "Weight for the grid vdw score term" ).def(1.0);
option.add( basic::options::OptionKeys::rna::farna::tag, "tag for naming silent file; legacy of rna_denovo_setup.py" ).def("");
option.add( basic::options::OptionKeys::rna::farna::working_native, "Native to use if we only know a fragment" ).def("false");
option.add( basic::options::OptionKeys::rna::farna::use_legacy_setup, "Use old de novo setup without residue/chain mapping" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::cst_gap, "Setup up atompair constraints to keep chain ends close if they are known to be part of the same chain in full model pose" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::convert_protein_CEN, "Convert protein residues to centroid mode during low-res fragment assembly" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::rna_protein_docking, "Do RNA/protein docking?" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::exclude_fragments, "Exclude these fragments from vall" ).def();
option.add( basic::options::OptionKeys::rna::farna::exclusion_match_type, "How tightly should we match fragments? Either sequence-independent (MATCH_ALL), purine vs. pyrimidine (MATCH_YR), or exact (MATCH_EXACT)" ).def("MATCH_EXACT");
option.add( basic::options::OptionKeys::rna::farna::fragment_homology_rmsd, "Distance in RMSD below which a fragment is considered homologous to the native" ).def(1.0);
option.add( basic::options::OptionKeys::rna::farna::exclude_native_fragments, "Exclude fragments from -in:file:native" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::exclude_fragment_files, "Files from which to exclude fragments" ).def();
option.add( basic::options::OptionKeys::rna::farna::out::out, "out option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rna::farna::out::output_lores_silent_file, "output lores stuff" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::out::dump, "Dump pdb" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::out::binary_output, "force output to binary rna silentstruct" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::out::output_score_file, "output running score to this file [specify 'none' if no score output; .SCORES.txt in default]" ).def("");
option.add( basic::options::OptionKeys::rna::farna::out::output_score_frequency, "output running score with this frequency [0 means no running output]" ).def(0);
option.add( basic::options::OptionKeys::rna::farna::out::output_jump_res, "output jump information for these two residues" ).def();
option.add( basic::options::OptionKeys::rna::farna::out::output_jump_o3p_to_o5p, "compute jump from o3' to o5' (instead of base centroid coordinate systems)" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::out::output_rotation_vector, "output rotation information as rotation vector (in degrees), not euler angles" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::out::target_xyz, "Target coordinates for harmonic penalty, o5' relative to o3' stub" ).def();
option.add( basic::options::OptionKeys::rna::farna::out::save_jump_histogram, "Save jump information into a 6D histogram" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::out::output_histogram_file, "output histogram to this file [specify 'none' if no score output; .HISTOGRAM.txt is default]" ).def("");
option.add( basic::options::OptionKeys::rna::farna::out::jump_histogram_boxsize, "Boxsize (max +/-x,y,z), Angstroms" ).def(40.0);
option.add( basic::options::OptionKeys::rna::farna::out::jump_histogram_binwidth, "Bin-width for x,y,z,, Angstroms" ).def(4.0);
option.add( basic::options::OptionKeys::rna::farna::out::jump_histogram_binwidth_rotvector, "Bin-width for rotation vector (degrees)" ).def(36.0);
option.add( basic::options::OptionKeys::rna::farna::db::db, "db option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rna::farna::db::jump_database, "Generate a database of jumps extracted from base pairings from a big RNA file" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::db::bps_database, "Generate a database of base pair steps extracted from a big RNA file" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::erraser::erraser, "erraser option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rna::farna::erraser::constrain_P, "constrain phosphate" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::erraser::fixed_res, "optional: residues to be held fixed in minimizer" ).def();
option.add( basic::options::OptionKeys::rna::farna::erraser::ready_set_only, "load in and output directly for reformatting the pdb" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::erraser::skip_minimize, "output the pdb without minimization" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::erraser::attempt_pyrimidine_flip, "try to flip pyrimidine by 180 degrees and pick the better energy conformer" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::minimize::minimize, "minimize option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rna::farna::minimize::minimize_rounds, "The number of rounds of minimization." ).def(2);
option.add( basic::options::OptionKeys::rna::farna::minimize::skip_coord_constraints, "Skip first stage of minimize with coordinate constraints" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::minimize::skip_o2prime_trials, "No O2* packing in minimizer" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::minimize::deriv_check, "In rna_minimize, check derivatives numerically" ).def(false);
option.add( basic::options::OptionKeys::rna::farna::minimize::minimizer_use_coordinate_constraints, "Use coordinate constraints for first round of minimizer" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::minimize::min_type, "Minimizer type" ).def("lbfgs_armijo_nonmonotone");
option.add( basic::options::OptionKeys::rna::farna::minimize::minimize_bps, "Minimize base pair steps (from Rosetta library)" ).def(true);
option.add( basic::options::OptionKeys::rna::farna::minimize::extra_minimize_res, "Extra residues during minimize step" ).def();
option.add( basic::options::OptionKeys::rna::farna::minimize::extra_minimize_chi_res, "Extra side-chain chis to move during minimize step" ).def();
option.add( basic::options::OptionKeys::rotamerdump::rotamerdump, "rotamerdump option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rotamerdump::xyz, "when using the RotamerDump application, output the xyz coords of every rotamer" ).def(false);
option.add( basic::options::OptionKeys::rotamerdump::one_body, "when using the RotamerDump application, output the one_body energies of every rotamer" ).def(false);
option.add( basic::options::OptionKeys::rotamerdump::two_body, "when using the RotamerDump application, output the two_body energies of every rotamer" ).def(false);
option.add( basic::options::OptionKeys::rotamerdump::annealer, "Run the annealer and output the rotamers it chose" ).def(false);
option.add( basic::options::OptionKeys::sample_around::sample_around, "sample_around option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::sample_around::alpha_increment, "if sampling jump, rotation increment, in degrees" ).def(40.0);
option.add( basic::options::OptionKeys::sample_around::cosbeta_increment, "if sampling jump, cosbeta increment, no units" ).def(0.25);
option.add( basic::options::OptionKeys::sample_around::gamma_increment, "if sampling jump, rotation increment, in degrees" ).def(40.0);
option.add( basic::options::OptionKeys::sicdock::sicdock, "sicdock option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::sicdock::clash_dis, "max acceptable clash dis" ).def(3.5);
option.add( basic::options::OptionKeys::sicdock::contact_dis, "max acceptable contact dis" ).def(12.0);
option.add( basic::options::OptionKeys::sicdock::hash_2D_vs_3D, "grid spacing top 2D hash" ).def(1.3);
option.add( basic::options::OptionKeys::sewing::sewing, "sewing option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::sewing::model_file_name, "Filename for model file (creation or reading)" );
option.add( basic::options::OptionKeys::sewing::score_file_name, "Filename for scores file (creation or reading)" );
option.add( basic::options::OptionKeys::sewing::new_model_file_name, "Filename for new model file to be written" );
option.add( basic::options::OptionKeys::sewing::remove_any_dssp, "If a given model has *any* segments with this DSSP, remove it" ).def("");
option.add( basic::options::OptionKeys::sewing::remove_all_dssp, "If a given model has *all* non-loop segments with this DSSP, remove it" ).def("");
option.add( basic::options::OptionKeys::sewing::min_helix_length, "Helices less than supplied length will be removed from model file" ).def(0);
option.add( basic::options::OptionKeys::sewing::max_helix_length, "Helices greater than supplied length will be removed from model file" ).def(1000);
option.add( basic::options::OptionKeys::sewing::min_loop_length, "Loops less than supplied length will be removed from model file" ).def(0);
option.add( basic::options::OptionKeys::sewing::max_loop_length, "Loops greater than supplied length will be removed from model file" ).def(1000);
option.add( basic::options::OptionKeys::sewing::min_strand_length, "Strands less than supplied length will be removed from model file" ).def(0);
option.add( basic::options::OptionKeys::sewing::max_strand_length, "Strands greater than supplied length will be removed from model file" ).def(1000);
option.add( basic::options::OptionKeys::sewing::leave_models_by_ss_num, "Only models with certain number of secondary structures remain" ).def(false);
option.add( basic::options::OptionKeys::sewing::model_should_have_this_num_of_ss, "Only models with this number of secondary structures remain" );
option.add( basic::options::OptionKeys::sewing::model_should_have_at_least_1_E_at_terminal_segment, "model_should_have_at_least_one_E_at_terminal_segment" ).def(false);
option.add( basic::options::OptionKeys::sewing::model_should_have_at_least_1_E, "model_should_have_at_least_one_E" ).def(false);
option.add( basic::options::OptionKeys::sewing::model_should_have_at_least_1_H, "model_should_have_at_least_one_H" ).def(false);
option.add( basic::options::OptionKeys::sewing::leave_models_with_E_terminal_ss, "leave only models_with_E_terminal_ss" ).def(false);
option.add( basic::options::OptionKeys::sewing::leave_models_with_H_terminal_ss, "leave only models_with_H_terminal_ss" ).def(false);
option.add( basic::options::OptionKeys::sewing::leave_antiparallel_way_H_bonded_models_by_terminal_strands, "leave only anti-pa H_bonded_models by_terminal_strands" ).def(false);
option.add( basic::options::OptionKeys::sewing::leave_parallel_way_H_bonded_models_by_terminal_strands, "leave only pa H_bonded_models by_terminal_strands" ).def(false);
option.add( basic::options::OptionKeys::sewing::leave_certain_model_ids, "Only models with selected ids are left" ).def(false);
option.add( basic::options::OptionKeys::sewing::leave_these_model_ids, "Only models with selected ids are left" );
option.add( basic::options::OptionKeys::sewing::box_length, "Neighborhood lookup box size, 3 for 27 boxes, 4 for 64 boxes etc" ).def(3);
option.add( basic::options::OptionKeys::sewing::mode, "The mode sewing_hasher should run." ).legal("hash").legal("generate").legal("generate_five_ss_model").legal("convert").legal("test").def("hash");
option.add( basic::options::OptionKeys::sewing::disregard_num_segment_matches, "if true, disregard num_segment_matches" );
option.add( basic::options::OptionKeys::sewing::do_not_remove_connection_inconsistencies, "if true, do not remove_connection_inconsistencies" );
option.add( basic::options::OptionKeys::sewing::score_between_opposite_terminal_segments, "if true, score_between_opposite_terminal_segments like 1-5 or 5-1" );
option.add( basic::options::OptionKeys::sewing::num_models_to_dump, "Used for ModelDumper. How many random models should be dumped?" );
option.add( basic::options::OptionKeys::sewing::models_to_dump, "Used for ModelDumper for specifying model ids you want to dump" );
option.add( basic::options::OptionKeys::sewing::min_hash_score, "Minimum number of overlapping atoms per segment" ).def(10);
option.add( basic::options::OptionKeys::sewing::max_clash_score, "Maximum number of atoms found in the same bin, but not from superimposed fragments" ).def(0);
option.add( basic::options::OptionKeys::sewing::num_segments_to_match, "Number of segments required to have min_hash_score atom matches" ).def(1);
option.add( basic::options::OptionKeys::sewing::match_segments, "Segment scored by the hasher" );
option.add( basic::options::OptionKeys::sewing::max_models, "Maximum models to hash, for testing purposes only" );
option.add( basic::options::OptionKeys::sewing::starting_model, "Starting model for hashing" );
option.add( basic::options::OptionKeys::sewing::num_procs, "Number of processors to split up hashing with" );
option.add( basic::options::OptionKeys::sewing::rank, "The processor rank for this process" );
option.add( basic::options::OptionKeys::sewing::hash_tag_only_terminal_Es, "hash_tag_only_terminal_Es" ).def(false);
option.add( basic::options::OptionKeys::sewing::assembly_type, "Type of Assembly class to generate" ).def("continuous");
option.add( basic::options::OptionKeys::sewing::num_edges_to_follow, "Maximum number of edges on graph to follow" );
option.add( basic::options::OptionKeys::sewing::base_native_bonus, "Weighting term for packing native rotamers" );
option.add( basic::options::OptionKeys::sewing::neighbor_cutoff, "Cutoff for favoring natives in SEWING refinement. Any residues with fewer neighbors is not favored" );
option.add( basic::options::OptionKeys::sewing::dump_pdbs, "Dump intermediate PDBs" ).def(false);
option.add( basic::options::OptionKeys::sewing::skip_refinement, "Should you refine the final assembly" ).def(false);
option.add( basic::options::OptionKeys::sewing::skip_filters, "Should the Assembly be filtered before refinment" ).def(false);
option.add( basic::options::OptionKeys::sewing::min_motif_score, "Minimum allowable motif score" ).def(20);
option.add( basic::options::OptionKeys::sewing::may_add_already_added_model, "may_add_already_added_model" ).def(false);
option.add( basic::options::OptionKeys::sewing::offset_bump_dsq, "offset to bump_dsq" ).def(0);
option.add( basic::options::OptionKeys::sewing::num_repeats, "Number of repeats to print in final structures" ).def(3);
option.add( basic::options::OptionKeys::sewing::repeat, "Should the AssemblyConstraintsMover treat this as a repeat?" ).def(false);
option.add( basic::options::OptionKeys::sewing::pose_segment_starts, "Segment begin indices" );
option.add( basic::options::OptionKeys::sewing::pose_segment_ends, "Segment end indices" );
option.add( basic::options::OptionKeys::sewing::keep_source_segments, "Keep the source segments rather than the target segments. For use with append" ).def(false);
option.add( basic::options::OptionKeys::sewing::partner_pdb, "A PDB that is not part of the Assembly, but will be used for clash checking" );
option.add( basic::options::OptionKeys::sewing::keep_model_residues, "A list of residues from the input pose that will not be designed (but are repacked)" );
option.add( basic::options::OptionKeys::sewing::min_lh_fragments, "Minimium number of LoopHash fragments necessary for each designed loop" ).def(10);
option.add( basic::options::OptionKeys::sewing::skip_loop_generation, "Should you skip generation of loops" ).def(false);
option.add( basic::options::OptionKeys::sewing::max_ss_num, "max_ss_num so either 3 (smotif) or 5 (5-ss_models)" ).def(5);
option.add( basic::options::OptionKeys::sewing::dump_every_model, "dump_every_model" ).def(false);
option.add( basic::options::OptionKeys::SSrbrelax::SSrbrelax, "SSrbrelax option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::SSrbrelax::rb_file, "rb definition file" ).def("rb_file");
option.add( basic::options::OptionKeys::SSrbrelax::rb_param_file, "rb param file" ).def("rb_param_file");
option.add( basic::options::OptionKeys::SSrbrelax::frag_sizes, "lengths of fragments to be used in loop modeling" ).def(9).def(3).def(1);
option.add( basic::options::OptionKeys::SSrbrelax::frag_files, "fragment libraries files" ).def("FragFile9").def("FragFile3").def("FragFile1");
option.add( basic::options::OptionKeys::stepwise::stepwise, "stepwise option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::stepwise::s1, "input file(s)" );
option.add( basic::options::OptionKeys::stepwise::s2, "input file(s)" );
option.add( basic::options::OptionKeys::stepwise::silent1, "input file" );
option.add( basic::options::OptionKeys::stepwise::silent2, "input file" );
option.add( basic::options::OptionKeys::stepwise::tags1, "input tag(s)" );
option.add( basic::options::OptionKeys::stepwise::tags2, "input tag(s)" );
option.add( basic::options::OptionKeys::stepwise::slice_res1, "Residues to slice out of starting file" ).def();
option.add( basic::options::OptionKeys::stepwise::slice_res2, "Residues to slice out of starting file" ).def();
option.add( basic::options::OptionKeys::stepwise::input_res1, "Residues already present in starting file" ).def();
option.add( basic::options::OptionKeys::stepwise::input_res2, "Residues already present in starting file2" ).def();
option.add( basic::options::OptionKeys::stepwise::backbone_only1, "just copy protein backbone DOFS, useful for homology modeling" );
option.add( basic::options::OptionKeys::stepwise::backbone_only2, "just copy protein backbone DOFS, useful for homology modeling" );
option.add( basic::options::OptionKeys::stepwise::fixed_res, "Do not move these residues during minimization." ).def();
option.add( basic::options::OptionKeys::stepwise::test_encapsulation, "Test ability StepWiseRNA Modeler to figure out what it needs from just the pose - no JobParameters" ).def(false);
option.add( basic::options::OptionKeys::stepwise::choose_random, "ask swa residue sampler for a random solution" ).def(false);
option.add( basic::options::OptionKeys::stepwise::num_random_samples, "In choose_random/monte-carlo mode, number of samples from swa residue sampler before minimizing best" ).def(20);
option.add( basic::options::OptionKeys::stepwise::max_tries_multiplier_for_ccd, "In choose_random/monte-carlo mode, when CCD closure needs to occur, multiple # tries by this factor" ).def(10);
option.add( basic::options::OptionKeys::stepwise::num_pose_minimize, "optional: set_num_pose_minimize by Minimizer" ).def(0);
option.add( basic::options::OptionKeys::stepwise::atr_rep_screen, "In sampling, screen for contacts (but no clash) between partitions before packing" ).def(true);
option.add( basic::options::OptionKeys::stepwise::atr_rep_screen_for_docking, "In just docking moves, screen for contacts (but no clash) between partitions before packing" ).def(false);
option.add( basic::options::OptionKeys::stepwise::align_pdb, "PDB to align to. Default will be -native, or no alignment" ).def("");
option.add( basic::options::OptionKeys::stepwise::enumerate, "For SWM. Force enumeration (SWA-like) instead of random" ).def(false);
option.add( basic::options::OptionKeys::stepwise::preminimize, "For SWM. Just prepack and minimize" ).def(false);
option.add( basic::options::OptionKeys::stepwise::skip_preminimize, "Skip preminimize before stepwise monte carlo" ).def(false);

}
inline void add_rosetta_options_14( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::stepwise::minimize_waters, "When hydrating magnesiums, minimize any waters that appear" ).def(false);
option.add( basic::options::OptionKeys::stepwise::test_all_moves, "Try all moves from starting pose, recursing through additions " ).def(false);
option.add( basic::options::OptionKeys::stepwise::new_move_selector, "For SWM. Use new move selector which does keep track of proposal probabilities." ).def(true);
option.add( basic::options::OptionKeys::stepwise::dump, "Dump intermediate silent & PDB files" ).def(false);
option.add( basic::options::OptionKeys::stepwise::VERBOSE, "VERBOSE" ).def(false);
option.add( basic::options::OptionKeys::stepwise::use_green_packer, "use packer instead of rotamer trials for side-chain packing and O2' optimization" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rmsd_screen, "keep sampled residues within this rmsd from the native pose" ).def(0.0);
option.add( basic::options::OptionKeys::stepwise::skip_minimize, "Skip minimize, e.g. in prepack step" ).def(false);
option.add( basic::options::OptionKeys::stepwise::virtualize_packable_moieties_in_screening_pose, "Virtualize 2'-OH, terminal phosphates in stepwise contact screening, before actual packing " ).def(false);
option.add( basic::options::OptionKeys::stepwise::minimizer_mode, "Minimize using thermal sampler (THERMAL_SAMPLER) or traditionally (TRADITIONAL_MINIMIZER, or really anything else)" ).def("TRADITIONAL_MINIMIZER");
option.add( basic::options::OptionKeys::stepwise::sampler_silent_file, "In StepWiseConnectionSampler, where to output all poses that pass filters" ).def("");
option.add( basic::options::OptionKeys::stepwise::superimpose_over_all, "In final superimposition, do not keep any domains fixed, superimpose over everything" ).def(false);
option.add( basic::options::OptionKeys::stepwise::move, "For SWM. Format: 'ADD 5 BOND_TO_PREVIOUS 4'" ).def();
option.add( basic::options::OptionKeys::stepwise::min_type, "Minimizer type" ).legal("linmin").legal("linmin_iterated").legal("linmin_iterated_atol").legal("dfpmin").legal("dfpmin_armijo").legal("dfpmin_armijo_nonmonotone").legal("dfpmin_atol").legal("dfpmin_armijo_atol").legal("dfpmin_armijo_nonmonoton_atol").legal("dfpmin_strong_wolfe").legal("dfpmin_strong_wolfe_atol").legal("lbfgs_armijo").legal("lbfgs_armijo_rescored").legal("lbfgs_armijo_atol").legal("lbfgs_armijo_nonmonotone").legal("lbfgs_armijo_nonmonotone_atol").legal("lbfgs_strong_wolfe").def("lbfgs_armijo_nonmonotone");
option.add( basic::options::OptionKeys::stepwise::min_tolerance, "Minimizer tolerance" ).def(0.000025);
option.add( basic::options::OptionKeys::stepwise::vary_polar_hydrogen_geometry, "Optimize hydrogens that form hydrogen bonds" ).def(false);
option.add( basic::options::OptionKeys::stepwise::output_minimized_pose_list, "Use legacy output that puts out all minimized poses; set to true in legacy SWA" ).def(false);
option.add( basic::options::OptionKeys::stepwise::virtualize_free_moieties_in_native, "Virtualize bulges, terminal phosphates, and 2' hydroxyls detected to be non-interacting ('free') in native pose. I.e., do not calculate RMSD over those atoms." ).def(true);
option.add( basic::options::OptionKeys::stepwise::output_cluster_size, "Output cluster_size in StepWiseClusterer as an extra score in the pose" ).def(false);
option.add( basic::options::OptionKeys::stepwise::lores, "Use coarse-grained energy function to sample; no minimize." ).def(false);
option.add( basic::options::OptionKeys::stepwise::verbose_sampler, "verbose output from StepWiseConnectionSampler sample-and-screen." ).def(false);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::monte_carlo, "monte_carlo option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::verbose_scores, "Show all score components" ).def(false);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::skip_deletions, "no delete moves -- just for testing" ).def(false);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::allow_internal_hinge_moves, "Allow moves in which internal suites are sampled (hinge-like motions)" ).def(true);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::allow_internal_local_moves, "Allow moves in which internal cutpoints are created to allow ERRASER rebuilds" ).def(true);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::allow_skip_bulge, "Allow moves in which an intervening residue is skipped and the next one is modeled as floating base" ).def(false);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::skip_bulge_frequency, "Compared to 'normal' add moves, how often to skip a bulge and do addition." ).def(0.0);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::from_scratch_frequency, "Allow modeling of 'free' dinucleotides that are not part of input poses" ).def(0.1);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::allow_split_off, "Allow chunks that do not contain fixed domains to split off after nucleating on fixed domains." ).def(true);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::cycles, "Number of Monte Carlo cycles" ).def(50);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::temperature, "Monte Carlo temperature" ).def(1.0);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::add_proposal_density_factor, "Increase/decrease the proposal_density_ratio for add moves by this factor" ).def(1.0);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::add_delete_frequency, "Frequency of add/delete vs. resampling" ).def(0.5);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::docking_frequency, "Frequency of docking vs. folding moves" ).def(0.2);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::submotif_frequency, "Frequency of submotif additions" ).def(0.2);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::intermolecular_frequency, "Same as -docking_frequency, to be deprecated soon" ).def(0.2);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::minimize_single_res_frequency, "Frequency with which to minimize the residue that just got rebuilt, instead of all" ).def(0.0);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::allow_variable_bond_geometry, "In 10% of moves, let bond angles & distance change" ).def(true);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::switch_focus_frequency, "Frequency with which to switch the sub-pose that is being modeled" ).def(0.5);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::just_min_after_mutation_frequency, "After a mutation, how often to just minimize (without further sampling the mutated residue)" ).def(0.5);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::local_redock_only, "In ResampleMover, docking partners can change anywhere across connected chains. Force the new partners to be close to the old ones." ).def(true);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::make_movie, "create silent files in movie/ with all steps and accepted steps" ).def(false);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::recover_low, "Output lowest energy model in monte carlo, not the last frame" ).def(true);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::use_precomputed_library, "In from_scratch moves, do not sample dinucleotides explicitly, but instead use library saved to disk." ).def(true);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::allow_submotif_split, "for submotif moves, allow submotifs to be split. (inconsistent with detailed balance.)" ).def(false);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::force_submotif_without_intervening_bulge, "for submotif moves, only add base pairs that have an attachment point and a cutpoint closed, with no intervening bulge" ).def(false);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::use_first_jump_for_submotif, "for submotif moves, only use first jump from jump library -- does not change stepwise -lores (which resamples jump) except in balance of move selection." ).def(false);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::vary_loop_length_frequency, "In design, allow loops ('n') to shorten from loop lengths defined in FASTA files." ).def(0.0);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::checkpointing_frequency, "How often should we output checkpoint files?" ).def(0);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::csa::csa, "csa option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::csa::csa_bank_size, "Do conformational space annealing (population monte carlo) with this number of models in the bank" ).def(0);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::csa::csa_rmsd, "RMSD cutoff for calling two poses different in conformational space annealing (population monte carlo)" ).def(1.0);
option.add( basic::options::OptionKeys::stepwise::monte_carlo::csa::csa_output_rounds, "output silent files at intermediate stages (at integral multiples of bank_size)" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::rna, "rna option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::stepwise::rna::sampler_num_pose_kept, "set_num_pose_kept by ResidueSampler )" ).def(108);
option.add( basic::options::OptionKeys::stepwise::rna::native_edensity_score_cutoff, "native_edensity_score_cutoff" ).def(-1.0);
option.add( basic::options::OptionKeys::stepwise::rna::o2prime_legacy_mode, "complete virtualization of O2' hydrogen during sampling, and then complete restoration and packing" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::allow_virtual_o2prime_hydrogens, "allow O2' hydrogen to be virtualized during packing." ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::sampler_perform_phosphate_pack, "perform terminal phosphate packing inside StepWiseRNA_ResidueSampler" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::force_phosphate_instantiation, "Require terminal phosphates to be instantiated." ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::distinguish_pucker, "distinguish pucker when cluster:both in sampler and clusterer" ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::finer_sampling_at_chain_closure, "Sampler: finer_sampling_at_chain_closure" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::PBP_clustering_at_chain_closure, "Sampler: PBP_clustering_at_chain_closure" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::sampler_allow_syn_pyrimidine, "sampler_allow_syn_pyrimidine" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::sampler_extra_chi_rotamer, "Sampler: extra_syn_chi_rotamer" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::sampler_extra_beta_rotamer, "Sampler: extra_beta_rotamer" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::sampler_extra_epsilon_rotamer, "Sampler: extra_epsilon_rotamer" ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::force_centroid_interaction, "Require base stack or pair even for single residue loop closed (which could also be bulges!)" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::virtual_sugar_legacy_mode, "In virtual sugar sampling, use legacy protocol to match Parin's original workflow" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::VDW_rep_optimize_memory_usage, "RNA_VDW_BinChecker, do not store vector of occupied xyz bins." ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::erraser, "Use KIC sampling" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::centroid_screen, "centroid_screen" ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::VDW_atr_rep_screen, "classic VDW_atr_rep_screen" ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::minimize_and_score_native_pose, "minimize_and_score_native_pose " ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::rm_virt_phosphate, "Remove virtual phosphate patches during minimization" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::VDW_rep_screen_info, "VDW_rep_screen_info to create VDW_rep_screen_bin ( useful when building loop from large poses )" ).def();
option.add( basic::options::OptionKeys::stepwise::rna::VDW_rep_alignment_RMSD_CUTOFF, "use with VDW_rep_screen_info" ).def(0.001);
option.add( basic::options::OptionKeys::stepwise::rna::VDW_rep_delete_matching_res, "delete residues in VDW_rep_pose that exist in the working_pose" ).def();
option.add( basic::options::OptionKeys::stepwise::rna::VDW_rep_screen_physical_pose_clash_dist_cutoff, "The distance cutoff for VDW_rep_screen_with_physical_pose" ).def(1.2);
option.add( basic::options::OptionKeys::stepwise::rna::integration_test, " integration_test " ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::allow_bulge_at_chainbreak, "Allow sampler to replace chainbreak res with virtual_rna_variant if it looks have bad fa_atr score." ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::parin_favorite_output, " parin_favorite_output " ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::reinitialize_CCD_torsions, "Sampler: reinitialize_CCD_torsions: Reinitialize_CCD_torsion to zero before every CCD chain closure" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::sample_both_sugar_base_rotamer, "Sampler: Super hacky for SQUARE_RNA" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::sampler_include_torsion_value_in_tag, "Sampler:include_torsion_value_in_tag" ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::sampler_assert_no_virt_sugar_sampling, "sampler_assert_no_virt_sugar_sampling" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::sampler_try_sugar_instantiation, "for floating base sampling, try to instantiate sugar if it looks promising" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::do_not_sample_multiple_virtual_sugar, " Sampler: do_not_sample_multiple_virtual_sugar " ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::sample_ONLY_multiple_virtual_sugar, " Sampler: sample_ONLY_multiple_virtual_sugar " ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::allow_base_pair_only_centroid_screen, "allow_base_pair_only_centroid_screen" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::minimizer_rename_tag, "Reorder and rename the tag by the energy_score" ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::minimize_res, "alternative to fixed_res" ).def();
option.add( basic::options::OptionKeys::stepwise::rna::alignment_res, "align_res_list" ).def();
option.add( basic::options::OptionKeys::stepwise::rna::native_alignment_res, "optional: native_alignment_res " ).def();
option.add( basic::options::OptionKeys::stepwise::rna::rmsd_res, "residues that will be use to calculate rmsd ( for clustering as well as RMSD to native_pdb if specified )" ).def();
option.add( basic::options::OptionKeys::stepwise::rna::missing_res, "Residues missing in starting pose_1, alternative to input_res" ).def();
option.add( basic::options::OptionKeys::stepwise::rna::missing_res2, "Residues missing in starting pose_2, alternative to input_res2" ).def();
option.add( basic::options::OptionKeys::stepwise::rna::job_queue_ID, "swa_rna_sample()/combine_long_loop mode: Specify the tag pair in filter_output_filename to be read in and imported ( start from 0! )" ).def(0);
option.add( basic::options::OptionKeys::stepwise::rna::minimize_and_score_sugar, "minimize and sugar torsion + angle? and include the rna_sugar_close_score_term " ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::global_sample_res_list, "A list of all the nucleotide to be build/sample over the entire dag." ).def();
option.add( basic::options::OptionKeys::stepwise::rna::filter_output_filename, "CombineLongLoopFilterer: filter_output_filename" ).def("filter_struct.txt");
option.add( basic::options::OptionKeys::stepwise::rna::combine_long_loop_mode, " Sampler: combine_long_loop_mode " ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::combine_helical_silent_file, "CombineLongLoopFilterer: combine_helical_silent_file" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::output_extra_RMSDs, "output_extra_RMSDs" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::protonated_H1_adenosine_list, "optional: protonate_H1_adenosine_list" ).def();
option.add( basic::options::OptionKeys::stepwise::rna::native_virtual_res, " optional: native_virtual_res " ).def();
option.add( basic::options::OptionKeys::stepwise::rna::simple_append_map, "simple_append_map" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::allow_fixed_res_at_moving_res, "mainly just to get Hermann Duplex modeling to work" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::force_user_defined_jumps, "Trust and use user defined jumps" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::jump_point_pairs, "optional: extra jump_points specified by the user for setting up the fold_tree " ).def();
option.add( basic::options::OptionKeys::stepwise::rna::add_virt_root, "add_virt_root" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::floating_base, " floating_base " ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::floating_base_anchor_res, "If we want floating base to be connected via a jump to an anchor res (with no intervening virtual residues), specify the anchor." ).def(0);
option.add( basic::options::OptionKeys::stepwise::rna::allow_chain_boundary_jump_partner_right_at_fixed_BP, "mainly just to get Hermann nano - square RNA modeling to work" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::rebuild_bulge_mode, "rebuild_bulge_mode" ).def(false);
option.add( basic::options::OptionKeys::stepwise::rna::virtual_sugar_keep_base_fixed, "When instantiating virtual sugar, keep base fixed -- do not spend a lot of time to minimize!" ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::virtual_sugar_do_minimize, "When instantiating virtual sugar, minimize (as in original SWA code) -- takes extra time!" ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::sampler_max_centroid_distance, "max centroid distance of moving base to reference in floating base sampler" ).def(0.0);
option.add( basic::options::OptionKeys::stepwise::rna::filter_user_alignment_res, " filter_user_alignment_res " ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::tether_jump, "In rigid body moves, keep moving residue close to (jump-connected) reference residue  (8.0 A) and force centroid interaction between them" ).def(true);
option.add( basic::options::OptionKeys::stepwise::rna::turn_off_rna_chem_map_during_optimize, "When using rna_chem_map, only score with this after minimizing (takes too long to compute during optimizing)." ).def(true);
option.add( basic::options::OptionKeys::stepwise::protein::protein, "protein option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::stepwise::protein::global_optimize, "In clustering, packing, minimizing, use all residues." ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::disable_sampling_of_loop_takeoff, "For KIC protein loop closure, disallow sampling of psi at N-terminus and phi at C-terminus takeoff residues" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::sample_beta, "sample beta strand pairing -- later need to specify parallel/antiparallel" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::ghost_loops, "Virtualize loops in centroid screening" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::centroid_screen, "Centroid Screen" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::centroid_score_diff_cut, "If doing -centroid_screen, only keep poses whose energies are within this energy of reference.." ).def(20.0);
option.add( basic::options::OptionKeys::stepwise::protein::centroid_weights, "weights for centroid filter" ).def("score3.wts");
option.add( basic::options::OptionKeys::stepwise::protein::score_diff_cut, "score difference cut for clustering" ).def(10.0);
option.add( basic::options::OptionKeys::stepwise::protein::filter_native_big_bins, "Figure out various terms for score12" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::cluster_by_all_atom_rmsd, "cluster by all atom rmsd" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::centroid_output, "output centroid structure during screening" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::n_sample, "number of samples per torsion angle" ).def(18);
option.add( basic::options::OptionKeys::stepwise::protein::nstruct_centroid, "Number of decoys to output from centroid screening" ).def(0);
option.add( basic::options::OptionKeys::stepwise::protein::ccd_close, "Close loops with CCD" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::bridge_res, "instead of enumerative sampling of backbone torsions, combine silent files that contains pieces of loops" ).def();
option.add( basic::options::OptionKeys::stepwise::protein::cart_min, "Use cartesian minimizer" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::move_jumps_between_chains, "Move all jumps" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::use_packer_instead_of_rotamer_trials, "Use packer instead of rotamer trials in residue sampling" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::expand_loop_takeoff, "expand -sample_res loop to include connection to previous/next residues" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::skip_coord_constraints, "Skip first stage of minimize with coordinate constraints" ).def(false);
option.add( basic::options::OptionKeys::stepwise::protein::allow_virtual_side_chains, "In packing, allow virtual side chains" ).def(true);
option.add( basic::options::OptionKeys::stepwise::protein::protein_prepack, "In packing, prepack separate partitions" ).def(true);
option.add( basic::options::OptionKeys::stepwise::protein::disulfide_file, "File with pairs of numbers for desired disulfides." ).def("");
option.add( basic::options::OptionKeys::full_model::full_model, "full_model option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::full_model::cutpoint_open, "open cutpoints in full model" ).def();
option.add( basic::options::OptionKeys::full_model::cutpoint_closed, "closed cutpoints in full model" ).def();
option.add( basic::options::OptionKeys::full_model::cyclize, "cyclize points in full model" ).def();
option.add( basic::options::OptionKeys::full_model::other_poses, "list of PDB files containing other poses" );
option.add( basic::options::OptionKeys::full_model::jump_res, "optional: residues for defining jumps -- please supply in pairs" ).def();
option.add( basic::options::OptionKeys::full_model::extra_min_res, "specify residues other than those being built that should be minimized" ).def();
option.add( basic::options::OptionKeys::full_model::extra_min_jump_res, "specify jump-connected pairs  other than those being built that should be minimized" ).def();
option.add( basic::options::OptionKeys::full_model::root_res, "optional: desired root res (used in SWM move testing)" ).def();
option.add( basic::options::OptionKeys::full_model::virtual_sugar_res, "optional: starting virtual sugars (used in SWM move testing)" ).def();
option.add( basic::options::OptionKeys::full_model::virtual_res, "optional: residues for defining virtual residues" ).def();
option.add( basic::options::OptionKeys::full_model::sample_res, "residues to build (for SWA, the first element is the actual sample res while the other are the bulge residues)" ).def();
option.add( basic::options::OptionKeys::full_model::calc_rms_res, "residues over which to calculate rms for SWA. Not in wide use anymore." ).def();
option.add( basic::options::OptionKeys::full_model::working_res, "residues that are being built [by default will be set from sample_res and any input pdbs]" ).def();
option.add( basic::options::OptionKeys::full_model::motif_mode, "in fixed PDB parts, minimize residues right next to loops & disallow pair/stacking in most distal residues" ).def(false);
option.add( basic::options::OptionKeys::full_model::allow_jump_in_numbering, "useful for design. if residue numbers jump from i to i+1 do *not* assume cutpoint." ).def(false);
option.add( basic::options::OptionKeys::full_model::rna::rna, "rna option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::full_model::rna::terminal_res, "optional: residues that are not allowed to stack during sampling" ).def();
option.add( basic::options::OptionKeys::full_model::rna::block_stack_above_res, "optional: residues on which other residues cannot stack above (uses repulsion atoms)" ).def();
option.add( basic::options::OptionKeys::full_model::rna::block_stack_below_res, "optional: residues on which other residues cannot stack below (uses repulsion atoms)" ).def();
option.add( basic::options::OptionKeys::full_model::rna::force_syn_chi_res_list, "optional: sample only syn chi for the res in sampler." ).def();
option.add( basic::options::OptionKeys::full_model::rna::force_anti_chi_res_list, "optional: sample only anti chi for the res in sampler." ).def();
option.add( basic::options::OptionKeys::full_model::rna::force_north_sugar_list, "optional: sample only north sugar for the res in sampler." ).def();
option.add( basic::options::OptionKeys::full_model::rna::force_south_sugar_list, "optional: sample only south sugar for the res in sampler." ).def();
option.add( basic::options::OptionKeys::full_model::rna::bulge_res, "optional: residues to be turned into a bulge variant" ).def();
option.add( basic::options::OptionKeys::full_model::rna::sample_sugar_res, "optional: residues in fixed input pose whose sugars can still move" ).def();
option.add( basic::options::OptionKeys::recces::seq1, "sequence 1 to model, 5' to 3' " ).def("");
option.add( basic::options::OptionKeys::recces::seq2, "sequence 2 to model, 5' to 3' " ).def("");
option.add( basic::options::OptionKeys::recces::n_cycle, "Number of cycles for random sampling Markov chain Monte Carlo" ).def(10000);
option.add( basic::options::OptionKeys::recces::a_form_range, "Range of sampling near A-form for duplexes in RECCES (turner)" ).def(60.0);
option.add( basic::options::OptionKeys::recces::dump_pdb, "Dump pdb files" ).def(false);
option.add( basic::options::OptionKeys::recces::dump_silent, "Dump structures to a silent file" ).def(false);
option.add( basic::options::OptionKeys::recces::out_torsions, "Print out torsion angles" ).def(false);
option.add( basic::options::OptionKeys::recces::temps, "Simulated tempering temperatures" ).def();
option.add( basic::options::OptionKeys::recces::st_weights, "Simulated tempering weights" ).def();
option.add( basic::options::OptionKeys::recces::save_score_terms, "Save scores and individual score terms of all sampled conformers" ).def(false);
option.add( basic::options::OptionKeys::recces::out_prefix, "prefix for the out file" ).def("recces");
option.add( basic::options::OptionKeys::recces::dump_freq, "Frequency to dump pdb or silent files" ).def(500);
option.add( basic::options::OptionKeys::recces::n_intermediate_dump, "Number of intermediate conformations to be dumped" ).def(0);
option.add( basic::options::OptionKeys::recces::output_min_pose, "Make last pose the minimum score pose ('recover low')" ).def(true);
option.add( basic::options::OptionKeys::recces::accept_no_op_moves, "override behavior where no_ops (e.g. for moving jump out of range) are not accepts" ).def(false);
option.add( basic::options::OptionKeys::recces::histogram_min, "Minimum energy for histogram" ).def(-100.05);
option.add( basic::options::OptionKeys::recces::histogram_max, "Maximum energy for histogram" ).def(+800.05);
option.add( basic::options::OptionKeys::recces::histogram_spacing, "Spacing for histogram" ).def(0.1);
option.add( basic::options::OptionKeys::recces::base_pair::base_pair, "base_pair option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::recces::base_pair::rmsd_cutoff, "base pair RMSD cutoff for jump sampling" ).def(2.0);
option.add( basic::options::OptionKeys::recces::base_pair::translation_mag, "magnitude of random translation moves" ).def(0.01);
option.add( basic::options::OptionKeys::recces::base_pair::rotation_mag, "magnitude of random rotation moves (in degrees)" ).def(1.0);
option.add( basic::options::OptionKeys::recces::base_pair::recces, "turn on RECCES in rb_entropy pilot app" ).def(false).is_group(true);
option.add( basic::options::OptionKeys::recces::base_pair::block_stack, "put block_stack atoms on test base pair" ).def(false);
option.add( basic::options::OptionKeys::recces::base_pair::sample_jump, "force base pair jump to be sampled when pose is setup vi -seq1, -seq2 (legacy turner mode)" ).def(false);
option.add( basic::options::OptionKeys::recces::thermal_sampling::thermal_sampling, "thermal_sampling option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::recces::thermal_sampling::sample_residues, "residues to sample" ).def();
option.add( basic::options::OptionKeys::recces::thermal_sampling::free_residues, "residues that are 'free,' affects stdev of chi sampler" ).def();
option.add( basic::options::OptionKeys::recces::thermal_sampling::loop_residues, "residues that are in loops and merit total BB sampling" ).def();
option.add( basic::options::OptionKeys::recces::thermal_sampling::angle_range_bb, "range bb torsions are allowed to move" ).def(20);
option.add( basic::options::OptionKeys::recces::thermal_sampling::angle_range_free_bb, "range free bb torsions are allowed to move" ).def(180);
option.add( basic::options::OptionKeys::recces::thermal_sampling::angle_range_chi, "range chi torsions are allowed to move" ).def(20);
option.add( basic::options::OptionKeys::recces::thermal_sampling::angle_range_free_chi, "range free chi torsions are allowed to move" ).def(180);
option.add( basic::options::OptionKeys::recces::thermal_sampling::chi_stdev, "standard deviation for chi sampler" ).def(20);
option.add( basic::options::OptionKeys::recces::thermal_sampling::bb_stdev, "standard deviation for backbone sampler" ).def(1);
option.add( basic::options::OptionKeys::recces::thermal_sampling::standard_bb_stdev, "standard deviation for standard backbone sampler" ).def(1);
option.add( basic::options::OptionKeys::recces::thermal_sampling::setup_base_pair_constraints, "Identify Watson/Crick pairs in input pose and put in constraints." ).def(false);
option.add( basic::options::OptionKeys::strand_assembly::strand_assembly, "strand_assembly option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::strand_assembly::min_num_strands_to_deal, "Minimum number of strands to handle beta-sandwich" );
option.add( basic::options::OptionKeys::strand_assembly::max_num_strands_to_deal, "Maximum number of strands to handle beta-sandwich" );
option.add( basic::options::OptionKeys::strand_assembly::extract_native_only, "if true, extract native full strands only" );
option.add( basic::options::OptionKeys::strand_assembly::min_res_in_strand, "minimum number of residues in a strand, for edge strand definition & analysis" );
option.add( basic::options::OptionKeys::strand_assembly::max_res_in_strand, "Maximum number of residues in a strand, for edge strand definition & analysis" );
option.add( basic::options::OptionKeys::strand_assembly::min_O_N_dis, "Minimum distance between backbone oxygen and backbone nitrogen" );
option.add( basic::options::OptionKeys::strand_assembly::max_O_N_dis, "Maximum distance between backbone oxygen and backbone nitrogen" );
option.add( basic::options::OptionKeys::strand_assembly::min_sheet_dis, "Minimum distance between sheets (CA and CA)" );
option.add( basic::options::OptionKeys::strand_assembly::max_sheet_dis, "Maximum distance between sheets (CA and CA)" );
option.add( basic::options::OptionKeys::strand_assembly::min_sheet_torsion, "Minimum torsion between sheets (CA and CA) with respect to terminal residues" );
option.add( basic::options::OptionKeys::strand_assembly::max_sheet_torsion, "Maximum torsion between sheets (CA and CA) with respect to terminal residues" );
option.add( basic::options::OptionKeys::strand_assembly::min_sheet_angle, "Minimum angle between sheets (CA and CA)" );
option.add( basic::options::OptionKeys::strand_assembly::max_sheet_angle, "Maximum angle between sheets (CA and CA)" );
option.add( basic::options::OptionKeys::strand_assembly::min_shortest_dis_sidechain_inter_sheet, "minimum distance between sidechains between sheets (pairs of strands)" );
option.add( basic::options::OptionKeys::TailSegment::TailSegment, "TailSegment option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::TailSegment::refine_cycles, "refinement phase runs for <input> cycles" ).def(100);
option.add( basic::options::OptionKeys::TailSegment::refine_repack_cycles, "refinement phase runs repack every <input> cycles" ).def(10);
option.add( basic::options::OptionKeys::templates::templates, "templates option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::templates::config, "read a list of templates and alignments" ).def("templates.dat");
option.add( basic::options::OptionKeys::templates::fix_aligned_residues, "pick only from template fragments and then keep these residues fixed" ).def(false);
option.add( basic::options::OptionKeys::templates::fix_frag_file, " fragments from this file are picked once in beginning and then kept fixed" ).def("");
option.add( basic::options::OptionKeys::templates::fix_margin, "keep n residues at edges of fixed fragments moveable" ).def(1);
option.add( basic::options::OptionKeys::templates::min_nr_large_frags, "how many large fragments should be present" ).def(100000);
option.add( basic::options::OptionKeys::templates::min_nr_small_frags, "how many small fragments should be present" ).def(100000);
option.add( basic::options::OptionKeys::templates::no_pick_fragments, "no further fragment picking from templates" ).def(false);
option.add( basic::options::OptionKeys::templates::nr_large_copies, "make N copies of each picked template fragment -- a hacky way to weight them" ).def(4);
option.add( basic::options::OptionKeys::templates::nr_small_copies, "make N copies of each picked template fragment -- a hacky way to weight them" ).def(20);
option.add( basic::options::OptionKeys::templates::pairings, "use pairings from templates" ).def(false);
option.add( basic::options::OptionKeys::templates::pick_multiple_sizes, "pick 9mers, 18mers and 27mers" ).def(false);
option.add( basic::options::OptionKeys::templates::strand_constraint, "use the template-based strand-constraints" ).def(false);
option.add( basic::options::OptionKeys::templates::vary_frag_size, "pick fragments as long as aligned regions" ).def(false);
option.add( basic::options::OptionKeys::templates::no_culling, "dont throw out constraints that are violated by other templates" ).def(false);
option.add( basic::options::OptionKeys::templates::helix_pairings, "file with list of pairings that are enforced (pick jumps from templates with H)" ).def("");
option.add( basic::options::OptionKeys::templates::prefix, "path for config directory -- applied to all filenames in template_config_file" ).def("");
option.add( basic::options::OptionKeys::templates::change_movemap, "stage in which movemap is switched to allow all bb-residues to move, valid stages: 3..4 (HACK)" ).def(3);
option.add( basic::options::OptionKeys::templates::force_native_topology, "force the native toplogy (geometries from templates)" ).def(false);

}
inline void add_rosetta_options_15( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::templates::topology_rank_cutoff, "select jumps from all topologies with a higher relative score than if 1.0 take top 5" ).def(1.0);
option.add( basic::options::OptionKeys::templates::min_frag_size, "smallest fragment picked from aligned template regions" ).def(6);
option.add( basic::options::OptionKeys::templates::max_shrink, "pick fragments up to max_shrink smaller than aligned regions" ).def(0);
option.add( basic::options::OptionKeys::templates::shrink_step, "shrink_step 5 , eg., 27mer 22mer 17mer" ).def(5);
option.add( basic::options::OptionKeys::templates::shrink_pos_step, "distance between start pos in shrinked fragments" ).def(5);
option.add( basic::options::OptionKeys::templates::min_padding, "minimum space between fragment and gap" ).def(0);
option.add( basic::options::OptionKeys::templates::min_align_pos, "ignore aligned residues before this position" ).def(0);
option.add( basic::options::OptionKeys::templates::max_align_pos, "ignore aligned residues after this position" ).def(-1);
option.add( basic::options::OptionKeys::templates::cst::cst, "cst option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::templates::cst::topN, "topN ranking models are used for constraints ( culling and source )" ).def(0);
option.add( basic::options::OptionKeys::templates::cst::wTopol, "weight for beta-pairing topology score in ranking" ).def(0.5);
option.add( basic::options::OptionKeys::templates::cst::wExtern, "weight for external score ( column in template_config_file, e.g, svn-score" ).def(0.5);
option.add( basic::options::OptionKeys::templates::fragsteal::fragsteal, "fragsteal option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::templates::fragsteal::topN, "topN ranking models are used for fragment stealing" ).def(0);
option.add( basic::options::OptionKeys::templates::fragsteal::wTopol, "weight for beta-pairing topology score in ranking" ).def(0.5);
option.add( basic::options::OptionKeys::templates::fragsteal::wExtern, "weight for external score ( column in template_config_file, e.g, svn-score" ).def(0.5);
option.add( basic::options::OptionKeys::unfolded_state::unfolded_state, "unfolded_state option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::unfolded_state::unfolded_energies_file, "path to an alternative unfolded state energies file" );
option.add( basic::options::OptionKeys::unfolded_state::split_unfolded_energies_file, "path to an alternative split unfolded state energies file" );
option.add( basic::options::OptionKeys::unfolded_state::split_unfolded_energies_atom_type, "name of the atom type specfied in the file defeined by the split_unfolded_energies_file option" ).legal("rosetta").legal("mm").legal("elemental").legal("pdb").legal("unique");
option.add( basic::options::OptionKeys::wum::wum, "wum option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::wum::n_slaves_per_master, "A value between 32 and 128 is usually recommended" ).def(64);
option.add( basic::options::OptionKeys::wum::n_masters, "Manual override for -n_slaves_per_master. How many master nodes should be spawned ? 1 by default. generall 1 for eery 256-512 cores is recommended depending on master workload" ).def(1);
option.add( basic::options::OptionKeys::wum::memory_limit, "Memory limit for queues (in kB) " ).def(0);
option.add( basic::options::OptionKeys::wum::extra_scorefxn, "Extra score function for post-batchrelax-rescoring" );
option.add( basic::options::OptionKeys::wum::extra_scorefxn_ref_structure, "Extra score function for post-batchrelax-rescoring reference structure for superimposition (for scorefunctions that depend on absolute coordinates such as electron denisty)" );
option.add( basic::options::OptionKeys::wum::extra_scorefxn_relax, "After doing batch relax and adding any extra_scorefunction terms do another N fast relax rounds (defaut=0)" ).def(0);
option.add( basic::options::OptionKeys::wum::trim_proportion, "No description" ).def(0.0);
option.add( basic::options::OptionKeys::blivens::blivens, "blivens option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::blivens::disulfide_scorer::disulfide_scorer, "disulfide_scorer option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::blivens::disulfide_scorer::nds_prob, "The probability of scoring a non-disulfide pair" ).def(0.0);
option.add( basic::options::OptionKeys::blivens::disulfide_scorer::cys_prob, "The probability of outputing a pair of non-disulf cysteines. Default to nds_prob" ).def(-1.0);
option.add( basic::options::OptionKeys::blivens::score_type, "The scoring type to use, eg for a filter." ).def("total_score");
option.add( basic::options::OptionKeys::cmiles::cmiles, "cmiles option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cmiles::kcluster::kcluster, "kcluster option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cmiles::kcluster::num_clusters, "Number of clusters to use during k clustering" );
option.add( basic::options::OptionKeys::cmiles::jumping::jumping, "jumping option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::cmiles::jumping::resi, "Residue i" );
option.add( basic::options::OptionKeys::cmiles::jumping::resj, "Residue j" );
option.add( basic::options::OptionKeys::crossmatch::crossmatch, "crossmatch option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::crossmatch::clash_dis, "" ).def(3.0);
option.add( basic::options::OptionKeys::dwkulp::dwkulp, "dwkulp option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::dwkulp::forcePolyAAfragments, "a single amino acid that will be used for fragment picking,default is blank which means taking actual sequence from pose" ).def("");
option.add( basic::options::OptionKeys::evolution::evolution, "evolution option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::evolution::parentlist, "File(s) containing list(s) of Parent PDB files to process" );
option.add( basic::options::OptionKeys::evolution::childlist, "File(s) containing list(s) of Parent PDB files to process" );
option.add( basic::options::OptionKeys::evolution::action, "One of the following:  diversify, intensify " ).def("diversify");
option.add( basic::options::OptionKeys::evolution::rms_threshold, "RMS Clustering threshold" ).def(3.5);
option.add( basic::options::OptionKeys::evolution::rms_topmargin, "RMS Clustering threshold" ).def(5.0);
option.add( basic::options::OptionKeys::evolution::targetdir, "Write target new parent polulation to this directory ! " ).def("./");
option.add( basic::options::OptionKeys::evolution::padding_score_filter, "RMS Clustering threshold" ).def(5.0);
option.add( basic::options::OptionKeys::evolution::padding_stage2_filter, "RMS Clustering threshold" ).def(15.0);
option.add( basic::options::OptionKeys::james::james, "james option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::james::min_seqsep, "No description" ).def(0);
option.add( basic::options::OptionKeys::james::atom_names, "No description" ).def(utility::vector1<std::string>());
option.add( basic::options::OptionKeys::james::dist_thresholds, "No description" ).def(utility::vector1<float>(1, 1.0));
option.add( basic::options::OptionKeys::james::torsion_thresholds, "No description" ).def(utility::vector1<float>(1, 30.0));
option.add( basic::options::OptionKeys::james::debug, "No description" ).def(false);
option.add( basic::options::OptionKeys::james::real, "Option for keeping things real." ).def(7.0);
option.add( basic::options::OptionKeys::james::n_designs, "total number of designs that James should make." ).def(1);
option.add( basic::options::OptionKeys::james::thread_unaligned, "basic_threading without performing an alignment" ).def(false);
option.add( basic::options::OptionKeys::krassk::krassk, "krassk option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::krassk::tail_mode, "No description" ).def(false);
option.add( basic::options::OptionKeys::krassk::tail_mode_name, "No description" ).def(1);
option.add( basic::options::OptionKeys::krassk::tail_output_file_name, "No description" ).def("tail_output");
option.add( basic::options::OptionKeys::loodo::loodo, "loodo option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::loodo::ins_begin, "insertion site (pose numbering)" );
option.add( basic::options::OptionKeys::loodo::cap, "cap pdb" ).def("");
option.add( basic::options::OptionKeys::loodo::bot, "bot pdb" ).def("");
option.add( basic::options::OptionKeys::loodo::fragAlength, "lengths for loop A" );
option.add( basic::options::OptionKeys::loodo::fragBlength, "lengths for loop B" );
option.add( basic::options::OptionKeys::loodo::known, "length of known interior region" );
option.add( basic::options::OptionKeys::loodo::fragAnative, "native loop A pdb file" ).def("");
option.add( basic::options::OptionKeys::loodo::fragBnative, "native loop B pdb file" ).def("");
option.add( basic::options::OptionKeys::loodo::gridligpath, "path to gridlig file" ).def("");
option.add( basic::options::OptionKeys::loodo::debug, "dump CapHitB pdbs" ).def(false);
option.add( basic::options::OptionKeys::loodo::ca_ratio, "fraction of C-alphas required in active site grid" ).def(0.5);
option.add( basic::options::OptionKeys::loodo::distance_tolerance, "distance cutoff for pairwise Real6 x,y,z comparisons" ).def(5.0);
option.add( basic::options::OptionKeys::loodo::euler_tolerance, "angle cutoff for pairwise Real6 euler angle comparisons" ).def(15.0);
option.add( basic::options::OptionKeys::loodo::num_frags, "number fragments to pick per frame in library" ).def(4500);
option.add( basic::options::OptionKeys::loodo::use_fraglib, "fragment library to use instead of vall database" );
option.add( basic::options::OptionKeys::loodo::use_fraglibsc, "fragment library to use instead of vall database with sidechain torsions specified" );
option.add( basic::options::OptionKeys::loodo::com_in_grid, "cap center-of-mass required to lie in placement grid" ).def(false);
option.add( basic::options::OptionKeys::loodo::loud, "loud output?" ).def(false);
option.add( basic::options::OptionKeys::loodo::dump_all_As, "dump passing As" ).def(false);
option.add( basic::options::OptionKeys::loodo::dump_all_Bs, "dump passing Bs" ).def(false);
option.add( basic::options::OptionKeys::loodo::caphit_rt_file, "name of CapHit_RT or filtered CapHitRT file" );
option.add( basic::options::OptionKeys::murphp::murphp, "murphp option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::murphp::inv_kin_lig_loop_design_filename, "input filename to be used for inv_kin_lig_loop_design" );
option.add( basic::options::OptionKeys::peptide_deriver::peptide_deriver, "peptide_deriver option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::peptide_deriver::pep_lengths, "Length(s) of derived peptides" ).def(10);
option.add( basic::options::OptionKeys::peptide_deriver::skip_zero_isc, "Makes derivation go faster by skipping peptides with 0 interface score" ).def(true);
option.add( basic::options::OptionKeys::peptide_deriver::dump_peptide_pose, "Output pose with peptide cut out (best one for each chain pair)" ).def(false);
option.add( basic::options::OptionKeys::peptide_deriver::dump_cyclic_poses, "Output each cyclic peptide pose (those that are modeled; which is determined by -optimize_cyclic_threshold)" ).def(false);
option.add( basic::options::OptionKeys::peptide_deriver::dump_prepared_pose, "Output each receptor-partner pose as Peptiderive sees it, i.e. after preparation (minimization and disulfide detection)" ).def(false);
option.add( basic::options::OptionKeys::peptide_deriver::dump_report_file, "Send PeptideDeriver output to a file (<input_name>.peptiderive.txt)" ).def(true);
option.add( basic::options::OptionKeys::peptide_deriver::restrict_receptors_to_chains, "Only use chains listed here as receptors. When empty, consider all chains." ).def();
option.add( basic::options::OptionKeys::peptide_deriver::restrict_partners_to_chains, "Only use chains listed here as partners. When empty, consider all chains. For each receptor-partner pair, a peptide is derived from the partner." ).def();
option.add( basic::options::OptionKeys::peptide_deriver::do_minimize, "Perform minimization before everything." ).def(true);
option.add( basic::options::OptionKeys::peptide_deriver::optimize_cyclic_threshold, "Choose value of peptide interface score percent of total isc from which to optimize cyclic peptide" ).def(0.35);
option.add( basic::options::OptionKeys::peptide_deriver::report_format, "The format of the report. Either 'basic' (easily parsable format) or 'markdown' (pretty, readable, but verbose format)." ).def("markdown");
option.add( basic::options::OptionKeys::peptide_deriver::report_gzip, "Gzip report file (only if -dump_report_file is enabled)" ).def(false);
option.add( basic::options::OptionKeys::phil::phil, "phil option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::phil::nloop, "No description" ).def(10);
option.add( basic::options::OptionKeys::phil::vall_file, "No description" );
option.add( basic::options::OptionKeys::robert::robert, "robert option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::robert::pairdata_input_pdb_list, "Takes in a file containing a list of pdb locations paired with protocol specific data (eg: one disulfide pair)" ).def("");
option.add( basic::options::OptionKeys::robert::pcs_maxsub_filter, "minimum normalized maxsub for PCS clustering protocol" ).def(0.9);
option.add( basic::options::OptionKeys::robert::pcs_maxsub_rmsd, "maxsub calculation's rmsd threshold" ).def(4.0);
option.add( basic::options::OptionKeys::robert::pcs_dump_cluster, "No description" ).def(false);
option.add( basic::options::OptionKeys::robert::pcs_cluster_coverage, "cluster coverage required" ).def(0.3);
option.add( basic::options::OptionKeys::robert::pcs_cluster_lowscoring, "cluster lowest 20% against lowest 50%" ).def(true);
option.add( basic::options::OptionKeys::rot_anl::rot_anl, "rot_anl option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::rot_anl::tag, "nametag" ).def(".");
option.add( basic::options::OptionKeys::rot_anl::min, "do sc min" ).def(false);
option.add( basic::options::OptionKeys::rot_anl::repack, "" ).def(false);
option.add( basic::options::OptionKeys::rot_anl::rtmin, "" ).def(false);
option.add( basic::options::OptionKeys::rot_anl::scmove, "" ).def(false);
option.add( basic::options::OptionKeys::rot_anl::design, "" ).def(false);
option.add( basic::options::OptionKeys::rot_anl::dump_pdb, "dump_pdb when pass thresh" ).def(false);
option.add( basic::options::OptionKeys::rot_anl::nloop_scmove, "base of scmover loop (total=nloop^n_chi)" ).def(9);
option.add( basic::options::OptionKeys::smhybrid::smhybrid, "smhybrid option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::smhybrid::add_cavities, "output cavities in result pdbs" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::abinitio_design, "do a design run in centroid mode" ).def(true);
option.add( basic::options::OptionKeys::smhybrid::fa_refine, "Do nobu's flxbb" ).def(true);
option.add( basic::options::OptionKeys::smhybrid::virtual_nterm, "remove Nterm" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::debug, "debug" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::refine, "don't do bit centroid moves" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::centroid_all_val, "mutate all to VAL in centroid mode" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::subsubs_attract, "attract subsubs togeher" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::linker_cst, "attract N/C termini for linker" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::pseudosym, "HACK pseudosymmetry" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::design_linker, "allow design on added 'linker' residues" ).def(true);
option.add( basic::options::OptionKeys::smhybrid::design, "allow design on added 'linker' residues" ).def(true);
option.add( basic::options::OptionKeys::smhybrid::restrict_design_to_interface, "allow design on added 'linker' residues" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::restrict_design_to_subsub_interface, "allow design on added 'linker' residues" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::design_hydrophobic, "design all hydrophobic" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::add_metal_at_0, "DEPRECATED" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::nres_mono, "target number of residues per monomer" ).def(20);
option.add( basic::options::OptionKeys::smhybrid::abinitio_cycles, "number of abinitio cycles" ).def(10000);
option.add( basic::options::OptionKeys::smhybrid::primary_subsubunit, "primary subunut" ).def(1);
option.add( basic::options::OptionKeys::smhybrid::minbb, "level of bb min 0=None 1=little 2=all" ).def(1);
option.add( basic::options::OptionKeys::smhybrid::switch_concert_sub, "assume prmary subsub is on this subunit for concerted RB moves" ).def(1);
option.add( basic::options::OptionKeys::smhybrid::temperature, "MC temp for cen fold" ).def(2.0);
option.add( basic::options::OptionKeys::smhybrid::inter_subsub_cst, "add dis csts inter-subsub" ).def(false);
option.add( basic::options::OptionKeys::smhybrid::rb_mag, "magnitude of rb moves" ).def(1.0);
option.add( basic::options::OptionKeys::smhybrid::symm_def_template, "template for symmetry definition file" );
option.add( basic::options::OptionKeys::smhybrid::symm_def_template_reduced, "template for reduced symmetry definition file" );
option.add( basic::options::OptionKeys::smhybrid::attach_as_sc, "attach the group via side chain" );
option.add( basic::options::OptionKeys::smhybrid::attach_as_sc_sub, "attach the group via side chain in this sub" );
option.add( basic::options::OptionKeys::smhybrid::chainbreaks, "close chainbreak from this subsub to the next" );
option.add( basic::options::OptionKeys::smhybrid::design_res_files, "files containing designable residues for each component pose" ).def("");
option.add( basic::options::OptionKeys::smhybrid::fixed_res_files, "files containing fixed residues (no repack even) for each component pose" ).def("");
option.add( basic::options::OptionKeys::smhybrid::frag_res_files, "files containing residues ok to insert frags into. will have starting ss" ).def("");
option.add( basic::options::OptionKeys::smhybrid::scattach_res_files, "files containing residues ok to scattach to." ).def("");
option.add( basic::options::OptionKeys::smhybrid::rep_edge_files, "files containing residues which are edge strands." ).def("");
option.add( basic::options::OptionKeys::smhybrid::virtual_res_files, "files containing residues that should be virtual" ).def("");
option.add( basic::options::OptionKeys::smhybrid::jumpcut_files, "file specifying jumps and cuts for subsubunits" ).def("");
option.add( basic::options::OptionKeys::smhybrid::cst_sub_files, "file specifying which subunits are part of a structural unit and shoudl be constrained" ).def("");
option.add( basic::options::OptionKeys::smhybrid::symm_file_tag, "label for each subunit" ).def("");
option.add( basic::options::OptionKeys::smhybrid::attach_atom, "attach atom on each subunit" ).def("");
option.add( basic::options::OptionKeys::smhybrid::add_res_before, "SS to add before each subunit region" ).def("");
option.add( basic::options::OptionKeys::smhybrid::add_res_after, "SS to add after each subunit region" ).def("");
option.add( basic::options::OptionKeys::smhybrid::add_ss_before, "residues to add" ).def("");
option.add( basic::options::OptionKeys::smhybrid::add_ss_after, "SS to add after each subunit region" ).def("");
option.add( basic::options::OptionKeys::smhybrid::add_atom_at_cen, "SS to add after each subunit region" ).def("");
option.add( basic::options::OptionKeys::smhybrid::attach_rsd, "attach rsd on each subunit" ).def("");
option.add( basic::options::OptionKeys::threadsc::threadsc, "threadsc option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::threadsc::src_chain, "Chain of source pdb" ).shortd( "Chain of source pdb" );
option.add( basic::options::OptionKeys::threadsc::trg_chain, "Chain of target pdb" ).shortd( "Chain of target pdb" );
option.add( basic::options::OptionKeys::threadsc::src_first_resid, "Residue id of first residue in source pdb range" ).shortd( "Residue id of first residue in source pdb range" );
option.add( basic::options::OptionKeys::threadsc::trg_first_resid, "Residue id of first residue in source pdb range" ).shortd( "Residue id of first residue in source pdb range" );
option.add( basic::options::OptionKeys::threadsc::nres, "Number of residues to be threaded" ).shortd( "Number of residues to be threaded" );
option.add( basic::options::OptionKeys::threadsc::trg_anchor, "anchor residue for backbone threading" ).shortd( "anchor residue for backbone threading" );
option.add( basic::options::OptionKeys::ufv::ufv, "ufv option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::ufv::left, "left endpoint" );
option.add( basic::options::OptionKeys::ufv::right, "right endpoint" );
option.add( basic::options::OptionKeys::ufv::ss, "secondary structure string" );
option.add( basic::options::OptionKeys::ufv::aa_during_build, "amino acid string during centroid build" );
option.add( basic::options::OptionKeys::ufv::aa_during_design_refine, "amino acid string during design-refine" );
option.add( basic::options::OptionKeys::ufv::keep_junction_torsions, "when rebuilding loops, keep (approx) the original torsions at the junctions of the loop endpoints" ).def(false);
option.add( basic::options::OptionKeys::ufv::ufv_loops, "use this multiple loop file in place of specifying single loop options on command line" );
option.add( basic::options::OptionKeys::ufv::use_fullmer, "use full-mer fragments when building loop" ).def(false);
option.add( basic::options::OptionKeys::ufv::centroid_loop_mover, "the centroid loop mover to use" ).def("RemodelLoopMover");
option.add( basic::options::OptionKeys::ufv::no_neighborhood_design, "only repack the neighborhood of the loop, don't design" ).def(false);
option.add( basic::options::OptionKeys::ufv::dr_cycles, "design-refine cycles" ).def(3);
option.add( basic::options::OptionKeys::ufv::centroid_sfx, "filename of the centroid score function to use," );
option.add( basic::options::OptionKeys::ufv::centroid_sfx_patch, "filename of the centroid score function patch to use," );
option.add( basic::options::OptionKeys::ufv::fullatom_sfx, "filename of the full-atom score function to use" );
option.add( basic::options::OptionKeys::ufv::fullatom_sfx_patch, "filename of the full-atom score function patch to use" );
option.add( basic::options::OptionKeys::ufv::insert::insert, "insert option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::ufv::insert::insert_pdb, "pdb of insert structure" );
option.add( basic::options::OptionKeys::ufv::insert::attached_pdb, "pdb of structure in rigid body relationship with insert structure" );
option.add( basic::options::OptionKeys::ufv::insert::connection_scheme, "enforce type of insertion: choose either n2c or c2n" );
option.add( basic::options::OptionKeys::willmatch::willmatch, "willmatch option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::willmatch::write_reduced_matchset, "<name> <pdb1> <pdb2> ..." );
option.add( basic::options::OptionKeys::willmatch::interface_size, "num CB-CB within 8A" ).def(30);
option.add( basic::options::OptionKeys::willmatch::max_dis_any, "" ).def(3.0);
option.add( basic::options::OptionKeys::willmatch::max_dis_all, "" ).def(2.6);
option.add( basic::options::OptionKeys::willmatch::max_dis_hb, "" ).def(3.2);
option.add( basic::options::OptionKeys::willmatch::min_dis_hb, "" ).def(2.2);
option.add( basic::options::OptionKeys::willmatch::max_dis_hb_colinear, "" ).def(0.7);
option.add( basic::options::OptionKeys::willmatch::max_dis_metal, "" ).def(1.0);
option.add( basic::options::OptionKeys::willmatch::max_ang_metal, "" ).def(5.0);
option.add( basic::options::OptionKeys::willmatch::clash_dis, "" ).def(3.5);
option.add( basic::options::OptionKeys::willmatch::c2_linker_dist, "" ).def(3.5);
option.add( basic::options::OptionKeys::willmatch::identical_match_dis, "" ).def(0.0001);
option.add( basic::options::OptionKeys::willmatch::chi1_increment, "" ).def(10.0);
option.add( basic::options::OptionKeys::willmatch::chi2_increment, "" ).def(20.0);
option.add( basic::options::OptionKeys::willmatch::c2_symm_increment, "" ).def(20.0);
option.add( basic::options::OptionKeys::willmatch::cb_sasa_thresh, "" ).def(20.0);
option.add( basic::options::OptionKeys::willmatch::design_interface, "" ).def(true);
option.add( basic::options::OptionKeys::willmatch::chilist, "" );
option.add( basic::options::OptionKeys::willmatch::fixed_res, "" );
option.add( basic::options::OptionKeys::willmatch::native1, "" );
option.add( basic::options::OptionKeys::willmatch::native2, "" );
option.add( basic::options::OptionKeys::willmatch::exclude_res1, "" ).def("");
option.add( basic::options::OptionKeys::willmatch::exclude_res2, "" ).def("");
option.add( basic::options::OptionKeys::willmatch::taglist, "" );
option.add( basic::options::OptionKeys::willmatch::residues, "" );
option.add( basic::options::OptionKeys::willmatch::symmetry_d2, "" ).def(false);
option.add( basic::options::OptionKeys::willmatch::symmetry_c2_dock, "" ).def(false);
option.add( basic::options::OptionKeys::willmatch::splitwork, "" );
option.add( basic::options::OptionKeys::willmatch::exclude_ala, "" ).def(false);
option.add( basic::options::OptionKeys::willmatch::match_overlap_dis, "distance under which to consider matches redundant" ).def(00.20);
option.add( basic::options::OptionKeys::willmatch::match_overlap_ang, "ang(deg) under which to consider matches redundant" ).def(10.00);
option.add( basic::options::OptionKeys::willmatch::forbid_residues, "disallow residues for matching" );
option.add( basic::options::OptionKeys::willmatch::poi, "xyz coords of some site of interest" );
option.add( basic::options::OptionKeys::willmatch::poidis, "poi distance threshold" );
option.add( basic::options::OptionKeys::willmatch::homodimer, "examine only homodimer configs" ).def(false);
option.add( basic::options::OptionKeys::willmatch::fa_dun_thresh, "" ).def(6.0);
option.add( basic::options::OptionKeys::testing::testing, "testing option group" ).legal(true).def(true).is_group(true);
option.add( basic::options::OptionKeys::testing::HCF, "Cause Rosetta to exit immediately with an error." ).def(false);

}

inline void add_all_rosetta_options( utility::options::OptionCollection &option ) {
	add_rosetta_options_0( option );
	add_rosetta_options_1( option );
	add_rosetta_options_2( option );
	add_rosetta_options_3( option );
	add_rosetta_options_4( option );
	add_rosetta_options_5( option );
	add_rosetta_options_6( option );
	add_rosetta_options_7( option );
	add_rosetta_options_8( option );
	add_rosetta_options_9( option );
	add_rosetta_options_10( option );
	add_rosetta_options_11( option );
	add_rosetta_options_12( option );
	add_rosetta_options_13( option );
	add_rosetta_options_14( option );
	add_rosetta_options_15( option );
}
#endif
